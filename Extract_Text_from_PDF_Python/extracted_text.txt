C++:The Complete Reference,Fourth EditionAbout the AuthorHerbert Schildtisthe
world’sleadingprogramming
author.HeisanauthorityontheC,C++,Java,andC#
languages,andisamasterWindowsprogrammer.His

programmingbookshavesoldmorethan3million

copiesworldwideandhavebeentranslatedintoall

majorforeignlanguages.Heistheauthorofnumerous

bestsellers,including
C++: TheComplete Reference, C#:
The Complete Reference,Java 2: The Complete Reference,

C: The CompleteReference,C++ from the Ground Up,

C++: ABeginner’s Guide, C#: ABeginner’s Guide,
andJava 2: ABeginner’s Guide
. Schildt holds a master’s

degree in computer science from the University of

Illinois. He can be reached at his consulting office at

(217) 586-4683.Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
C++:The Complete Reference,Fourth EditionHerbert SchildtMcGraw-Hill/OsborneNew YorkChicagoSan Francisco
LisbonLondonMadridMexico City
MilanNew DelhiSan Juan
SeoulSingaporeSydneyToronto
Copyright © 2003 by The McGraw-Hill Companies. All rights reserved. Manufactured in the United States of America. Except as per
-mitted under the United States Copyright Act of 1976, no part of this publication may be reproduced or distributed in any form 
or by any
means, or stored in a database or retrieval system, without the prior written permission of the publisher. 
0-07-150239-4
The material in this eBook also appears in the print version of this title: 0-07-222680-3.

All trademarks are trademarks of their respective owners. Rather than put a trademark symbol after every occurrence of a tradem
arked
name, we use names in an editorial fashion only, and to the benefit of the trademark owner, with no intention of infringement of the 

trademark. Where such designations appear in this book, they have been printed with initial caps. 
McGraw-Hill eBooks are available at special quantity discounts to use as premiums and sales promotions, or for use in corporate
 training programs. For more information, please contact George Hoare, Special Sales, at george_hoare@mcgraw-hill.com or 
(212) 904-4069. TERMS OF USE 
This is a copyrighted work and The McGraw-Hill Companies, Inc. (ÒMcGraw-HillÓ) and its licensors reserve all rights in and to t
he work.
Use of this work is subject to these terms. Except as permitted under the Copyright Act of 1976 and the right to store and retrieve one
copy of the work, you may not decompile, disassemble, reverse engineer, reproduce, modify, create derivative works based upon, 
trans-mit, distribute, disseminate, sell, publish or sublicense the work or any part of it without McGraw-HillÕs prior consent. You m
ay use the
work for your own noncommercial and personal use; any other use of the work is strictly prohibited. Your right to use the work 
may be
terminated if you fail to comply with these terms. 
THE WORK IS PROVIDED ÒAS IS.Ó McGRAW-HILL AND ITS LICENSORS MAKE NO GUARANTEES OR WARRANTIES AS TO
THE ACCURACY, ADEQUACY OR COMPLETENESS OF OR RESULTS TO BE OBTAINED FROM USING THE WORK,

INCLUDING ANY INFORMATION THAT CAN BE ACCESSED THROUGH THE WORK VIA HYPERLINK OR OTHERWISE,

AND EXPRESSLY DISCLAIM ANY WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WAR-

RANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. McGraw-Hill and its licensors do not warrant

or guarantee that the functions contained in the work will meet your requirements or that its operation will be uninterrupted o
r error free.
Neither McGraw-Hill nor its licensors shall be liable to you or anyone else for any inaccuracy, error or omission, regardless of cause, in

the work or for any damages resulting therefrom. McGraw-Hill has no responsibility for the content of any information accessed 
throughthe work. Under no circumstances shall McGraw-Hill and/or its licensors be liable for any indirect, incidental, special, puniti
ve, conse-
quential or similar damages that result from the use of or inability to use the work, even if any of them has been advised of the possibil-

ity of such damages. This limitation of liability shall apply to any claim or cause whatsoever whether such claim or cause arises in con-

tract, tort or otherwise. 
DOI: 10.1036/0072226803We hope you enjoy this
McGraw-Hill eBook! IfyouÕd like more information about this book,
its author, or related books and websites,

please click here.ProfessionalWant to learn more?
Contents at a GlancePart I
The Foundation of C++: The C Subset1An Overview of C. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3
2Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .13
3Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .57
4Arrays and Null-Terminated Strings. . . . . . . . . . . . . . . .89
5Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .113
6Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .137
7Structures, Unions, Enumerations,
and User-Defined Types. . . . . . . . . . . . . . . . . . . . . . . .161
8C-Style Console I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .187
9File I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .211
10The Preprocessor and Comments. . . . . . . . . . . . . . . . . .237
Part II
C++11An Overview of C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . .255
12Classes and Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .289
v13Arrays, Pointers, References, and the Dynamic
Allocation Operators. . . . . . . . . . . . . . . . . . . . . . . . . . .325
14Function Overloading, Copy Constructors,
and Default Arguments. . . . . . . . . . . . . . . . . . . . . . . . .359
15Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . .383
16Inheritance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .417
17Virtual Functions and Polymorphism. . . . . . . . . . . . . . .443
18Templates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .459
19Exception Handling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .487
20The C++ I/O System Basics. . . . . . . . . . . . . . . . . . . . . . .509
21C++ File I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .539
22Run-Time Type ID and the Casting Operators. . . . . . .567
23Namespaces, Conversion Functions,and Other Advanced Topics. . . . . . . . . . . . . . . . . . . . .591
24Introducing the Standard Template Library. . . . . . . . . .629
Part III
The Standard Function Library
25The C-Based I/O Functions. . . . . . . . . . . . . . . . . . . . . . .699
26The String and Character Functions. . . . . . . . . . . . . . . .723
27The Mathematical Functions. . . . . . . . . . . . . . . . . . . . . .737
28Time, Date, and Localization Functions. . . . . . . . . . . . .747
29The Dynamic Allocation Functions. . . . . . . . . . . . . . . . .757
30Utility Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .761
31The Wide-Character Functions. . . . . . . . . . . . . . . . . . . . .775
Part IV
The Standard C++ Class Library
32The Standard C++ I/O Classes. . . . . . . . . . . . . . . . . . . .787
33The STLContainer Classes. . . . . . . . . . . . . . . . . . . . . . . .811
34The STLAlgorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .839
35STLIterators, Allocators, and Function Objects. . . . . .861
36The String Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .881
37The Numeric Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . .897
38Exception Handling and Miscellaneous Classes. . . . . .925
viC++:TheCompleteReference
Part V
Applying C++39Integrating New Classes: A Custom String Class. . . . .935
40Parsing Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .963
AThe .NET Managed Extensions to C++. . . . . . . . . . . . . .999
BC++ and the Robotics Age. . . . . . . . . . . . . . . . . . . . . . . .1005
Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1009
ContentsataGlance
viiThis page intentionally left blank ContentsIntroduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xxix
Part I
The Foundation of C++: The C Subset1An Overview of C. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3
The Origins and History of C. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4
C Is a Middle-Level Language. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5

C Is a Structured Language. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6

C Is a Programmer’s Language. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .8

The Form of a C Program. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9

The Library and Linking. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10

Separate Compilation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12

Understanding the .C and .CPPFile Extensions. . . . . . . . . . . . . . . .12
2Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .13
The Five Basic Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14

Modifying the Basic Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .15

Identifier Names. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .16

Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .17
Where Variables Are Declared. . . . . . . . . . . . . . . . . . . . . . . .18

Local Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .18
ixFor more information about this title, click herexC++:TheCompleteReference
Formal Parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21
Global Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21
The const and volatile Qualifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . .23
const. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .23

volatile. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .24
Storage Class Specifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25
extern. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25

static Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .28

register Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .30
Variable Initializations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .31

Constants. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .32
Hexadecimal and Octal Constants. . . . . . . . . . . . . . . . . . . .33

String Constants. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .33

Backslash Character Constants. . . . . . . . . . . . . . . . . . . . . . .33
Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .35
The Assignment Operator. . . . . . . . . . . . . . . . . . . . . . . . . . .35

Type Conversion in Assignments. . . . . . . . . . . . . . . . . . . . .35

Multiple Assignments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .37

Arithmetic Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .37

Increment and Decrement. . . . . . . . . . . . . . . . . . . . . . . . . . .38

Relational and Logical Operators. . . . . . . . . . . . . . . . . . . . .40

Bitwise Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .42

The ? Operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .47

The & and * Pointer Operators. . . . . . . . . . . . . . . . . . . . . . .48

The Compile-Time Operator sizeof. . . . . . . . . . . . . . . . . . .50

The Comma Operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .50

The Dot (.) and Arrow (
−>) Operators. . . . . . . . . . . . . . . . .51
The [ ] and ( ) Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . .51

Precedence Summary. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .52
Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .52
Order of Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .52

Type Conversion in Expressions. . . . . . . . . . . . . . . . . . . . . .53

Casts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .54

Spacing and Parentheses. . . . . . . . . . . . . . . . . . . . . . . . . . . .55

Compound Assignments. . . . . . . . . . . . . . . . . . . . . . . . . . . .56
3Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .57
True and False in C and C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .58

Selection Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .59
if. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .59

Nested ifs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .60

The if-else-if Ladder. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .62

The ? Alternative. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .63

The Conditional Expression. . . . . . . . . . . . . . . . . . . . . . . . . .66
Contentsxiswitch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .67
Nested switch Statements. . . . . . . . . . . . . . . . . . . . . . . . . . .70
Iteration Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .70
The for Loop. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .70

for Loop Variations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .72

The Infinite Loop. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .76

for Loops with No Bodies. . . . . . . . . . . . . . . . . . . . . . . . . . .77

The while Loop. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .77

The do-while Loop. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .79
Declaring Variables Within Selection and Iteration Statements. . .81

Jump Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .82
The return Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .82

The goto Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .83

The break Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .83

The exit( ) Function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .85

The continue Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . .86
Expression Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .88

Block Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .88
4Arrays and Null-Terminated Strings. . . . . . . . . . . . . . . .89
Single-Dimension Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .90

Generating a Pointer to an Array. . . . . . . . . . . . . . . . . . . . . . . . . . . .92

Passing Single-Dimension Arrays to Functions. . . . . . . . . . . . . . . .92

Null-Terminated Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .94

Two-Dimensional Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .96
Arrays of Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .100
Multidimensional Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .101

Indexing Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .102

Array Initialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .105
Unsized Array Initializations. . . . . . . . . . . . . . . . . . . . . . . . .106
ATic-Tac-Toe Example. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .108
5Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .113
What Are Pointers?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .114

Pointer Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .115

The Pointer Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .115

Pointer Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .116
Pointer Assignments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .117

Pointer Arithmetic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .117

Pointer Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .119
Pointers and Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .121
Arrays of Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .122
Multiple Indirection. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .123

Initializing Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .125

Pointers to Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .126
xiiC++:TheCompleteReference
C's Dynamic Allocation Functions. . . . . . . . . . . . . . . . . . . . . . . . . . .129
Problems with Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .131
6Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .137
The General Form of a Function. . . . . . . . . . . . . . . . . . . . . . . . . . . . .138

Scope Rules of Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .138

Function Arguments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .139
Call by Value, Call by Reference. . . . . . . . . . . . . . . . . . . . . .139

Creating a Call by Reference. . . . . . . . . . . . . . . . . . . . . . . . .140

Calling Functions with Arrays. . . . . . . . . . . . . . . . . . . . . . .142
argc and argv—Arguments to main( ). . . . . . . . . . . . . . . . . . . . . . . .144

The return Statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .147
Returning from a Function. . . . . . . . . . . . . . . . . . . . . . . . . . .148

Returning Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .149

Returning Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .151

Functions of Type void. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .152

What Does main( ) Return?. . . . . . . . . . . . . . . . . . . . . . . . . .153
Recursion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .153

Function Prototypes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .155
Standard Library Function Prototypes. . . . . . . . . . . . . . . . .157
Declaring Variable-Length Parameter Lists. . . . . . . . . . . . . . . . . . . .158

Old-Style Versus Modern FunctionParameter Declarations. . . . . .158
7Structures, Unions, Enumerations,
and User-Defined Types. . . . . . . . . . . . . . . . . . . . . . . . .161
Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .162
Accessing Structure Members. . . . . . . . . . . . . . . . . . . . . . . .165

Structure Assignments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .165
Arrays of Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .166

Passing Structures to Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .167
Passing Structure Members to Functions. . . . . . . . . . . . . . .167

Passing Entire Structures to Functions. . . . . . . . . . . . . . . . .168
Structure Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .169
Declaring a Structure Pointer. . . . . . . . . . . . . . . . . . . . . . . . .170

Using Structure Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . .170
Arrays and Structures Within Structures. . . . . . . . . . . . . . . . . . . . . .173

Bit-Fields. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .174

Unions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .176

Enumerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .180

Using sizeof to Ensure Portability. . . . . . . . . . . . . . . . . . . . . . . . . . . .183

typedef. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .184
8C-Style Console I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .187
An Important Application Note. . . . . . . . . . . . . . . . . . . . . . . . . . . . .188
ContentsxiiiReading and Writing Characters. . . . . . . . . . . . . . . . . . . . . . . . . . . . .189
AProblem with getchar( ). . . . . . . . . . . . . . . . . . . . . . . . . . .190
Alternatives to getchar( ). . . . . . . . . . . . . . . . . . . . . . . . . . . .190
Reading and Writing Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .192

Formatted Console I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .195

printf( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .195
Printing Characters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .196

Printing Numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .196

Displaying an Address. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .198

The %nSpecifier. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .198

Format Modifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .199

The Minimum Field Width Specifier. . . . . . . . . . . . . . . . . .199

The Precision Specifier. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .200

Justifying Output. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .201

Handling Other Data Types. . . . . . . . . . . . . . . . . . . . . . . . . .202

The * and # Modifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .202
scanf( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .203
Format Specifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .203

Inputting Numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .203

Inputting Unsigned Integers. . . . . . . . . . . . . . . . . . . . . . . . .205

Reading Individual Characters Using scanf( ). . . . . . . . . .205

Reading Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .205

Inputting an Address. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .206

The %n Specifier. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .206

Using a Scanset. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .206

Discarding Unwanted White Space. . . . . . . . . . . . . . . . . . .207

Non-White-Space Characters in the Control String. . . . . .208

You Must Pass scanf( ) Addresses. . . . . . . . . . . . . . . . . . . . .208

Format Modifiers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .208

Suppressing Input. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .209
9File I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .211
C Versus C++ File I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .212

Streams and Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .212

Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .212
Text Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .213

Binary Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .213
Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .213

File System Basics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .214
The File Pointer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215

Opening a File. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215

Closing a File. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .217

Writing a Character. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .217

Reading a Character. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .218
xivC++:TheCompleteReference
Using fopen( ), getc( ), putc( ), and fclose( ). . . . . . . . . . . . .218
Using feof( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .220

Working with Strings: fputs( ) and fgets( ). . . . . . . . . . . . . .222

rewind( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .223

ferror( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .224

Erasing Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .226

Flushing a Stream. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .226
fread( ) and fwrite( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .227
Using fread( ) and fwrite( ). . . . . . . . . . . . . . . . . . . . . . . . . . .227
fseek( ) and Random-Access I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . .229

fprintf( ) and fscanf( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .230

The Standard Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .232
The Console I/O Connection. . . . . . . . . . . . . . . . . . . . . . . . .233

Using freopen( ) to Redirect the Standard Streams. . . . . .234
10The Preprocessor and Comments. . . . . . . . . . . . . . . . . .237
The Preprocessor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .238

#define. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .238
Defining Function-like Macros. . . . . . . . . . . . . . . . . . . . . . .240
#error. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .241

#include. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .242

Conditional Compilation Directives. . . . . . . . . . . . . . . . . . . . . . . . . .242
#if, #else, #elif, and #endif. . . . . . . . . . . . . . . . . . . . . . . . . . .243

#ifdef and #ifndef. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .245
#undef. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .246

Using defined. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .247

#line. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .248

#pragma. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .248

The # and ## Preprocessor Operators. . . . . . . . . . . . . . . . . . . . . . . . .248

Predefined Macro Names. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .250

Comments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .250

Single-Line Comments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .252
Part II
C++11An Overview of C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . .255
The Origins of C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .256

What Is Object-Oriented Programming?. . . . . . . . . . . . . . . . . . . . . .257
Encapsulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .258

Polymorphism. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .258

Inheritance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .259
Some C++ Fundamentals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .259
ASample C++ Program. . . . . . . . . . . . . . . . . . . . . . . . . . . . .260
ContentsxvACloser Look at the I/O Operators. . . . . . . . . . . . . . . . . . .263
Declaring Local Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . .264

No Default to int. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .265

The bool Data Type. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .266
Old-Style vs. Modern C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .267
The New C++ Headers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .268

Namespaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .269

Working with an Old Compiler. . . . . . . . . . . . . . . . . . . . . . .270
Introducing C++ Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .270

Function Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .275

Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .278

Inheritance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .278

Constructors and Destructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .283

The C++ Keywords. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .287

The General Form of a C++ Program. . . . . . . . . . . . . . . . . . . . . . . . .288
12Classes and Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .289
Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .290

Structures and Classes Are Related. . . . . . . . . . . . . . . . . . . . . . . . . . .293

Unions and Classes Are Related. . . . . . . . . . . . . . . . . . . . . . . . . . . . .295
Anonymous Unions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .296
Friend Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .297

Friend Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .302

Inline Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .303
Defining Inline Functions Within a Class. . . . . . . . . . . . . .306
Parameterized Constructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .307
Constructors with One Parameter: ASpecial Case. . . . . . .309
Static Class Members. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .310
Static Data Members. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .310

Static Member Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . .315
When Constructors and Destructors Are Executed. . . . . . . . . . . . .317

The Scope Resolution Operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .319

Nested Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .319

Local Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .320

Passing Objects to Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .320

Returning Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .323

Object Assignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .324
13Arrays, Pointers, References, and the Dynamic
Allocation Operators. . . . . . . . . . . . . . . . . . . . . . . . . . .325
Arrays of Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .326
Creating Initialized vs. Uninitialized Arrays. . . . . . . . . . .328
Pointers to Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .329

Type Checking C++ Pointers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .332
xviC++:TheCompleteReference
The this Pointer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .332
Pointers to Derived Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .334

Pointers to Class Members. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .337

References. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .339
Reference Parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .339

Passing References to Objects. . . . . . . . . . . . . . . . . . . . . . . .343

Returning References. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .344

Independent References. . . . . . . . . . . . . . . . . . . . . . . . . . . . .345

References to Derived Types. . . . . . . . . . . . . . . . . . . . . . . . .346

Restrictions to References. . . . . . . . . . . . . . . . . . . . . . . . . . . .347
AMatter of Style. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .347

C++'s Dynamic Allocation Operators. . . . . . . . . . . . . . . . . . . . . . . . .347
Initializing Allocated Memory. . . . . . . . . . . . . . . . . . . . . . .349

Allocating Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .350

Allocating Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .351

The nothrow Alternative. . . . . . . . . . . . . . . . . . . . . . . . . . . .356

The Placement Form of new. . . . . . . . . . . . . . . . . . . . . . . . .357
14Function Overloading, Copy Constructors,
and Default Arguments. . . . . . . . . . . . . . . . . . . . . . . . .359
Function Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .360

Overloading Constructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .362
Overloading a Constructor to Gain Flexibility. . . . . . . . . .362

Allowing Both Initialized and Uninitialized Objects. . . . .364
Copy Constructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .366

Finding the Address of an Overloaded Function. . . . . . . . . . . . . . .370

The overload Anachronism. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .371

Default Function Arguments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .371
Default Arguments vs. Overloading. . . . . . . . . . . . . . . . . .376

Using Default Arguments Correctly. . . . . . . . . . . . . . . . . . .377
Function Overloading and Ambiguity. . . . . . . . . . . . . . . . . . . . . . . .378
15Operator Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . .383
Creating a Member Operator Function. . . . . . . . . . . . . . . . . . . . . . .384
Creating Prefix and Postfix Forms
of the Increment and Decrement Operators. . . . . . . . . .389
Overloading the Shorthand Operators. . . . . . . . . . . . . . . . .390

Operator Overloading Restrictions. . . . . . . . . . . . . . . . . . . .390
Operator Overloading Using a Friend Function. . . . . . . . . . . . . . . .391
Using a Friend to Overload ++ or ––. . . . . . . . . . . . . . . . . .393

Friend Operator Functions Add Flexibility. . . . . . . . . . . . .396
Overloading new and delete. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .398
Overloading new and delete for Arrays. . . . . . . . . . . . . . .403

Overloading the nothrow Version of new and delete. . . .406
Overloading Some Special Operators. . . . . . . . . . . . . . . . . . . . . . . . .407
Overloading [ ]. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .407
Overloading ( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .411

Overloading –>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .413
Overloading the Comma Operator. . . . . . . . . . . . . . . . . . . . . . . . . . .414
16Inheritance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .417
Base-Class Access Control. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .418

Inheritance and protected Members. . . . . . . . . . . . . . . . . . . . . . . . . .420
Protected Base-Class Inheritance. . . . . . . . . . . . . . . . . . . . . .424
Inheriting Multiple Base Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . .425

Constructors, Destructors, and Inheritance. . . . . . . . . . . . . . . . . . . .426
When Constructors and Destructors Are Executed. . . . . .426

Passing Parameters to Base-Class Constructors. . . . . . . . .430
Granting Access. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .434

Virtual Base Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .437
17Virtual Functions and Polymorphism. . . . . . . . . . . . . . .443
Virtual Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .444
Calling a Virtual Function Through a Base
Class Reference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .447
The Virtual Attribute Is Inherited. . . . . . . . . . . . . . . . . . . . . . . . . . . .448

Virtual Functions Are Hierarchical. . . . . . . . . . . . . . . . . . . . . . . . . . .450

Pure Virtual Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .453
Abstract Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .455
Using Virtual Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .455

Early vs. Late Binding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .458
18Templates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .459
Generic Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .460
AFunction with Two Generic Types. . . . . . . . . . . . . . . . . . .463

Explicitly Overloading a Generic Function. . . . . . . . . . . . .463

Overloading a Function Template. . . . . . . . . . . . . . . . . . . . .466

Using Standard Parameters with Template Functions. . . .466

Generic Function Restrictions. . . . . . . . . . . . . . . . . . . . . . . .467
Applying Generic Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .468
AGeneric Sort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .469

Compacting an Array. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .470
Generic Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .472
An Example with Two Generic Data Types. . . . . . . . . . . . .476

Applying Template Classes: AGeneric Array Class. . . . .477

Using Non-Type Arguments with Generic Classes. . . . . .479

Using Default Arguments with Template Classes. . . . . . .481

Explicit Class Specializations. . . . . . . . . . . . . . . . . . . . . . . . .483
ContentsxviiThe typename and export Keywords. . . . . . . . . . . . . . . . . . . . . . . . .484
The Power of Templates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .485
19Exception Handling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .487
Exception Handling Fundamentals. . . . . . . . . . . . . . . . . . . . . . . . . .488
Catching Class Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .494

Using Multiple catch Statements. . . . . . . . . . . . . . . . . . . . . .495
Handling Derived-Class Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . .497

Exception Handling Options. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .498
Catching All Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . .498

Restricting Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .500

Rethrowing an Exception. . . . . . . . . . . . . . . . . . . . . . . . . . . .502
Understanding terminate( ) and unexpected( ). . . . . . . . . . . . . . . . .503
Setting the Terminate and Unexpected Handlers. . . . . . . .504
The uncaught_exception( ) Function. . . . . . . . . . . . . . . . . . . . . . . . .505

The exception and bad_exception Classes. . . . . . . . . . . . . . . . . . . . .506

Applying Exception Handling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .506
20The C++ I/O System Basics. . . . . . . . . . . . . . . . . . . . . . .509
Old vs. Modern C++ I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .510

C++ Streams. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .511

The C++ Stream Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .511
C++'s Predefined Streams. . . . . . . . . . . . . . . . . . . . . . . . . . .512
Formatted I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .513
Formatting Using the ios Members. . . . . . . . . . . . . . . . . . . .513

Setting the Format Flags. . . . . . . . . . . . . . . . . . . . . . . . . . . . .514

Clearing Format Flags. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .515

An Overloaded Form of setf( ). . . . . . . . . . . . . . . . . . . . . . . .516

Examining the Formatting Flags. . . . . . . . . . . . . . . . . . . . . .518

Setting All Flags. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .519

Using width( ), precision( ), and fill( ). . . . . . . . . . . . . . . . .520

Using Manipulators to Format I/O. . . . . . . . . . . . . . . . . . .522
Overloading << and >>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .526
Creating Your Own Inserters. . . . . . . . . . . . . . . . . . . . . . . . .526

Creating Your Own Extractors. . . . . . . . . . . . . . . . . . . . . . . .532

Creating Your Own Manipulator Functions. . . . . . . . . . . .535
21C++ File I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .539
<fstream> and the File Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .540

Opening and Closing a File. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .540

Reading and Writing Text Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .543

Unformatted and Binary I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .545
Characters vs. Bytes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .545

put( ) and get( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .546

read( ) and write( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .548
xviiiC++:TheCompleteReference
ContentsxixMore get( ) Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .551
getline( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .551

Detecting EOF. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .553

The ignore( ) Function. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .555

peek( ) and putback( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .556

flush( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .556

Random Access. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .557
Obtaining the Current File Position. . . . . . . . . . . . . . . . . . .561
I/O Status. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .561

Customized I/O and Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .563
22Run-Time Type ID and the Casting Operators. . . . . . .567
Run-Time Type Identification (RTTI). . . . . . . . . . . . . . . . . . . . . . . . .568

The Casting Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .578

dynamic_cast. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .578
23Namespaces, Conversion Functions,and Other Advanced Topics. . . . . . . . . . . . . . . . . . . . .591
Namespaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .592
Namespace Fundamentals. . . . . . . . . . . . . . . . . . . . . . . . . . .592

using. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .596

Unnamed Namespaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .598

Some Namespace Options. . . . . . . . . . . . . . . . . . . . . . . . . . .599
The std Namespace. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601

Creating Conversion Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .603

const Member Functions and mutable. . . . . . . . . . . . . . . . . . . . . . . .607

Volatile Member Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .609

Explicit Constructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .610

The Member Initialization Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . .611

Using the asm Keyword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .616

Linkage Specification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .617

Array-Based I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .618
The Array-Based Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . .619

Creating an Array-Based Output Stream. . . . . . . . . . . . . . .619

Using an Array as Input. . . . . . . . . . . . . . . . . . . . . . . . . . . . .621

Input/Output Array-Based Streams. . . . . . . . . . . . . . . . . . .623

Using Dynamic Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .624

Using Binary I/O with Array-Based Streams. . . . . . . . . . .625
Summarizing the Differences Between C and C++. . . . . . . . . . . . .626
24Introducing the Standard Template Library. . . . . . . . . .629
An Overview of the STL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .630
Containers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .630
xxC++:TheCompleteReference
Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .631
Iterators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .631

Other STLElements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .632
The Container Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .633

General Theory of Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .634

Vectors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .635
Accessing a Vector Through an Iterator. . . . . . . . . . . . . . . .639

Inserting and Deleting Elements in a Vector. . . . . . . . . . . .641

Storing Class Objects in a Vector. . . . . . . . . . . . . . . . . . . . . .643
Lists. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .645
Understanding end( ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .649

push_front( ) vs. push_back( ). . . . . . . . . . . . . . . . . . . . . . . .651

Sort a List. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .652

Merging One List with Another. . . . . . . . . . . . . . . . . . . . . .653

Storing Class Objects in a List. . . . . . . . . . . . . . . . . . . . . . . .655
Maps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .658
Storing Class Objects in a Map. . . . . . . . . . . . . . . . . . . . . . .662
Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .664
Counting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .664

Removing and Replacing Elements. . . . . . . . . . . . . . . . . . .670

Reversing a Sequence. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .672

Transforming a Sequence. . . . . . . . . . . . . . . . . . . . . . . . . . . .673
Using Function Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .675
Unary and Binary Function Objects. . . . . . . . . . . . . . . . . . .675

Using the Built-in Function Objects. . . . . . . . . . . . . . . . . . .675

Creating a Function Object. . . . . . . . . . . . . . . . . . . . . . . . . . .678

Using Binders. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .680
The string Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .683
Some string Member Functions. . . . . . . . . . . . . . . . . . . . . . .687

Strings Are Containers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .693

Putting Strings into Other Containers. . . . . . . . . . . . . . . . .694
Final Thoughts on the STL. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .695
Part III
The Standard Function Library
25The C-Based I/O Functions. . . . . . . . . . . . . . . . . . . . . . .699
clearerr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .700

fclose. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .701

feof. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .701

ferror. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .701

fflush. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .702

fgetc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .702

fgetpos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .702
Contentsxxifgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .703
fopen. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .703

fprintf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .705

fputc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .705

fputs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .706

fread. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .706

freopen. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .706

fscanf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .707

fseek. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .707

fsetpos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .708

ftell. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .708

fwrite. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .709

getc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .709

getchar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .710

gets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .710

perror. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .710

printf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .711

putc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .714

putchar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .714

puts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .714

remove. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .715

rename. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .715

rewind. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .715

scanf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .715

setbuf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .719

setvbuf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .719

sprintf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .720

sscanf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .720

tmpfile. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .720

tmpnam. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .721

ungetc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .721

vprintf, vfprintf, and vsprintf. . . . . . . . . . . . . . . . . . . . . . . .722
26The String and Character Functions. . . . . . . . . . . . . . . .723
isalnum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .724

isalpha. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .724

iscntrl. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .725

isdigit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .725

isgraph. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .725

islower. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .725

isprint. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .726

ispunct. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .726

isspace. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .726

isupper. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .727
xxiiC++:TheCompleteReference
isxdigit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .727
memchr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .727

memcmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .727

memcpy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .728

memmove. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .728

memset. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .729

strcat. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .729

strchr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .729

strcmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .730

strcoll. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .730

strcpy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .731

strcspn. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .731

strerror. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .731

strlen. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .731

strncat. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .732

strncmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .732

strncpy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .733

strpbrk. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .733

strrchr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .733

strspn. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .734

strstr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .734

strtok. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .734

strxfrm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .735

tolower. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .735

toupper. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .735
27The Mathematical Functions. . . . . . . . . . . . . . . . . . . . . .737
acos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .738

asin. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .738

atan. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .739

atan2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .739

ceil. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .739

cos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .740

cosh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .740

exp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .740

fabs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .741

floor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .741

fmod. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .741

frexp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .741

ldexp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .742

log. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .742

log10. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .742

modf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .743

pow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .743

sin. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .743
Contentsxxiiisinh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .744
sqrt. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .744

tan. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .744

tanh. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .745
28Time, Date, and Localization Functions. . . . . . . . . . . . .747
asctime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .748

clock. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .749

ctime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .749

difftime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .750

gmtime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .750

localeconv. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .750

localtime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .752

mktime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .752

setlocale. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .752

strftime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .753

time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .754
29The Dynamic Allocation Functions. . . . . . . . . . . . . . . . .757
calloc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .758

free. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .758

malloc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .759

realloc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .759
30Utility Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .761
abort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .762

abs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .762

assert. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .763

atexit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .763

atof. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .763

atoi. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .764

atol. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .764

bsearch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .764

div. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .765

exit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .766

getenv. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .766

labs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .766

ldiv. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .767

longjmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .767

mblen. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .767

mbstowcs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .768

mbtowc. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .768

qsort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .768

raise. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .769
xxivC++:TheCompleteReference
rand. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .770
setjmp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .770

signal. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .770

srand. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .771

strtod. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .771

strtol. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .772

strtoul. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .772

system. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .773

va_arg, va_start, and va_end. . . . . . . . . . . . . . . . . . . . . . . . .773

wcstombs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .774

wctomb. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .774
31The Wide-Character Functions. . . . . . . . . . . . . . . . . . . . .775
The Wide-Character Classification Functions. . . . . . . . . . . . . . . . . .776

The Wide-Character I/O Functions. . . . . . . . . . . . . . . . . . . . . . . . . .779

The Wide-Character String Functions. . . . . . . . . . . . . . . . . . . . . . . . .779

Wide-Character String Conversion Functions. . . . . . . . . . . . . . . . . .779

Wide-Character Array Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . .782

Multibyte/Wide-Character Conversion Functions. . . . . . . . . . . . . .783
Part IV
The Standard C++ Class Library
32The Standard C++ I/O Classes. . . . . . . . . . . . . . . . . . . .787
The I/O Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .788

The I/O Headers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .790

The Format Flags and I/O Manipulators. . . . . . . . . . . . . . . . . . . . . .791

Several Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .793
The streamsize and streamoff Types. . . . . . . . . . . . . . . . . . .793

The streampos and wstreampos Types. . . . . . . . . . . . . . . .793

The pos_type and off_type Types. . . . . . . . . . . . . . . . . . . . .793

The openmode Type. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .793

The iostate Type. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .794

The seekdir Type. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .794

The failure Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .794
Overload << and >> Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .794

The General-Purpose I/O Functions. . . . . . . . . . . . . . . . . . . . . . . . .795
bad. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .795

clear. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .795

eof. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .795

exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .796

fail. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .796

fill. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .796

flags. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .797
Contentsxxvflush. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .797
fstream, ifstream, and ofstream. . . . . . . . . . . . . . . . . . . . . . .797

gcount. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .798

get. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .798

getline. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .799

good. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .800

ignore. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .800

open. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .800

peek. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .801

precision. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .802

put. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .802

putback. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .802

rdstate. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .802

read. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .803

readsome. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .803

seekg and seekp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .804

setf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .805

setstate. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .805

str. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .806

stringstream, istringstream, ostringstream. . . . . . . . . . . . .806

sync_with_stdio. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .807

tellg and tellp. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .808

unsetf. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .808

width. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .808

write. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .809
33The STLContainer Classes. . . . . . . . . . . . . . . . . . . . . . . .811
The Container Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .812
bitset. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .814

deque. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .816

list. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .819

map. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .822

multimap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .824

multiset. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .827

queue. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .829

priority_queue. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .830

set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .831

stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .833

vector. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .834
34The STLAlgorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .839
adjacent_find. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .840

binary_search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .840

copy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .841
xxviC++:TheCompleteReference
copy_backward. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .841
count. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .841

count_if. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .842

equal. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .842

equal_range. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .842

fill and fill_n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .843

find. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .843

find_end. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .843

find_first_of. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .843

find_if. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .844

for_each. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .844

generate and generate_n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .844

includes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .845

inplace_merge. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .845

iter_swap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .845

lexicographical_compare. . . . . . . . . . . . . . . . . . . . . . . . . . . .846

lower_bound. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .846

make_heap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .846

max. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .847

max_element. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .847

merge. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .847

min. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .848

min_element. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .848

mismatch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .848

next_permutation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .849

nth_element. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .849

partial_sort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .849

partial_sort_copy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .850

partition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .850

pop_heap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .850

prev_permutation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .851

push_heap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .851
random_shuffle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .851

remove, remove_if, remove_copy, and remove_copy_if .        852
replace, replace_copy, replace_if, and replace_copy_if. . .852

reverse and reverse_copy. . . . . . . . . . . . . . . . . . . . . . . . . . . .853

rotate and rotate_copy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .853

search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .854

search_n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .854

set_difference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .854

set_intersection. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .855

set_symmetric_difference. . . . . . . . . . . . . . . . . . . . . . . . . . . .855

set_union. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .856

sort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .856

sort_heap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .856
Contentsxxviistable_partition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .857
stable_sort. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .857

swap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .857

swap_ranges. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .858

transform. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .858

unique and unique_copy. . . . . . . . . . . . . . . . . . . . . . . . . . . .858

upper_bound. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .859
35STLIterators, Allocators, and Function Objects. . . . . .861
Iterators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .862
The Basic Iterator Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . .862

The Low-Level Iterator Classes. . . . . . . . . . . . . . . . . . . . . . .863

The Predefined Iterators. . . . . . . . . . . . . . . . . . . . . . . . . . . . .864

Two Iterator Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .872
Function Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .872
Function Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .873

Binders. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .874

Negators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .875

Adaptors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .876
Allocators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .879
36The String Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .881
The basic_string Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .882

The char_traits Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .894
37The Numeric Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . .897
The complex Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .898

The valarray Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .902
The slice and gslice Classes. . . . . . . . . . . . . . . . . . . . . . . . . .917

The Helper Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .920
The Numeric Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .920
accumulate. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .920

adjacent_difference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .921

inner_product. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .922

partial_sum. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .923
38Exception Handling and Miscellaneous Classes. . . . . .925
Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .926
<exception>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .926

<stdexcept>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .927
auto_ptr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .928

The pair Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .930

Localization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .931

Other Classes of Interest. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .931
Part V
Applying C++39Integrating New Classes: A Custom String Class. . . . .935
The StrType Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .936
The Constructors and Destructors. . . . . . . . . . . . . . . . . . . . . . . . . . .938

I/O on Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .939

The Assignment Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .941

Concatenation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .942

Substring Subtraction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .945

The Relational Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .947

Miscellaneous String Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .948

The Entire StrType Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .949

Using the StrType Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .958

Creating and Integrating New Types in General. . . . . . . . . . . . . . .961

AChallenge. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .961
40Parsing Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .963
Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .964

Parsing Expressions: The Problem. . . . . . . . . . . . . . . . . . . . . . . . . . .965

Parsing an Expression. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .966

The Parser Class. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .968

Dissecting an Expression. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .969

ASimple Expression Parser. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .971
Understanding the Parser. . . . . . . . . . . . . . . . . . . . . . . . . . .977
Adding Variables to the Parser. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .978

Syntax Checking in a Recursive-Descent Parser. . . . . . . . . . . . . . . .988

Building a Generic Parser. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .989

Some Things to Try. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .997
AThe .NET Managed Extensions to C++. . . . . . . . . . . . . .999
The .NET Keyword Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1000

Preprocessor Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1002

The attribute Attribute. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1003

Compiling Managed C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1003
BC++ and the Robotics Age. . . . . . . . . . . . . . . . . . . . . . . .1005
Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1009
xxviiiC++:TheCompleteReference
Ifthereisonelanguagethatdefinesmodernprogramming,itisC++.Itssyntax,
style,andphilosophyhavesetthestandardbywhichallotherlanguagesare

judged.Furthermore,C++istheuniversallanguageofprogramming.Whenan
algorithmortechniqueisdescribed,itisusuallydonesousingtheC++syntax.The

long-termsuccessofC++hasalsoleftalastingimpressiononcomputerlanguage

development. For example, both Java and C# are descended from C++. Frankly, to be
a professional programmer implies proficiency in C++. It is the one language that no
programmer can afford to ignore.Thisisthefourtheditionof
C++:TheCompleteReference
.Itfullydescribesand
demonstrates the keywords, syntax, functions, classes, and features that define the C++

language. More specifically, this book fully describes Standard C++. This is the version

of C++ defined by the ANSI/ISO Standard for C++ and it is the version of C++ that is

supported by all major compilers, including Microsoft’s Visual C++ and Borland’s C++

Builder.Thus,theinformationinthisbookisapplicabletoallmodernprogramming

environments.
In the time that has passed since the previous edition of this book, there have
been no changes to the C++ language. There have, however, been big changes to the

computing environment. For example, a new standard for C, called C99, was created,

Java became the dominant language for Web programming, the .NET Framework was
xxixCopyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
released, and C# was invented. Through all the changes of the past few years, one thing
has remained constant: the staying power of C++. C++ has been, is, and will remain the

preeminent language for the development of high-performance software well into the

foreseeable future.
What’s New in the Fourth Edition
Theoverallstructureandorganizationofthefourtheditionissimilartothethirdedition.

Thus,ifyouhavebeenusingthethirdedition,youwillfeelrightathomewiththefourth

edition. Most of the changes to the fourth edition involve updating and expanding the
coverage throughout. In some cases, additional details were added. In other cases, the

presentationofatopicwasimproved.Instillothersituations,descriptionswere

modernizedtoreflectthecurrentprogrammingenvironment.Severalnewsectionswere
alsoadded. In Part One, the relationship of C++ to the new C standard, called C99, is noted

where appropriate.
Twoappendiceswerealsoadded.Thefirstdescribedtheextendedkeywords
defined by Microsoft that are used for creating managed code for the .NET Framework.

The second shows off an area of personal interest: robotics. Robotics has long been a

hobby of mine and I thought that many readers would find my experimental robot to

be of interest. Most of the software that drives it is, of course, written in C++!
Finally, all code examples were retested against the current crop of compilers,
including Microsoft’s Visual Studio .NET and Borland’s C++ Builder.
What’s InsideThis books covers in detail all aspects of the C++ language, including its foundation, C.
The book is divided into these five parts:The C Subset—The foundation of C++The C++ languageThe Standard Function Library
The Standard Class Library
Sample C++ applicationsPartOneprovidesacomprehensivediscussionoftheCsubsetofC++.Asmost
readerswillknow,CisthefoundationuponwhichC++wasbuilt.ItistheCsubset

thatdefinesthebedrockfeaturesofC++,includingsuchthingsas
forloopsand
ifstatements. It also defines the essential nature of C++’s block structure, pointers, and

functions. Since many readers are already familiar with and proficient in C, discussing

the C subset separately in Part One prevents the knowledgeable C programmer from

having to “wade through” reams of information he or she already knows. Instead, the
xxxC++:TheCompleteReference
experienced C programmer can simply turn to the sections of this book that cover the
C++-specific features.
Part Two discusses in detail the features that move beyond the C foundation and
define the C++ language These include its object-oriented features such as classes,

constructors, destructors, RTTI, and templates. Thus, Part Two covers those constructs

that “make C++, C++.”Part Three describes the standard function library and Part Four examines the
standard class library, including the STL(Standard Template Library). Part Five

shows two practical examples of applying C++ and object-oriented programming.
A Book for All Programmers
This C++ reference is designed for all C++ programmers, regardless of their experience

level. It does assume, however, a reader able to create at least a simple program. If you

are just learning C++, this book will make an excellent companion to any C++ tutorial

and serve as a source of answers to your specific questions. Experienced C++ pros will

find the in-depth coverage of C++’s more advanced features especially useful.
If You’re Using Windows
If your computer uses Windows, then you have chosen the right language. C++ is

completely at home with Windows programming. However, none of the programs in

thisbookareWindowsprograms.Instead,theyareconsole-basedprograms.Thereasonfor

thisiseasytounderstand:Windowsprogramsare,bytheirnature,largeandcomplex.The

overhead required to create even a minimal Windows skeletal program is 50 to 70 lines

of code. To write Windows programs that demonstrate the features of C++ would

requirehundredsoflinesofcodeeach.Putsimply,Windowsisnotanappropriate

environmentinwhichtodiscussthefeaturesofaprogramminglanguage.However,

youcanstilluseaWindows-basedcompilertocompiletheprogramsinthisbook

becausethecompilerwillautomaticallycreateaconsolesessioninwhichtoexecute

your program.
Don’t Forget: Code on the Web
Remember, the source code for all of the programs in this book is available free-of-

charge on the Web at
www.osborne.com
. Downloading this code prevents you from
having to type in the examples.xxxiFor Further Study
C++: The Complete Referenceis your gateway to the Herb Schildt series ofprogramming books. Here are some others that you will find of interest.To learn more about C++, tryC++: ABeginner’s Guide
C++ from the Ground Up

Teach Yourself C++

STLProgramming from the Ground Up

C++ Programmer’s Reference
To learn about Java programming, we recommend the following:Java 2: ABeginner’s Guide

Java 2: The Complete Reference

Java 2 Programmer’s Reference
To learn about C#, Herb offers these books:C#: ABeginner’s Guide

C#: The Complete Reference
To learn about Windows programming we suggest the following Schildt books:Windows 98 Programming from the Ground Up

Windows 2000 Programming from the Ground Up

MFC Programming from the Ground Up

The Windows Programming Annotated Archives
If you want to learn about the C language, which is the foundation of all modernprogramming, then the following titles will be of interest.C: The Complete Reference

Teach Yourself C
When you need solid answers, fast, turn to Herbert Schildt,
the recognized authority on programming.
xxxiiC++:TheCompleteReference
Part I
The Foundation of C++:The C SubsetThisbookdividesitsdescriptionoftheC++languageintotwoparts.
PartOnediscussestheC-likefeaturesofC++.Thisiscommonly

referredtoasthe
Csubset
ofC++.PartTwodescribesthosefeatures
specifictoC++.Together,thesepartsdescribetheentireC++language.
Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
As you may know, C++ was built upon the foundation of C. In fact, C++ includes
theentireClanguage,and(withminorexceptions)allCprogramsarealsoC++programs.
WhenC++wasinvented,theClanguagewasusedasthestartingpoint.ToCwereadded

several new features and extensions designed to support object oriented programming

(OOP).However,theC-likeaspectsofC++wereneverabandoned,andthe1989ANSI/

ISO C Standard is a
base documentfor the International Standard for C++. Thus, an
understanding of C++ implies an understanding of C.Inabooksuchasthis
CompleteReference
,dividingtheC++languageintotwopieces—the
C foundation and the C++-specific features—achieves three major benefits:
The dividing line between C and C++ is clearly delineated.Readers already familiar with C can easily find the C++-specific information.
It provides a convenient place in which to discuss those features of C++ that
relate mostly to the C subset.
Understanding the dividing line between C and C++ is important because both are
widelyusedlanguages,anditisverylikelythatyouwillbecalledupontowriteor
maintain both C and C++ code. When working on C code, you need to know where C

ends and C++ begins. Many C++ programmers will, from time to time, be required to

write code that is limited to the “C subset.” This will be especially true for embedded

systems programming and the maintenance of existing applications. Knowing the

difference between C and C++ is simply part of being a top-notch professional C++

programmer.
Aclear understanding of C is also valuable when converting C code into C++.
To do this in a professional manner, a solid knowledge of C is required. For example,

without a thorough understanding of the C I/O system, it is not possible to convert

an I/O-intensive C program into C++ in an efficient manner.
Many readers already know C. Covering the C-like features of C++ in their own
section makes it easier for the experienced C programmer to find information about

C++ quickly and easily, without having to “wade through” reams of information that

heorshealreadyknows.Ofcourse,throughoutPartOne,anyminordifferencesbetweenC

andC++arenoted.Also,separatingtheCfoundationfromthemoreadvanced,object-

oriented features of C++ makes it possible to tightly focus on those advanced features

because all of the basics have already been discussed.
AlthoughC++containstheentireClanguage,notallofthefeaturesprovidedbytheC
languagearecommonlyusedwhenwriting“C++-style”programs.Forexample,the

CI/OsystemisstillavailabletotheC++programmereventhoughC++definesits

own,object-orientedversion.Thepreprocessorisanotherexample.Thepreprocessor

isveryimportanttoC,butlesssotoC++.Discussingseveralofthe“C-only”features

inPartIpreventsthemfromclutteringuptheremainderofthebook.
Remember: The C subset described in Part One constitutes the core of C++ and the
foundation upon which C++’s object-oriented features are built. All the features

described here are part of C++ and available for your use.
Part I of this book is excerpted from my book C: The Complete Reference (McGraw-Hill/

Osborne). If you are particularly interested in C, you will find this book helpful.
Chapter1
An Overview of C3Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
4C++:TheCompleteReference
To understand C++ is to understand the forces that drove its creation, the ideasthat shaped it, and the legacy it inherits. Thus, the story of C++ begins with C.This chapter presents an overview of the C programming language, its origins, its
uses, and its underlying philosophy. Because C++ is built upon C, this chapter provides

an important historical perspective on the roots of C++. Much of what “makes C++,

C++” had its genesis in the C language.The Origins and History of C
C was invented and first implemented by Dennis Ritchie on a DEC PDP-11 that used

the UNIX operating system. C is the result of a development process that started with

anolderlanguagecalledBCPL.BCPLwasdevelopedbyMartinRichards,andit

influenced a language called B, which was invented by Ken Thompson. B led to the
development of C in the 1970s.Formanyyears,thedefactostandardforCwastheversionsuppliedwiththeUNIX
operatingsystem.Itwasfirstdescribedin
TheCProgrammingLanguage
byBrianKernighan
and Dennis Ritchie (Englewood Cliffs, N.J.: Prentice-Hall, 1978). In the summer of 1983

a committee was established to create an ANSI (American National Standards Institute)

standard that would define the C language. The standardization process took six years

(much longer than anyone reasonably expected at the time).
The ANSI C standard was finally adopted in December of 1989, with the first copies
becoming available in early 1990. The standard was also adopted by ISO (International

Standards Organization) and the resulting standard was typically referred to as ANSI/

ISO Standard C. In 1995, Amendment 1 to the C standard was adopted, which, among

other things, added several new library functions. The 1989 standard for C, along with

Amendment 1, became thebasedocument
for Standard C++, defining the
C subsetofC++. The version of C defined by the 1989 standard is commonly referred to as C89.
After 1989, C++ took center stage, and during the 1990s the development of astandard for C++ consumed most programmers’ attention, with a standard for C++

being adopted by the end of 1998. However, work on C continued along quietly. The

endresultwasthe1999standardforC,usuallyreferredtoasC99.Ingeneral,C99retained

nearlyallofthefeaturesofC89anddidnotalterthemainaspectsofthelanguage.Thus,

the C language described by C99 is essentially the same as the one described by C89.
The C99 standardization committee focused on two main areas: the addition of several

numeric libraries and the development of some special-use, but highly innovative, new
features,suchasvariable-lengtharraysandthe
restrictpointerqualifier.Inafewcases,
features originally from C++, such as single-line comments, were also incorporated into

C99. Because the standard for C++ was finalized before C99 was created, none of the

C99 innovations are found in Standard C++.
C89 vs. C99Although the innovations in C99 are important from a computer science point of view,

they are currently of little practical consequence because, at the time of this writing, no

widely-used compiler implements C99. Rather, it is C89 that defines the version of C
THEFOUNDATIONOFC++:
THECSUBSET
Chapter1:AnOverviewofC
5that most programmers think of as “C” and that all mainstream compilers recognize.
Furthermore,itisC89thatformstheCsubsetofC++.Althoughseveralofthenew

features added by C99 will eventually find their way into the next standard for C++,

currently these new features are incompatible with C++.
Because C89 is the standard that forms the C subset of C++, and because it is the
version of C that the vast majority of C programmers currently know, it is the version

ofCdiscussedinPartI.Thus,whentheterm
Cisused,takeittomeantheCdefined
by C89. However, important differences between C89 and C99 that relate specifically to

C++ are noted, such as when C99 adds a feature that improves compatibility with C++.
C Is a Middle-Level LanguageC is often called amiddle-levelcomputer language. This does not mean that C is lesspowerful, harder to use, or less developed than a high-level language such as BASIC or

Pascal; nor does it imply that C has the cumbersome nature of assembly language (and

its associated troubles). Rather, C is thought of as a middle-level language because it

combines the best elements of high-level languages with the control and flexibility of

assemblylanguage.Table1-1showshowCfitsintothespectrumofcomputerlanguages.
Asamiddle-levellanguage,Callowsthemanipulationofbits,bytes,andaddresses—
the basic elements with which the computer functions. Despite this fact, C code is alsoHighest levelAdaModula-2
Pascal
COBOL
FORTRAN

BASICMiddle levelJava
C#
C++
C
ForthMacro-assembler
Lowest levelAssemblerTable1-1.
C’s Place in the World of Languages
6C++:TheCompleteReference
portable.Portabilitymeans that it is easy to adapt software written for one type of
computer or operating system to another. For example, if you can easily convert a
program written for UNIX so that it runs under Windows, that program is portable.
All high-level programming languages support the concept of data types. A
datatypedefines a set of values that a variable can store along with a set of operations that
can be performed on that variable. Common data types are integer, character, and real.

Although C has five basic built-in data types, it is not a strongly typed language, as are

Pascal and Ada. C permits almost all type conversions. For example, you may freely

intermix character and integer types in an expression.
Unlike a high-level language, C performs almost no run-time error checking. For
example, no check is performed to ensure that array boundaries are not overrun. These

types of checks are the responsibility of the programmer.
In the same vein, C does not demand strict type compatibility between a parameterand an argument. As you may know from your other programming experience, a high-

level computer language will typically require that the type of an argument be (more or

less)exactlythesametypeastheparameterthatwillreceivetheargument.However,

such is not the case for C. Instead, C allows an argument to be of any type so long as it

can be reasonably converted into the type of the parameter. Further, C provides all of

the automatic conversions to accomplish this.Cisspecialinthatitallowsthedirectmanipulationofbits,bytes,words,andpointers.
This makes it well suited for system-level programming, where these operations are

common.Another important aspect of C is that it has only a few keywords, which are the
commands that make up the C language. For example, C89 defines only 32 keywords,

with C99 adding just another 5. Some computer languages have several times more.

For comparison, most versions of BASIC have well over 100 keywords!
C Is a Structured Language
Inyourpreviousprogrammingexperience,youmayhaveheardtheterm
block-structured
appliedtoacomputerlanguage
.Althoughthetermblock-structuredlanguagedoes
not strictly apply to C, C is commonly referred to simply as a
structured
language. It hasmanysimilaritiestootherstructuredlanguages,suchasALGOL,Pascal,andModula-2.
The reason that C (and C++) is not, technically, a block-structured language is that

block-structured languages permit procedures or functions to be declared inside other

procedures or functions. However, since C does not allow the creation of functions

within functions, it cannot formally be called block-structured.
The distinguishing feature of a structured language is
compartmentalizationof codeand data. This is the ability of a language to section off and hide from the rest of the

program all information and instructions necessary to perform a specific task. One

way that you achieve compartmentalization is by using subroutines that employ local

(temporary)variables.Byusinglocalvariables,youcanwritesubroutinessothat

the events that occur within them cause no side effects in other parts of the program.
Chapter1:AnOverviewofC
7THEFOUNDATIONOFC++:
THECSUBSET
This capability makes it easier for programs to share sections of code. If you develop
compartmentalized functions, you only need to know what a function does, not how
it does it. Remember, excessive use of global variables (variables known throughout

the entire program) may allow bugs to creep into a program by allowing unwanted

side effects. (Anyone who has programmed in standard BASIC is well aware of this

problem.)
The concept of compartmentalization is greatly expanded by C++. Specifically, in C++,

one part of your program may tightly control which other parts of your program are

allowed access.Astructured language allows you a variety of programming possibilities. It directly
supportsseveralloopconstructs,suchas
while,do-while,and
for.Inastructured
language,theuseof
gotoiseitherprohibitedordiscouragedandisnotthecommon
form of program control (as is the case in standard BASIC and traditional FORTRAN,

for example). Astructured language allows you to place statements anywhere on a line

and does not require a strict field concept (as some older FORTRANs do).
Here are some examples of structured and nonstructured languages:
Nonstructured
Structured
FORTRAN
PascalBASICAdaCOBOLJavaC#
C++
C
Modula-2Structuredlanguagestendtobemodern.Infact,amarkofanoldcomputer
language is that it is nonstructured. Today, few programmers would consider using
a nonstructured language for serious, new programs.
New versions of many older languages have attempted to add structured elements.

BASIC is an example—in particular Visual Basic by Microsoft. However, the

shortcomings of these languages can never be fully mitigated because they were

not designed with structured features from the beginning.
C’s main structural component is the function—C’s stand-alone subroutine. In C,
functionsarethebuildingblocksinwhichallprogramactivityoccurs.Theyallowyouto

defineandcodeseparatelytheseparatetasksinaprogram,thusallowingyourprograms

to be modular. After you have created a function, you can rely on it to work properly

in various situations without creating side effects in other parts of the program. Being
8C++:TheCompleteReference
able to create stand-alone functions is extremely critical in larger projects where one
programmer’s code must not accidentally affect another’s code.
Another way to structure and compartmentalize code in C is through the use of
code blocks. Acode blockis a logically connected group of program statements that is
treated as a unit. In C, you create a code block by placing a sequence of statements

between opening and closing curly braces. In this example,if (x < 10)  {printf("Too low, try again.\n");scanf("%d", &x);}the two statements after theifand between the curly braces are both executed if
xis less than 10. These two statements together with the braces represent a code block.
Theyarealogicalunit:oneofthestatementscannotexecutewithouttheotherexecuting

also. Code blocks allow many algorithms to be implemented with clarity, elegance, and

efficiency. Moreover, they help the programmer better conceptualize the true nature of

the algorithm being implemented.C Is a Programmer’s Language
Surprisingly, not all computer programming languages are for programmers. Consider

the classic examples of nonprogrammer languages, COBOLand BASIC. COBOLwas

designed not to better the programmer’s lot, not to improve the reliability of the code

produced, and not even to improve the speed with which code can be written. Rather,

COBOLwasdesigned,inpart,toenablenonprogrammerstoreadandpresumably

(however unlikely) to understand the program. BASIC was created essentially to allow

nonprogrammers to program a computer to solve relatively simple problems.
In contrast, C was created, influenced, and field-tested by working programmers.
TheendresultisthatCgivestheprogrammerwhattheprogrammerwants:few

restrictions, few complaints, block structures, stand-alone functions, and a compact set

ofkeywords.ByusingC,youcannearlyachievetheefficiencyofassemblycodecombined
withthe structure of ALGOLor Modula-2. It is no wonder that C and C++ are easily two of

the most popular languages among topflight professional programmers.
The fact that you can often use C in place of assembly language is a major factor inits popularity among programmers. Assembly language uses a symbolic representation

of the actual binary code that the computer executes directly. Each assembly-language

operationmapsintoasingletaskforthecomputertoperform.Althoughassembly

languagegivesprogrammersthepotentialtoaccomplishtaskswithmaximumflexibility

and efficiency, it is notoriously difficult to work with when developing and debugging

a program. Furthermore, since assembly language is unstructured, the final program

tends to be spaghetti code—a tangled mess of jumps, calls, and indexes. This lack of
structure makes assembly-language programs difficult to read, enhance, and maintain.
Chapter1:AnOverviewofC
9THEFOUNDATIONOFC++:
THECSUBSET
Perhaps more important, assembly-language routines are not portable between
machines with different central processing units (CPUs).
Initially, C was used for systems programming. A
systems program
forms a portionoftheoperatingsystemofthecomputeroritssupportutilities.Forexample,thefollowingare

usually called systems programs:
Operating systemsInterpreters
EditorsCompilersFile utilitiesPerformance enhancersReal-time executivesDevice driversAs C grew in popularity, many programmers began to use it to program all tasks
because of its portability and efficiency—and because they liked it! At the time of its

creation, C was a much longed-for, dramatic improvement in programming languages.

Of course, C++ has carried on this tradition.With the advent of C++, some thought that C as a distinct language would die out.
Such has not been the case. First, not all programs require the application of the object-

oriented programming features provided by C++. For example, applications such as

embedded systems are still typically programmed in C. Second, much of the world

still runs on C code, and those programs will continue to be enhanced and maintained.

While C’s greatest legacy is as the foundation for C++, C will continue to be a vibrant,

widely used language for many years to come.The Form of a C Program
Table 1-2 lists the 32 keywords that, combined with the formal C syntax, form C89, the

C subset of C++. All are, of course, also keywords in C++.
In addition, many compilers have added several keywords that better exploit their
operating environment. For example, several compilers include keywords to manage

the memory organization of the 8086 family of processors, to support inter-language

programming, and to access interrupts. Here is a list of some commonly used extended

keywords:
asm_cs_ds_es
_sscdeclfarhuge

interruptnearpascal
10C++:TheCompleteReference
Your compiler may also support other extensions that help it take better advantage of
its specific environment.
Noticethatallofthekeywordsarelowercase.C/C++is
case-sensitive.Thus,in
a C/C++ program, uppercase and lowercase are different. This means that
elseis akeyword,while
ELSEisnot.Youmaynotuseakeywordforanyotherpurposein
a program— that is, you may not use it as a variable or function name.
All C programs consist of one or more functions. The only function that must be
present is called
main( ), which is the first function called when program execution
begins. In well-written C code,main( )contains what is, in essence, an outline of whatthe program does. The outline is composed of function calls. Although
main( )is nota keyword, treat it as if it were. For example, don’t try to use
mainas the name of avariable because you will probably confuse the compiler.
The general form of a C program is illustrated in Figure 1-1, where
f1( )through
fN( )represent user-defined functions.
The Library and Linking
Technicallyspeaking,youcancreateauseful,functionalCorC++programthatconsistss
olelyof the statements that you actually created. However, this is quite rare because neither

C nor C++ provides any keywords that perform such things as I/O operations,

high-levelmathematicalcomputations,orcharacterhandling.Asaresult,mostprograms

include calls to various functions contained in thestandard library.All C++ compilers come with a standard library of functions that perform most
commonly needed tasks. Standard C++ specifies a minimal set of functions that will be

supported by all compilers. However, your compiler will probably contain many other

functions. For example, the standard library does not define any graphics functions,

but your compiler will probably include some.
autodoubleintstruct
break
elselongswitchcaseenumregister
typedefcharexternreturn
unionconstfloatshortunsignedcontinueforsignedvoiddefaultgotosizeofvolatiledoifstaticwhileTable1-2.
The 32 Keywords Defined by the C Subset of C++
Chapter1:AnOverviewofC
11THEFOUNDATIONOFC++:
THECSUBSET
The C++ standard library can be divided into two halves: the standard function
library and the class library. The standard function library is inherited from the C
language. C++ supports the entire function library defined by C89. Thus, all of the

standard C functions are available for use in C++ programs that you write.
In addition to the standard function library, C++ also defines its own class library.
The class library provides object-oriented routines that your programs may use. It also

defines the Standard Template Library (STL), which offers off-the-shelf solutions to

a variety of programming problems. Both the class library and the STLare discussed

later in this book. In Part One, only the standard function library is used, since it is the

only one that is also defined by C.global declarationsreturn-type main (parameter list)
{statement sequence}
return-type f1 (parameter list)
{statement sequence}
return-type f2 (parameter list)
{statement sequence}
.
.
.
return-type fN(parameter list)
{statement sequence}Figure1-1.
The general form of a C program
12C++:TheCompleteReference
The standard function library contains most of the general-purpose functions that
you will use. When you call a library function, the compiler “remembers” its name.
Later, the linker combines the code you wrote with the object code for the library

function, which is found in the standard library. This process is called
linking. Somecompilers have their own linker, while others use the standard linker supplied by

your operating system.The functions in the library are in
relocatable
format. This means that the memoryaddressesforthevariousmachine-codeinstructionshavenotbeenabsolutelydefined—

only offset information has been kept. When your program links with the functions in

the standard library, these memory offsets are used to create the actual addresses used.

Several technical manuals and books explain this process in more detail. However, you

do not need any further explanation of the actual relocation process to program in C++.
Many of the functions that you will need as you write programs are in the standard
library. They act as building blocks that you combine. If you write a function that you

will use again and again, you can place it into a library, too.
Separate CompilationMost short programs are completely contained within one source file. However, as

a program’s length grows, so does its compile time (and long compile times make for

short tempers). Hence, C/C++ allows a program to be contained in multiple files and

lets you compile each file separately. Once you have compiled all files, they are linked,

along with any library routines, to form the complete object code. The advantage of

separatecompilationisthatifyouchangethecodeofonefile,youdonotneedtorecompilethe

entire program. On all but the most simple projects, this saves a substantial amount of

time. The user documentation to your C/C++ compiler will contain instructions for

compiling multiple-file programs.
Understanding the .C and .CPP File ExtensionsThe programs in Part One of this book are, of course, valid C++ programs and can be

compiledusinganymodernC++compiler.TheyarealsovalidCprogramsandcan

becompiledusingaCcompiler.Thus,ifyouarecalledupontowriteCprograms,

the programs shown in Part One qualify as examples. Traditionally, C programs use the

fileextension
.CandC++programsusetheextension
.CPP.AC++compileruses
the file extension to determine what type of program it is compiling. This is important

because the compiler assumes that any program using the
.Cextension is a C program
and that any file using.CPPis a C++ program. Unless explicitly noted otherwise, you
may use either extension for the programs in Part One. However, the programs in the

rest of this book will require
.CPP.One last point: Although C is a subset of C++, there are a few minor differences
between the two languages and in a few cases, you may need to compile a C program

as a C program
(using the.Cextension). Any instances of this will be noted.Chapter2
Expressions13Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This chapter examines the most fundamental element of the C (as well as the C++)language: the expression. As you will see, expressions in C/C++ are substantially
more general and more powerful than in most other computer languages.Expressions are formed from these atomic elements: data and operators. Data may be
represented either by variables or by constants. Like most other computer languages,
C/C++ supports a number of different types of data. It also provides a wide variety
of operators.The Five Basic Data Types
There are five atomic data types in the C subset: character, integer, floating-point,

double floating-point, and valueless (char,int,float,double, andvoid, respectively).
As you will see, all other data types in C are based upon one of these types. The size

andrangeofthesedatatypesmayvarybetweenprocessortypesandcompilers.However,

in all cases a character is 1 byte. The size of an integer is usually the same as the word

lengthoftheexecutionenvironmentoftheprogram.Formost16-bitenvironments,such

as DOS or Windows 3.1, an integer is 16 bits. For most 32-bit environments, such as

Windows 2000, an integer is 32 bits. However, you cannot make assumptions about

the size of an integer if you want your programs to be portable to the widest range of

environments.ItisimportanttounderstandthatbothCandC++onlystipulatethe

minimalrange
of each data type, not its size in bytes.To the five basic data types defined by C, C++ adds two more:
boolandwchar_t. Theseare discussed in Part Two.
Theexactformatoffloating-pointvalueswilldependuponhowtheyareimplemented.
Integers will generally correspond to the natural size of a word on the host computer.

Values of type
charare generally used to hold values defined by the ASCII character
set. Values outside that range may be handled differently by different compilers.
The range offloatanddoublewill depend upon the method used to represent
the floating-point numbers. Whatever the method, the range is quite large. Standard

C specifies that the minimum range for a floating-point value is 1E−37 to 1E+37. Theminimum number of digits of precision for each floating-point type is shown in

Table 2-1.
Standard C++ does not specify a minimum size or range for the basic types. Instead, it
simply states that they must meet certain requirements. For example, Standard C++

statesthatan
intwill“havethenaturalsizesuggestedbythearchitectureofthe
execution environment." In all cases, this will meet or exceed the minimum ranges

specified by Standard C. Each C++ compiler specifies the size and range of the basic
types in the header<climits>.14C++:TheCompleteReference
The typevoideither explicitly declares a function as returning no value or creates
generic pointers. Both of these uses are discussed in subsequent chapters.
Modifying the Basic Types
Except for typevoid, the basic data types may have various modifiers preceding them.
You use a
modifierto alter the meaning of the base type to fit various situations more
precisely. The list of modifiers is shown here:
signedunsigned
long
shortChapter2:Expressions
15THEFOUNDATIONOFC++:
THECSUBSET
Type
Typical Size in BitsMinimal Range
char8−127 to 127unsigned char80 to 255signed char8−127 to 127int16 or 32−32,767 to 32,767unsigned int16 or 320 to 65,535signed int16 or 32same asintshort int16−32,767 to 32,767unsigned short int160 to 65,535signed short int16same asshort intlong int32−2,147,483,647 to
2,147,483,647signed long int32same aslong intunsigned long int320 to 4,294,967,295float32Six digits of precision
double64Ten digits of precision
long double80Ten digits of precision
Table2-1.
All Data Types Defined by the ANSI/ISO C Standard
Youcanapplythemodifiers
signed,short,long,and
unsignedtointegerbasetypes.
You can apply
unsignedandsignedto characters. You may also apply
longtodouble.Table 2-1 shows all valid data type combinations, along with their minimal ranges and
approximate bit widths. (These values also apply to a typical C++ implementation.)

Remember, the table shows the
minimum rangethat these types will have as specifiedby Standard C/C++, not their typical range. For example, on computers that use two's

complement arithmetic (which is nearly all), an integer will have a range of at least
32,767 to –32,768.The use ofsignedon integers is allowed, but redundant because the default integer
declaration assumes a signed number. The most important use of
signedis to modifycharin implementations in whichcharis unsigned by default.The difference between signed and unsigned integers is in the way that the high-
orderbitoftheintegerisinterpreted.Ifyouspecifyasignedinteger,thecompiler

generatescodethatassumesthatthehigh-orderbitofanintegeristobeusedasa

signflag
. If the sign flag is 0, the number is positive; if it is 1, the number is negative.In general, negative numbers are represented using the
two'scomplement
approach,
which reverses all bits in the number (except the sign flag), adds 1 to this number, and

sets the sign flag to 1.Signed integers are important for a great many algorithms, but they only have half
the absolute magnitude of their unsigned relatives. For example, here is 32,767:
0 1 1 1 1 1 1 1  1 1 1 1 1 1 1 1If the high-order bit were set to 1, the number would be interpreted as
−1. However,
if you declare this to be an
unsignedint
, the number becomes 65,535 when the high-order bit is set to 1.
When a type modifier is used by itself (that is, when it does not precede a basic
type), thenintis assumed. Thus, the following sets of type specifiers are equivalent:
SpecifierSame Assignedsigned intunsignedunsigned intlonglong intshortshort intAlthough theintis implied, many programmers specify the
intanyway.
Identifier NamesIn C/C++, the names of variables, functions, labels, and various other user-defined

objects are called
identifiers. These identifiers can vary from one to several characters.
16C++:TheCompleteReference
The first character must be a letter or an underscore, and subsequent characters must
be either letters, digits, or underscores. Here are some correct and incorrect identifier

names:Correct
Incorrect
Count1counttest23hi!there
high_balancehigh...balanceIn C, identifiers may be of any length. However, not all characters will necessarily
be significant. If the identifier will be involved in an external link process, then at

least the first six characters will be significant. These identifiers, calledexternal names,include function names and global variables that are shared between files. If the

identifier is not used in an external link process, then at least the first 31 characters

will be significant. This type of identifier is called aninternal nameand includes thenames of local variables, for example. In C++, there is no limit to the length of an

identifier, and at least the first 1,024 characters are significant. This difference may

be important if you are converting a program from C to C++.
In an identifier, upper- and lowercase are treated as distinct. Hence,
count,Count,andCOUNTare three separate identifiers.
An identifier cannot be the same as a C or C++ keyword, and should not have the
same name as functions that are in the C or C++ library.
Variables
As you probably know, a
variableis a named location in memory that is used to hold avalue that may be modified by the program. All variables must be declared before they

can be used. The general form of a declaration istype variable_list;Here,
typemust be a valid data type plus any modifiers, andvariable_listmay consist ofone or more identifier names separated by commas. Here are some declarations:
int i,j,l;short int si;
unsigned int ui;
double balance, profit, loss;Remember, in C/C++ the name of a variable has nothing to do with its type.
Chapter2:Expressions
17THEFOUNDATIONOFC++:
THECSUBSET
Where Variables Are Declared
Variables will be declared in three basic places: inside functions, in the definition of
function parameters, and outside of all functions. These are local variables, formal

parameters, and global variables.Local Variables
Variables that are declared inside a function are called
localvariables
. In some C/C++literature, these variables are referred to as
automaticvariables. This book uses the more
common term, local variable. Local variables may be referenced only by statements that

are inside the block in which the variables are declared. In other words, local variables

are not known outside their own code block. Remember, a block of code begins with an

opening curly brace and terminates with a closing curly brace.Local variables exist only while the block of code in which they are declared is
executing. That is, a local variable is created upon entry into its block and destroyed

upon exit.The most common code block in which local variables are declared is the function.
For example, consider the following two functions:void func1(void){int x;x = 10;}
void func2(void){int x;x = -199;}The integer variablexis declared twice, once in
func1( )and once infunc2( ). Thexinfunc1()
hasnobearingonorrelationshiptothe
xinfunc2()
.Thisisbecauseeach
xis known only to the code within the block in which it is declared.
The C language contains the keyword
auto, which you can use to declare local
variables. However, since all nonglobal variables are, by default, assumed to be
auto,this keyword is virtually never used. Hence, the examples in this book will not use it.
(It has been said thatautowas included in C to provide for source-level compatibility
with its predecessor B. Further,
autois supported in C++ to provide compatibility
with C.)18C++:TheCompleteReference
Chapter2:Expressions
19THEFOUNDATIONOFC++:
THECSUBSET
Forreasonsofconvenienceandtradition,mostprogrammersdeclareallthevariables
used by a function immediately after the function's opening curly braceand before any
other statements. However, you may declare local variables within any code block. The

block defined by a function is simply a special case. For example,void f(void){int t;scanf("%d%*c", &t);
if(t==1) {char s[80];  /* this is created only uponentry into this block */printf("Enter name:");gets(s);
/* do something ... */}}Here, the local variable
sis created upon entry into the
ifcode block and destroyed
upon exit. Furthermore,
sis known only within theifblock and may not be referenced
elsewhere—even in other parts of the function that contains it.
Declaringvariableswithintheblockofcodethatusesthemhelpsprevent
unwanted side effects. Since a variable does not exist outside the block in which it is
declared, it cannot be accidentally altered.
There is an important difference between C (as defined by C89) and C++ as to
where you can declare local variables. In C, you must declare all local variables at the

start of a block, prior to any "action" statements. For example, in C89 the following
function is in error.
/* For C89, this function is in error,but it is perfectly acceptable for C++.*/void f(void)
{int i;i = 10;
int j;  /* this line will cause an error */j = 20;}However,inC++,thisfunctionisperfectlyvalidbecauseyoucandeclarelocal
variables at any point within a block, prior to their first use. (The topic of C++ variable
declaration is discussed in depth in Part Two.) As a point of interest, C99 allows you to

define variables at any point within a block.Because local variables are created and destroyed with each entry and exit from
the block in which they are declared, their content is lost once the block is left. This is

especially important to remember when calling a function. When a function is called,

its local variables are created, and upon its return they are destroyed. This means that

local variables cannot retain their values between calls. (However, you can direct the

compiler to retain their values by using the
staticmodifier.)
Unless otherwise specified, local variables are stored on the stack. The fact that
the stack is a dynamic and changing region of memory explains why local variables

cannot, in general, hold their values between function calls.Youcaninitializealocalvariabletosomeknownvalue.Thisvaluewillbeassigned
tothevariableeachtimetheblockofcodeinwhichitisdeclaredisentered.Forexample,

thefollowingprogramprintsthenumber10tentimes:
#include <stdio.h>void f(void);
int main(void){int i;for(i=0; i<10; i++)  f();
return 0;}
void f(void){int j = 10;printf("%d ", j);
j++;  /* this line has no lasting effect */}20C++:TheCompleteReference
Formal Parameters
If a function is to use arguments, it must declare variables that will accept the values
of the arguments. These variables are called the
formalparameters
of the function. Theybehave like any other local variables inside the function. As shown in the following
program fragment, their declarations occur after the function name and inside

parentheses:
/* Return 1 if c is part of string s; 0 otherwise */int is_in(char *s, char c)
{while(*s)if(*s==c) return 1;
else s++;return 0;}Thefunction
is_in( )hastwoparameters:
sandc.Thisfunctionreturns1ifthecharacter
specifiedin
ciscontainedwithinthestring
s;0ifitisnot.
Youmustspecifythetypeoftheformalparametersbydeclaringthemasjustshown.
Thenyoumayusetheminsidethefunctionasnormallocalvariables.Keepinmindthat,
aslocalvariables,theyarealsodynamicandaredestroyeduponexitfromthefunction.
Aswithlocalvariables,youmaymakeassignmentstoafunction'sformalparameters
orusetheminanyallowableexpression.Eventhoughthesevariablesreceivethevalueof

theargumentspassedtothefunction,youcanusethemlikeanyotherlocalvariable.
Global Variables
Unlike local variables,global variablesare known throughout the program and may be
used by any piece of code. Also, they will hold their value throughout the program's

execution. You create global variables by declaring them outside of any function. Any

expression may access them, regardless of what block of code that expression is in.
Inthefollowingprogram,thevariable
counthasbeendeclaredoutsideofallfunctions.
Although its declaration occurs before the
main( )function, you could have placed itanywhere before its first use as long as it was not in a function. However, it is usually

best to declare global variables at the top of the program.
#include <stdio.h>int count;  /* count is global */void func1(void);Chapter2:Expressions
21THEFOUNDATIONOFC++:
THECSUBSET
void func2(void);int main(void){count = 100;
func1();return 0;}
void func1(void){int temp;temp = count;func2();
printf("count is %d", count); /* will print 100 */}void func2(void){int count;for(count=1; count<10; count++)putchar('.');}Look closely at this program. Notice that although neither
main( )norfunc1( )hasdeclared the variable
count, both may use it.func2( ), however, has declared a local
variable calledcount. Whenfunc2( )refers to
count, it refers to only its local variable,
not the global one. If a global variable and a local variable have the same name, allreferences to that variable name inside the code block in which the local variable is

declaredwillrefertothatlocalvariableandhavenoeffectontheglobalvariable.

This can be convenient, but forgetting it can cause your program to act strangely,

even though it looks correct.
Storageforglobalvariablesisinafixedregionofmemorysetasideforthispurpose
bythecompiler.Globalvariablesarehelpfulwhenmanyfunctionsinyourprogram

usethesamedata.Youshouldavoidusingunnecessaryglobalvariables,however.

Theytakeupmemorytheentiretimeyourprogramisexecuting,notjustwhentheyare

needed.Inaddition,usingaglobalwherealocalvariablewoulddomakesafunction

lessgeneralbecauseitreliesonsomethingthatmustbedefinedoutsideitself.Finally,

usingalargenumberofglobalvariablescanleadtoprogramerrorsbecauseofunknown
22C++:TheCompleteReference
Chapter2:Expressions
23THEFOUNDATIONOFC++:
THECSUBSET
andunwantedsideeffects.Amajorproblemindevelopinglargeprogramsisthe
accidentalchangingofavariable'svaluebecauseitwasusedelsewhereintheprogram.

ThiscanhappeninC/C++ifyouusetoomanyglobalvariablesinyourprograms.
The const and volatile QualifiersThere are two qualifiers that control how variables may be accessed or modified:

constandvolatile. They must precede the type modifiers and the type names that
they qualify. These qualifiers are formally referred to as the
cv-qualifiers.constVariables of type
constmay not be changed by your program. (A
constvariable can begiven an initial value, however.) The compiler is free to place variables of this type into

read-only memory (ROM). For example,
const int a=10;creates an integer variable called
awith an initial value of 10 that your program
may not modify. However, you can use the variable
ain other types of expressions.
Aconstvariable will receive its value either from an explicit initialization or by some
hardware-dependent means.
Theconstqualifier can be used to protect the objects pointed to by the arguments
to a function from being modified by that function. That is, when a pointer is passed to

afunction,thatfunctioncanmodifytheactualvariablepointedtobythepointer.However,

if the pointer is specified asconstin the parameter declaration, the function code won'tbeabletomodifywhatitpointsto.Forexample,the
sp_to_dash()
functioninthe
followingprogramprintsadashforeachspaceinitsstringargument.Thatis,thestring

"thisisatest"willbeprintedas"this-is-a-test".Theuseof
constintheparameter
declaration ensures that the code inside the function cannot modify the object pointed

to by the parameter.
#include <stdio.h>void sp_to_dash(const char *str);
int main(void){sp_to_dash("this is a test");return 0;}void sp_to_dash(const char *str){while(*str) {if(*str== ' ') printf("%c", '-');else printf("%c", *str);
str++;}}If you had writtensp_to_dash( )in such a way that the string would be modified, itwould not compile. For example, if you had codedsp_to_dash( )as follows, you wouldreceive a compile-time error:
/* This is wrong. */
void sp_to_dash(const char *str)
{while(*str) {if(*str==' ' ) *str = '-'; /* can't do this; str is const */
printf("%c", *str);
str++;}}Many functions in the standard library use
constin their parameter declarations.For example, thestrlen( )function has this prototype:
size_t strlen(const char *str);Specifyingstrasconstensures that
strlen( )will not modify the string pointed to bystr.In general, when a standard library function has no need to modify an object pointed to
by a calling argument, it is declared as
const.You can also use
constto verify that your program does not modify a variable.
Remember, a variable of type
constcan be modified by something outside yourprogram. For example, a hardware device may set its value. However, by declaring

a variable asconst, you can prove that any changes to that variable occur because of
external events.volatileThe modifiervolatiletells the compiler that a variable's value may be changed in waysnot explicitly specified by the program. For example, a global variable's address may

be passed to the operating system's clock routine and used to hold the real time of the
24C++:TheCompleteReference
Chapter2:Expressions
25THEFOUNDATIONOFC++:
THECSUBSET
system. In this situation, the contents of the variable are altered without any explicit
assignmentstatementsintheprogram.ThisisimportantbecausemostC/C++compilers

automaticallyoptimizecertainexpressionsbyassumingthatavariable'scontentis

unchangingifitdoesnotoccurontheleftsideofanassignmentstatement;thus,it

might not be reexamined each time it is referenced. Also, some compilers change the

order of evaluation of an expression during the compilation process. The
volatilemodifier prevents these changes.
You can use
constandvolatiletogether. For example, if 0x30 is assumed to be the
value of a port that is changed by external conditions only, the following declaration

would prevent any possibility of accidental side effects:
const volatile char *port = (const volatile char *) 0x30;Storage Class SpecifiersThere are four storage class specifiers supported by C:
extern
static
register
autoThese specifiers tell the compiler how to store the subsequent variable. The general

form of a declaration that uses one is shown here.
storage_specifier type var_name;Notice that the storage specifier precedes the rest of the variable declaration.
C++addsanotherstorage-classspecifiercalled
mutable,whichisdescribedin
PartTwo.
externBefore examining
extern, a brief description of C/C++ linkage is in order. C and C++
define three categories of linkage: external, internal, and none. In general, functions

and global variables have external linkage. This means that they are available to all

files that comprise a program. Global objects declared as
static(described in the nextsection) have internal linkage. These are known only within the file in which they are

declared. Local variables have no linkage and are therefore known only within their

own block.The principal use ofexternis to specify that an object is declared with external
linkage elsewhere in the program. To understand why this is important it is necessary
tounderstandthedifferencebetweena
declarationanda
definition.Adeclarationdeclares
thenameandtypeofanobject.Adefinitioncausesstoragetobeallocatedforthe
object. While there can be many declarations of the same object, there can be
onlyone
definition for the object.In most cases, variable declarations are also definitions. However, by preceding a
variable name with theexternspecifier, you can declare a variable without defining it.
Thus,whenyouneedtorefertoavariablethatisdefinedinanotherpartofyourprogram,

you can declare that variable using
extern.Here is an example that uses
extern. Notice that the global variablesfirstandlastare declared
aftermain( ).#include <stdio.h>int main(void){extern int first, last; /* use global vars */printf("%d %d", first, last);
return 0;}
/* global definition of first and last */int first = 10, last = 20;This programs outputs
10 20because the global variablesfirstandlastused by theprintf( )statement are initialized to these values. Because the
externdeclaration inmain( )tells the compiler thatfirstandlastare declared elsewhere (in this case, later
in the same file), the program can be compiled without error even though
firstandlastare used prior to their definition.
It is important to understand that theexternvariable declarations as shown in thepreceding program are necessary only because
firstandlasthad not yet been declared
prior to their use inmain( ). Had their declarations occurred prior to
main( ), then there
would have been no need for theexternstatement. Remember, if the compiler finds a
variable that has not been declared within the current block, the compiler checks if it
matchesanyofthevariablesdeclaredwithinenclosingblocks.Ifitdoesnot,thecompiler

then checks the previously declared global variables. If a match is found, the compiler

assumes that that is the variable being referenced.  The
externspecifier is needed whenyou want to use a variable that is declared later in the file.
Asmentioned,
externallowsyoutodeclareavariablewithoutdefiningit.However,
ifyougivethatvariableaninitialization,thenthe
externdeclarationbecomesadefinition.
This is important because an object can have multiple declarations, but only one
definition.26C++:TheCompleteReference
There is an important use of
externthat relates to mutiple-file programs. In C/C++,
a program can be spread across two or more files, compiled separately, and then linked
together. When this is the case, there must be some way of telling all the files about the

global variables required by the program. The best (and most portable) way to do this

is to declare all of your global variables in one file and use
externdeclarations in theother, as in Figure 2-1.
InFileTwo,theglobalvariablelistwascopiedfromFileOneandthe
externspecifierwas added to the declarations. Theexternspecifier tells the compiler that the variabletypes and names that follow it have been defined elsewhere. In other words,
externletsthe compiler know what the types and names are for these global variables without

actually creating storage for them again. When the linker links the two modules, all

references to the external variables are resolved.
In real world, multi-file programs,
externdeclarations are normally contained in
a header file that is simply included with each source code file. This is both easier and

less error prone than manually duplicating
externdeclarations in each file.In C++, theexternspecifier has another use, which is described in Part Two.
externcan also be applied to a function declaration, but doing so is redundant.
Chapter2:Expressions
27THEFOUNDATIONOFC++:
THECSUBSET
File OneFile Two
int x, y;extern int x, y;char ch;extern char ch;
int main(void)void func22(void)

{{/* ... */x = y / 10;
}}void func1(void)void func23(void)
{{x = 123;y = 10;
}}Figure2-1.
Using global variables in separately compiled modules28C++:TheCompleteReference
static Variables
staticvariables are permanent variables within their own function or file. Unlike global
variables,theyarenotknownoutsidetheirfunctionorfile,buttheymaintaintheir
valuesbetweencalls.Thisfeaturemakesthemusefulwhenyouwritegeneralized

functions and function libraries that other programmers may use.
statichas different
effects upon local variables and global variables.
static Local Variables
When you apply thestaticmodifier to a local variable, the compiler creates permanent
storageforit,muchasitcreatesstorageforaglobalvariable.Thekeydifference

betweena
staticlocalvariableandaglobalvariableisthatthe
staticlocalvariable
remains known only to the block in which it is declared. In simple terms, a
staticlocalvariable is a local variable that retains its value between function calls.
staticlocalvariablesareveryimportanttothecreationofstand-alonefunctions
becauseseveraltypesofroutinesmustpreserveavaluebetweencalls.If
staticvariableswerenotallowed,globalswouldhavetobeused,openingthedoortopossibleside

effects.Anexampleofafunctionthatbenefitsfroma
staticlocalvariableisanumber-
seriesgeneratorthatproducesanewvaluebasedonthepreviousone.Youcoulduse

aglobalvariabletoholdthisvalue.However,eachtimethefunctionisusedina

program,youwouldhavetodeclarethatglobalvariableandmakesurethatitdidnot

conflictwithanyotherglobalvariablesalreadyinplace.Thebettersolutionistodeclare

thevariablethatholdsthegeneratednumbertobe
static,asinthisprogramfragment:
int series(void){static int series_num;series_num = series_num+23;return series_num;}In this example, the variableseries_numstays in existence between function calls,instead of coming and going the way a normal local variable would. This means thateach call toseries( )can produce a new member in the series based on the preceding
number without declaring that variable globally.
You can give a
staticlocal variable an initialization value. This value is assignedonly once, at program start-up—not each time the block of code is entered, as with

normal local variables. For example, this version ofseries( )initializesseries_numto 100:int series(void){Chapter2:Expressions
29THEFOUNDATIONOFC++:
THECSUBSET
static int series_num = 100;series_num = series_num+23;return series_num;}As the function now stands, the series will always begin with the same value—in thiscase, 123. While this might be acceptable for some applications, most series generators
needtolettheuserspecifythestartingpoint.Onewaytogive
series_numauser-specified
value is to make it a global variable and then let the user set its value. However, not

definingseries_numasglobalwasthepointofmakingit
static.Thisleadstothesecond
use ofstatic.static Global Variables
Applying the specifierstaticto a global variable instructs the compiler to create a
global variable that is known only to the file in which you declared it. This means

that even though the variable is global, routines in other files may have no knowledge

of it or alter its contents directly, keeping it free from side effects. For the few situations

where a local
staticvariable cannot do the job, you can create a small file that contains
only the functions that need the globalstaticvariable, separately compile that file, anduse it without fear of side effects.
To illustrate a global
staticvariable, the series generator example from the previous
section is recoded so that a seed value initializes the series through a call to a second

function calledseries_start( ). The entire file containing
series( ),series_start( ), andseries_numis shown here:
/* This must all be in one file - preferably by itself. */static int series_num;void series_start(int seed);
int series(void);int series(void){series_num = series_num+23;
return series_num;}/* initialize series_num */void series_start(int seed)
{series_num = seed;}Callingseries_start( )with some known integer value initializes the series generator.
After that, calls toseries( )generate the next element in the series.To review: The names of local
staticvariables are known only to the block of code
in which they are declared; the names of global
staticvariables are known only to the
fileinwhichtheyreside.Ifyouplacethe
series()
andseries_start()
functionsina
library, you can use the functions but cannot reference the variable
series_num, whichis hidden from the rest of the code in your program. In fact, you can even declare and
use another variable calledseries_numin your program (in another file, of course). In
essence, thestaticmodifier permits variables that are known only to the functions that
need them, without unwanted side effects.
staticvariables enable you to hide portions of your program from other portions.
This can be a tremendous advantage when you are trying to manage a very large and

complex program.
In C++, the preceding use of
staticis still supported, but deprecated. This means that it
isnotrecommendedfornewcode.Instead,youshoulduseanamespace,whichisdescribed

in Part Two.
register Variables
Theregisterstorage specifier originally applied only to variables of typeint,char
, orpointer types. However,
register's definition has been broadened so that it applies to
any type of variable.Originally, the
registerspecifier requested that the compiler keep the value of a
variable in a register of the CPU rather than in memory, where normal variables are

stored. This meant that operations on a
registervariable could occur much faster thanon a normal variable because theregistervariable was actually held in the CPU anddid not require a memory access to determine or modify its value.
Today,thedefinitionof
registerhasbeengreatlyexpandedanditnowmaybeapplied
toanytypeofvariable.StandardCsimplystates"thataccesstotheobjectbeasfastas

possible."(StandardC++statesthat
registerisa"hinttotheimplementationthatthe
objectsodeclaredwillbeheavilyused.")Inpractice,charactersandintegersarestill

storedinregistersintheCPU.Largerobjectslikearraysobviouslycannotbestoredin

aregister,buttheymaystillreceivepreferentialtreatmentbythecompiler.Depending

upontheimplementationoftheC/C++compileranditsoperatingenvironment,
registervariablesmaybehandledinanywaydeemedfitbythecompiler'simplementor.Infact,

itistechnicallypermissibleforacompilertoignorethe
registerspecifieraltogether
andtreatvariablesmodifiedbyitasiftheyweren't,butthisisseldomdoneinpractice.
You can only apply the
registerspecifier to local variables and to the formalparameters in a function. Globalregistervariables are not allowed. Here is an example
that usesregistervariables. This function computes the result of M
efor integers:30C++:TheCompleteReference
Chapter2:Expressions
31THEFOUNDATIONOFC++:
THECSUBSET
int int_pwr(register int m,  register int e){register int temp;temp = 1;
for(; e; e--) temp = temp * m;return temp;}In this example,e,m, andtempare declared as
registervariables because theyare all used within the loop. The fact that
registervariables are optimized for speed
makes them ideal for control of or use in loops. Generally,
registervariables are used
where they will do the most good, which are often places where many references will
be made to the same variable. This is important because you can declare any number

of variables as being of typeregister, but not all will receive the same access speed
optimization.The number ofregistervariables optimized for speed within any one code block isdetermined by both the environment and the specific implementation of C/C++. You

don't have to worry about declaring too manyregistervariables because the compilerautomatically transformsregistervariables into nonregister variables when the limit is
reached. (This ensures portability of code across a broad line of processors.)
Usually at least tworegistervariables of typecharorintcan actually be held inthe registers of the CPU. Because environments vary widely, consult your compiler's

documentation to determine if you can apply any other types of optimization options.InC,youcannotfindtheaddressofa
registervariableusingthe
&operator(discussed
later in this chapter). This makes sense because aregistervariable might be stored in
a register of the CPU, which is not usually addressable. But this restriction does not

apply to C++. However, taking the address of a
registervariable in C++ may prevent
it from being fully optimized.
Althoughthedescriptionof
registerhasbeenbroadenedbeyonditstraditional
meaning,inpracticeitstillgenerallyhasasignificanteffectonlywithintegerand

charactertypes.Thus,youshouldprobablynotcountonsubstantialspeedimprovements

for other variable types.Variable Initializations
You can give variables a value as you declare them by placing an equal sign and

a value after the variable name. The general form of initialization istype variable_name = value;32C++:TheCompleteReference
Some examples are
char ch = 'a';int first = 0;
float balance = 123.23;Global andstaticlocal variables are initialized only at the start of the program. Local
variables (excludingstaticlocal variables) are initialized each time the block in which
theyaredeclaredisentered.Localvariablesthatarenotinitializedhaveunknown
values before the first assignment is made to them. Uninitialized global and
staticlocalvariables are automatically set to zero.
ConstantsConstantsrefer to fixed values that the program cannot alter. Constants can be of any
of the basic data types. The way each constant is represented depends upon its type.

Constants are also called
literals.Character constants are enclosed between single quotes. For example 'a' and '%'
are both character constants. Both C and C++ define wide characters (used mostly in

non-Englishlanguageenvironments),whichare16bitslong.Tospecifyawidecharacter

constant, precede the character with an
L. For example,wchar_t wc;wc = L'A';Here,
wcis assigned the wide-character constant equivalent of A. The type of widecharacters iswchar_t. In C, this type is defined in a header file and is not a built-intype. In C++,wchar_tis built in.Integer constants are specified as numbers without fractional components. For
example, 10 and –100 are integer constants. Floating-point constants require the
decimal point followed by the number's fractional component. For example, 11.123

is a floating-point constant. C/C++ also allows you to use scientific notation for
floating-point numbers.Therearetwofloating-pointtypes:
floatanddouble.Therearealsoseveralvariations
ofthebasictypesthatyoucangenerateusingthetypemodifiers.Bydefault,thecompiler

fitsanumericconstantintothesmallestcompatibledatatypethatwillholdit.Therefore,

assuming16-bitintegers,10is
intbydefault,but103,000isa
long.Eventhoughthe
value10couldfitintoacharactertype,thecompilerwillnotcrosstypeboundaries.The

only exception to the smallest type rule ar
e floating-point constants, which areassumed
to bedoubles.For most programs you will write, the compiler defaults are adequate. However,
you can specify precisely the type of numeric constant you want by using a suffix.

For floating-point types, if you follow the number with an F, the number is treated
Chapter2:Expressions
33THEFOUNDATIONOFC++:
THECSUBSET
as afloat. If you follow it with an L, the number becomes alongdouble
. For integertypes, the U suffix stands for
unsignedand the Lfor
long. Here are some examples:
Data typeConstant examplesint1 123 21000−234long int35000L−34Lunsigned int10000U 987U 40000Ufloat123.23F 4.34e−3Fdouble123.23 1.0−0.9876324long double1001.2LHexadecimal and Octal ConstantsIt is sometimes easier to use a number system based on 8 or 16 rather than 10 (ourstandard decimal system). The number system based on 8 is called
octaland uses thedigits0through7.Inoctal,thenumber10isthesameas8indecimal.Thebase16number

system is calledhexadecimaland uses the digits 0 through 9 plus the letters Athrough F,
which stand for 10, 11, 12, 13, 14, and 15, respectively. For example, the hexadecimal

number10is16indecimal.Becausethesetwonumbersystemsareusedfrequently,

C/C++allowsyoutospecifyintegerconstantsinhexadecimaloroctalinsteadof

decimal.Ahexadecimalconstantmustconsistofa0xfollowedbytheconstantin

hexadecimal form. An octal constant begins with a 0. Here are some examples:
int hex = 0x80;   /* 128 in decimal */int oct = 012;    /* 10 in decimal */String ConstantsC/C++ supports one other type of constant: the string. Astringis a set of charactersenclosedindoublequotes.Forexample,"thisisatest"isastring.Youhaveseenexamples
of strings in some of theprintf( )statements in the sample programs. Although C
allows you to define string constants, it does not formally have a string data type.
(C++doesdefine a string class, however.)
Youmustnotconfusestringswithcharacters.Asinglecharacterconstantisenclosed
in single quotes, as in 'a'. However, "a" is a string containing only one letter.
Backslash Character ConstantsEnclosing character constants in single quotes works for most printing characters. A
few, however, such as the carriage return, are impossible to enter into a string from the

keyboard. For this reason, C/C++ include the special
backslash character constantsshownin Table 2-2 so that you may easily enter these special characters as constants. These are
also referred to as
escapesequences
. You should use the backslash codes instead of their
ASCII equivalents to help ensure portability.
For example, the following program outputs a new line and a tab and then prints
the stringThis is a test.#include <stdio.h>int main(void){printf("\n\tThis is a test.");return 0;}34C++:TheCompleteReference
CodeMeaning\bBackspace\fForm feed\nNew line\rCarriage return
\tHorizontal tab\"Double quote\'Single quote\0Null\\Backslash\vVertical tab
\aAlert\?Question mark\NOctal constant (where N is an octal constant)
\xNHexadecimal constant (where N is a hexadecimal
constant)Table2-2.
Backslash CodesChapter2:Expressions
35THEFOUNDATIONOFC++:
THECSUBSET
OperatorsC/C++isrichinbuilt-inoperators.Infact,itplacesmoresignificanceonoperatorsthan
do most other computer languages. There are four main classes of operators:
arithmetic,relational
,logical,and
bitwise.Inaddition,therearesomespecialoperatorsfor
particular tasks.The Assignment OperatorYou can use the assignment operator within any valid expression. This is not the case

with many computer languages (including Pascal, BASIC, and FORTRAN), which treat

theassignmentoperatorasaspecialcasestatement.Thegeneralformoftheassignment

operator isvariable_name = expression;whereanexpressionmaybeassimpleasasingleconstantorascomplexasyourequire.

C/C++ uses a single equal sign to indicate assignment (unlike Pascal or Modula-2,
which use the := construct). The
target
, or left part, of the assignment must be a variableor a pointer, not a function or a constant.
Frequently in literature on C/C++ and in compiler error messages you will see
these two terms: lvalue and rvalue. Simply put, anlvalueis any object that can occuron the left side of an assignment statement. For all practical purposes, "lvalue" means
"variable." The termrvaluerefers to expressions on the right side of an assignment and
simply means the value of an expression.
Type Conversion in Assignments
When variables of one type are mixed with variables of another type, a
type conversionwill occur. In an assignment statement, the type conversion rule is easy: The value of

the right side (expression side) of the assignment is converted to the type of the left

side (target variable), as illustrated here:
int x;char ch;
float  f;void func(void){ch = x;    /* line 1 */
x = f;     /* line 2 */
f = ch;    /* line 3 */
f = x;     /* line 4 */}In line 1, the left high-order bits of the integer variable
xare lopped off, leaving
chwiththelower8bits.If
xwerebetween255and0,
chandxwouldhaveidenticalvalues.
Otherwise, the value ofchwould reflect only the lower-order bits of
x. In line 2,xwillreceive the nonfractional part of
f. In line 3,fwill convert the 8-bit integer value stored
inchto the same value in the floating-point format. This also happens in line 4, exceptthatfwill convert an integer value into floating-point format.When converting from integers to characters and long integers to integers, the
appropriate amount of high-order bits will be removed. In many 16-bit environments,
this means that 8 bits will be lost when going from an integer to a character and 16 bits

willbelostwhengoingfromalongintegertoaninteger.For32-bitenvironments,

24 bits will be lost when converting from an integer to a character and 16 bits will be

lost when converting from an integer to a short integer.
Table2-3summarizestheassignmenttypeconversions.Rememberthattheconversion
ofan
inttoa
float,ora
floattoa
double,andsoon,doesnotaddanyprecisionor
accuracy.Thesekindsofconversionsonlychangetheforminwhichthevalueis

represented. In addition, some compilers always treat a
charvariable as positive, nomatter what value it has, when converting it to anintorfloat. Other compilers treat
charvariable values greater than 127 as negative numbers when converting. Generally
36C++:TheCompleteReference
Target TypeExpression TypePossible Info Loss
signed charchar
If value > 127, target is negative
charshort intHigh-order 8 bits
charint (16 bits)High-order 8 bits
charint (32 bits)High-order 24 bits
charlong intHigh-order 24 bits
short intint (16 bits)Noneshort intint (32 bits)High-order 16 bits
int (16 bits)long intHigh-order 16 bits
int (32 bits)long intNoneintfloatFractional part and possibly more
floatdoublePrecision, result rounded
doublelong doublePrecision, result rounded
Table2-3.
The Outcome of Common Type ConversionsChapter2:Expressions
37THEFOUNDATIONOFC++:
THECSUBSET
speaking, you should usecharvariables for characters, and useints,shortint
s, orsignedchar
s when needed to avoid possible portability problems.
To use Table 2-3 to make a conversion not shown, simply convert one type at a time
until you finish. For example, to convert from
doubletoint, first convert from
doubletofloatand then from
floattoint.Multiple AssignmentsC/C++allowsyoutoassignmanyvariablesthesamevaluebyusingmultipleassignments
inasinglestatement.Forexample,thisprogramfragmentassigns
x,y,and
zthevalue0:
x = y = z = 0;In professional programs, variables are frequently assigned common values using this

method.Arithmetic OperatorsTable 2-4 lists C/C++'s arithmetic operators. The operators
+,−,*, and/work as theydo in most other computer languages. You can apply them to almost any built-in data

type. When you apply/to an integer or character, any remainder will be truncated.
For example, 5/2 will equal 2 in integer division.The modulus operator%also works in C/C++ as it does in other languages,yielding the remainder of an integer division. However, you cannot use it on

floating-point types. The following code fragment illustrates%:int x, y;x = 5;y = 2;printf("%d ", x/y);   /* will display 2 */printf("%d ", x%y);   /* will display 1, the remainder ofthe integer division */x = 1;
y = 2;printf("%d %d", x/y, x%y); /*  will display 0 1 */Thelastlineprintsa0anda1because1/2inintegerdivisionis0witharemainderof1.
The unary minus multiplies its operand by –1. That is, any number preceded by
a minus sign switches its sign.Increment and Decrement
C/C++includestwousefuloperatorsnotfoundinsomeothercomputerlanguages.
These are the increment and decrement operators,
++and− −. The operator++adds 1to its operand, and− −subtracts 1. In other words:
x = x+1;is the same as++x;andx = x-1;is the same asx--;Both the increment and decrement operators may either precede (prefix) or follow

(postfix) the operand. For example,38C++:TheCompleteReference
OperatorAction−Subtraction, also unary minus+Addition*Multiplication/Division%Modulus– –Decrement
++Increment
Table2-4.
Arithmetic OperatorsChapter2:Expressions
39THEFOUNDATIONOFC++:
THECSUBSET
x = x+1;can be written++x;orx++;Thereis,however,adifferencebetweentheprefixandpostfixformswhenyouuse
these operators in an expression. When an increment or decrement operator precedes

itsoperand,theincrementordecrementoperationisperformedbeforeobtainingthevalue

oftheoperandforuseintheexpression.Iftheoperatorfollowsitsoperand,thevalueof

the operand is obtained before incrementing or decrementing it. For instance,
x = 10;y = ++x;setsyto 11. However, if you write the code as
x = 10;
y = x++;yis set to 10. Either way,
xis set to 11; the difference is in when it happens.
Most C/C++ compilers produce very fast, efficient object code for increment and
decrement operations—code that is better than that generated by using the equivalent
assignment statement. For this reason, you should use the increment and decrement

operators when you can.Here is the precedence of the arithmetic operators:
highest++  – –– (unary minus)
*  /  %lowest+  –Operators on the same level of precedence are evaluated by the compiler from left to
right. Of course, you can use parentheses to alter the order of evaluation. C/C++ treats

parentheses in the same way as virtually all other computer languages. Parentheses

force an operation, or set of operations, to have a higher level of precedence.
Relational and Logical OperatorsIntheterm
relationaloperator
,relationalreferstotherelationshipsthatvaluescanhave
withoneanother.Intheterm
logicaloperator
,logicalreferstothewaystheserelationships
canbeconnected.Becausetherelationalandlogicaloperatorsoftenworktogether,they

arediscussedtogetherhere.
The idea of trueand false underlies the concepts of relational and logical operators.
In C,true is any value other than zero. False is zero. Expressions that use relational or

logical operators return 0 forfalse and 1 for true.
C++ fully supports the zero/non-zero concept of true and false. However, it also
defines thebooldata type and the Boolean constantstrueandfalse. In C++, a 0 valueis automatically converted intofalse,and a non-zero value is automatically converted
intotrue. The reverse also applies:
trueconverts to 1 andfalseconverts to 0. In C++,theoutcomeofarelationalorlogicaloperationis
trueorfalse.Butsincethisautomatically
convertsinto1or0,thedistinctionbetweenCandC++onthisissueismostlyacademic.
Table 2-5 shows the relational and logical operators. The truth table for the logical
operators is shown here using 1's and 0's.
pqp && qp || q!p00001
01011

11110

10010
Boththerelationalandlogicaloperatorsarelowerinprecedencethanthe
arithmetic operators. That is, an expression like 10 > 1+12 is evaluated as if it were
written 10 > (1+12). Of course, the result is false.
You can combine several operations together into one expression, as shown here:
10>5 && !(10<9) || 3<=4In this case, the result is true.
Although neither C nor C++ contain an exclusive OR (XOR) logical operator, you
can easily create a function that performs this task using the other logical operators.
The outcome of an XOR operation is true if and only if one operand (but not both) is
40C++:TheCompleteReference
Chapter2:Expressions
41THEFOUNDATIONOFC++:
THECSUBSET
true. The following program contains the function
xor( ), which returns the outcome of
an exclusive OR operation performed on its two arguments:
#include <stdio.h>int xor(int a, int b);
int main(void){printf("%d", xor(1, 0));
printf("%d", xor(1, 1));
printf("%d", xor(0, 1));
printf("%d", xor(0, 0));return 0;}Relational OperatorsOperatorAction>Greater than
>=Greater than or equal
<Less than<=Less than or equal= =Equal!=Not equalLogical OperatorsOperatorAction&&AND||OR!NOTTable2-5.
Relational and Logical Operators42C++:TheCompleteReference
/* Perform a logical XOR operation using thetwo arguments. */int xor(int a, int b){return (a || b) && !(a && b);}The following table shows the relative precedence of the relational and logical
operators:Highest!>   >=   <   <=
==   !=
&&Lowest||As with arithmetic expressions, you can use parentheses to alter the natural order ofevaluation in a relational and/or logical expression. For example,!0 && 0 || 0isfalse.However,whenyouaddparenthesestothesameexpression,asshownhere,

theresultistrue:
!(0 && 0) || 0Remember,allrelationalandlogicalexpressionsproduceeitheratrueorfalse
result.Therefore,thefollowingprogramfragmentisnotonlycorrect,butwillprint
thenumber1.
int x;x = 100;printf("%d", x>10);Bitwise OperatorsUnlikemanyotherlanguages,C/C++supportsafullcomplementofbitwiseoperators.
SinceCwasdesignedtotaketheplaceofassemblylanguageformostprogramming
tasks,itneededtobeabletosupportmanyoperationsthatcanbedoneinassembler,
includingoperationsonbits.
Bitwiseoperation
referstotesting,setting,orshiftingthe
actualbitsinabyteorword,whichcorrespondtothe
charandintdatatypesand
variants.Youcannotusebitwiseoperationson
float,double,longdouble
,void,bool,orother,morecomplextypes.Table2-6liststheoperatorsthatapplytobitwise

operations.Theseoperationsareappliedtotheindividualbitsoftheoperands.
The bitwise AND, OR, and NOT (one's complement) are governed by the same
truth table as their logical equivalents, except that they work bit by bit. The exclusive

OR has the truth table shown here:
pqp ^q000101
110
011Asthetableindicates,theoutcomeofanXORistrueonlyifexactlyoneoftheoperands
istrue;otherwise,itisfalse.
Bitwise operations most often find application in device drivers—such as modemprograms, disk file routines, and printer routines — because the bitwise operations

can be used to mask off certain bits, such as parity. (The parity bit confirms that the

rest of the bits in the byte are unchanged. It is usually the high-order bit in each byte.)
Chapter2:Expressions
43THEFOUNDATIONOFC++:
THECSUBSET
OperatorAction&AND|OR^Exclusive OR (XOR)~One's complement (NOT)>>Shift right<<Shift leftTable2-6.
Bitwise Operators44C++:TheCompleteReference
ThinkofthebitwiseANDasawaytoclearabit.Thatis,anybitthatis0ineither
operandcausesthecorrespondingbitintheoutcometobesetto0.Forexample,the
following function reads a character from the modem portand resets the parity bit to 0:
char get_char_from_modem(void){char ch;ch = read_modem(); /* get a character from themodem port */return(ch & 127);}Parity is often indicated by the eighth bit, which is set to 0 by ANDing it with abyte that has bits 1 through 7 set to 1 and bit 8 set to 0. The expression
ch & 127meansto AND together the bits inchwith the bits that make up the number 127. The netresult is that the eighth bit of
chis set to 0. In the following example, assume thatchhad received the character "A" and had the parity bit set:
The bitwise OR, as the reverse of AND, can be used to set a bit. Any bit that is set
to 1 in either operand causes the corresponding bit in the outcome to be set to 1. For
example, the following is 128 | 3:Ill2-2
Parity bit1 1 0 0 0 0 0 1chcontaining an "A" with parity set0 1 1 1 1 1 1 1127 in binary
&___________bitwise AND
0 1 0 0 0 0 0 1"A" without parity
1 0 0 0 0 0 0 0128 in binary
0 0 0 0 0 0 1 13 in binary
¦___________bitwise OR
1 0 0 0 0 0 1 1result
An exclusive OR, usually abbreviated XOR, will set a bit on if and only if the bits
being compared are different. For example, 127 ^120 is
Remember, relational and logical operators always produce a result that is either
true or false, whereas the similar bitwise operations may produce any arbitrary value
inaccordancewiththespecificoperation.Inotherwords,bitwiseoperationsmay

produce values other than 0 or 1, while logical operators will always evaluate to 0 or 1.
The bit-shift operators, >> and <<, move all bits in a value to the right or left asspecified. The general form of the shift-right statement isvalue >> number of bit positionsThe general form of the shift-left statement isvalue << number of bit positionsAs bits are shifted off one end, 0's are brought in the other end. (In the case of a
signed, negative integer, a right shift will cause a 1 to be brought in so that the sign bit
is preserved.) Remember, a shift is not a rotate. That is, the bits shifted off one end do

not come back around to the other. The bits shifted off are lost.
Bit-shiftoperationscanbeveryusefulwhenyouaredecodinginputfroman
external device, like a D/Aconverter, and reading status information. The bitwise shift

operators can also quickly multiply and divide integers. Ashift right effectively divides

a number by 2 and a shift left multiplies it by 2, as shown in Table 2-7. The following

program illustrates the shift operators:
/* A bit shift example. */#include <stdio.h>int main(void){unsigned int i;
int j;i = 1;Chapter2:Expressions
45THEFOUNDATIONOFC++:
THECSUBSET
0 1 1 1 1 1 1 1127 in binary
0 1 1 1 1 0 0 0120 in binary
^___________bitwise XOR
0 0 0 0 0 1 1 1result
/* left shifts */for(j=0; j<4; j++) {i = i << 1;  /* left shift i by 1, whichis same as a multiply by 2 */printf("Left shift %d: %d\n", j, i);}/* right shifts */for(j=0; j<4; j++) {i = i >> 1;  /* right shift i by 1, whichis same as a division by 2 */printf("Right shift %d: %d\n", j, i);}return 0;}The one's complement operator,
~, reverses the state of each bit in its operand. That
is, all 1's are set to 0, and all 0's are set to 1.
The bitwise operators are often used in cipher routines. If you want to make a disk
file appear unreadable, perform some bitwise manipulations on it. One of the simplest
46C++:TheCompleteReference
unsigned char x;x as each statementexecutesvalue of x
x = 7;0 0 0 0 0 1 1 17x = x<<1;0 0 0 0 1 1 1 014x = x<<3;0 1 1 1 0 0 0 0112
x = x<<2;1 1 0 0 0 0 0 0192x = x>>1;0 1 1 0 0 0 0 096x = x>>2;0 0 0 1 1 0 0 024*Each left shift multiplies by 2. Notice that information has been lost after x<<2 becausea bit was shifted off the end.
**Each right shift divides by 2. Notice that subsequent divisions do not bring back anylost bits.Table2-7.
Multiplication and Division with Shift OperatorsChapter2:Expressions
47THEFOUNDATIONOFC++:
THECSUBSET
methods is to complement each byte by using the one's complement to reverse each bit
in the byte, as is shown here:
Notice that a sequence of two complements in a row always produces the original
number. Thus, the first complement represents the coded version of that byte. The

second complement decodes the byte to its original value.You could use the
encode( )function shown here to encode a character.
/* A simple cipher function. */char encode(char ch)
{return(~ch); /* complement it */}Of course, a file encoded usingencode( )would be very easy to crack!The ? OperatorC/C++ contains a very powerful and convenient operator that replaces certain
statements of the if-then-else form. The ternary operator?takes the general formExp1 ? Exp2 : Exp3;where
Exp1,Exp2, andExp3are expressions. Notice the use and placement of the colon.
The?operatorworkslikethis:
Exp1isevaluated.Ifitistrue,
Exp2isevaluated
andbecomesthevalueoftheexpression.If
Exp1isfalse,
Exp3isevaluatedandits
valuebecomesthevalueoftheexpression.Forexample,in
x = 10;y = x>9 ? 100 : 200;yis assigned the value 100. Ifxhad been less than 9,ywould have received the value
200. The same code written using theif-elsestatement isx = 10;SameOriginalbyte
0 0 1 0 1 1 0 0
After 1st complement1 1 0 1 0 0 1 1
After 2nd complement            0 0 1 0 1 1 0 048C++:TheCompleteReference
if(x>9) y = 100;else y = 200;The?operator will be discussed more fully in Chapter 3 in relationship to the other
conditional statements.The & and * Pointer OperatorsApointeris the memory address of some object. A
pointervariable
is a variable that isspecifically declared to hold a pointer to an object of its specified type. Knowing a
variable's address can be of great help in certain types of routines. However, pointers

have three main functions in C/C++. They can provide a fast means of referencing

array elements. They allow functions to modify their calling parameters. Lastly,

they support linked lists and other dynamic data structures. Chapter 5 is devoted

exclusively to pointers. However, this chapter briefly covers the two operators that

are used to manipulate pointers.
The first pointer operator is&, a unary operator that returns the memory address
of its operand. (Remember, a unary operator only requires one operand.) For example,
m = &count;places intomthe memory address of the variable
count. This address is the computer's
internal location of the variable. It has nothing to do with the value ofcount. You can
think of&as meaning "the address of." Therefore, the preceding assignment statement
means "mreceives the address of
count."To better understand this assignment, assume that the variable
countis at memorylocation 2000. Also assume thatcounthas a value of 100. Then, after the previous
assignment,mwill have the value 2000.The second pointer operator is*, which is the complement of&. The*is a unaryoperator that returns the value of the variable located at the address that follows it.

For example, ifmcontains the memory address of the variable
count,q = *m;places the value ofcountintoq. Nowqhas the value 100 because 100 is stored at
location2000,thememoryaddressthatwasstoredin
m.Thinkof
*asmeaning
"at address." In this case, you could read the statement as "
qreceives the value at
address
m."Unfortunately, the multiplication symbol and the "at address" symbol are the
same, and the symbol for the bitwise AND and the "address of" symbol are the same.
Chapter2:Expressions
49THEFOUNDATIONOFC++:
THECSUBSET
These operators have no relationship to each other. Both
&and*have a higherprecedence than all other arithmetic operators except the unary minus, with which
they share equal precedence.
Variables that will hold memory addresses (i.e., pointers), must be declared by
putting*in front of the variable name. This indicates to the compiler that it will hold
a pointer. For example, to declare
chas a pointer to a character, write
char *ch;Here,
chis not a character but a pointer to a character—there is a big difference. The
typeofdatathatapointerpointsto,inthiscase
char,iscalledthe
basetype
ofthepointer.
However, the pointer variable itself is a variable that holds the address to an object of

the base type. Thus, a character pointer (or any pointer) is of sufficient size to hold any

address as defined by the architecture of the computer. However, as a rule, a pointer

should only point to data that is of that pointer's base type.You can mix both pointer and nonpointer variables in the same declaration
statement. For example,int x, *y, count;declares
xandcountas integer types andyas a pointer to an integer type.The following program uses
*and&operators to put the value 10 into a variablecalledtarget. As expected, this program displays the value 10 on the screen.
#include <stdio.h>int main(void){int target, source;
int *m;source = 10;m = &source;
target = *m;printf("%d", target);
return 0;}50C++:TheCompleteReference
The Compile-Time Operator sizeof
sizeofis a unary compile-time operator that returns the length, in bytes, of the variable
or parenthesized type-specifier that it precedes. For example, assuming that integers
are 4 bytes and
doubles are 8 bytes,
double f;printf("%d ", sizeof f);printf("%d", sizeof(int));will display8 4.Remember,tocomputethesizeofatype,youmustenclosethetypenameinparentheses.
Thisisnotnecessaryforvariablenames,althoughthereisnoharmdoneifyoudoso.
C/C++defines(using
typedef)aspecialtypecalled
size_t,whichcorresponds
looselytoanunsignedinteger.Technically,thevaluereturnedby
sizeofisoftype
size_t. For all practical purposes, however, you can think of it (and use it) as if it were
an unsigned integer value.sizeofprimarily helps to generate portable code that depends upon the size of thebuilt-indatatypes.Forexample,imagineadatabaseprogramthatneedstostoresix

integervaluesperrecord.Ifyouwanttoportthedatabaseprogramtoavarietyof

computers, you must not assume the size of an integer, but must determine its actual

length usingsizeof. This being the case, you could use the following routine to write
a record to a disk file:
/* Write 6 integers to a disk file. */void put_rec(int rec[6], FILE *fp)
{int len;len = fwrite(rec, sizeof(int)*6, 1, fp);if(len != 1) printf("Write Error");}Coded as shown,put_rec( )compiles and runs correctly in any environment, including
those that use 16- and 32-bit integers.One final point:sizeofis evaluated at compile time, and the value it produces is
treated as a constant within your program.
The Comma OperatorThe comma operator strings together several expressions. The left side of the comma
operator is always evaluated asvoid. This means that the expression on the right side
becomes the value of the total comma-separated expression. For example,
x = (y=3, y+1);first assignsythe value 3 and then assignsxthe value 4. The parentheses are necessary
because the comma operator has a lower precedence than the assignment operator.
Essentially, the comma causes a sequence of operations. When you use it on the
right side of an assignment statement, the value assigned is the value of the lastexpression of the comma-separated list.
The comma operator has somewhat the same meaning as the word "and" in normal
English as used in the phrase "do this and this and this."The Dot (.) and Arrow (
>) OperatorsIn C, the.(dot) and the>(arrow) operators access individual elements of structures
and unions.Structures
andunionsare compound (also called
aggregate
) data types thatmay be referenced under a single name (see Chapter 7). In C++, the dot and arrow

operators are also used to access the members of a class.
The dot operator is used when working with a structure or union directly. The
arrow operator is used when a pointer to a structure or union is used. For example,

given the fragmentstruct employee{char name[80];
int age;
float wage;} emp;struct employee *p = &emp; /* address of emp into p */you would write the following code to assign the value 123.23 to thewagemember ofstructure variable
emp:emp.wage = 123.23;However, the same assignment using a pointer to
empwould bep->wage = 123.23;The [ ] and ( ) OperatorsParentheses are operators that increase the precedence of the operations inside them.
Square brackets perform array indexing (arrays are discussed fully in Chapter 4). Given
Chapter2:Expressions
51THEFOUNDATIONOFC++:
THECSUBSET
an array, the expression within square brackets provides an index into that array. For
example,#include <stdio.h>char s[80];int main(void){s[3] = 'X';
printf("%c", s[3]);return 0;}first assigns the value 'X' to the fourth element (remember, all arrays begin at 0) of array
s, and then prints that element.Precedence Summary
Table 2-8 lists the precedence of all operators defined by C. Note that all operators,

except the unary operators and?, associate from left to right. The unary operators
(*,&,) and?associate from right to left.
C++ defines a few additional operators, which are discussed at length in Part Two.
Expressions
Operators, constants, and variables are the constituents of expressions. An
expression
inC/C++ is any valid combination of these elements. Because most expressions tend to

follow the general rules of algebra, they are often taken for granted. However, a few

aspects of expressions relate specifically to C and C++.
Order of Evaluation
Neither C nor C++ specifies the order in which the subexpressions of an expression are

evaluated. This leaves the compiler free to rearrange an expression to produce more

optimal code. However, it also means that your code should never rely upon the order

in which subexpressions are evaluated. For example, the expression
x = f1() + f2();does not ensure that
f1( )will be called before
f2( ).52C++:TheCompleteReference
Chapter2:Expressions
53THEFOUNDATIONOFC++:
THECSUBSET
Type Conversion in Expressions
When constants and variables of different types are mixed in an expression, they are
all converted to the same type. The compiler converts all operands up to the type of
the largest operand, which is called
typepromotion
. First, allcharandshort intvaluesare automatically elevated to
int. (This process is called
integral promotion
.) Once thisstep has been completed, all other conversions are done operation by operation, as

described in the following type conversion algorithm:IF an operand is along doubleTHEN the second is converted tolong doubleELSE IF an operand is adoubleTHEN the second is converted todoubleHighest( ) [ ]−> .! ~ ++––(type) * & sizeof
* / %+−<< >>< <= > >=
== !=
&
^
|
&&
||Highest?:= +=−=*= /= etc.
Lowest,Table2-8.
The Precedence of C Operators
54C++:TheCompleteReference
ELSE IF an operand is afloatTHEN the second is converted tofloatELSE IF an operand is anunsignedlong
THEN the second is converted tounsignedlong
ELSE IF an operand islongTHEN the second is converted tolongELSE IF an operand isunsigned intTHEN the second is converted tounsigned intThere is one additional special case: If one operand is
longand the other isunsigned int, and if the value of theunsigned intcannot be represented by a
long,both operands are converted to
unsignedlong
.Once these conversion rules have been applied, each pair of operands is of the
same type and the result of each operation is the same as the type of both operands.
For example, consider the type conversions that occur in Figure 2-2. First, the
characterchis converted to an integer. Then the outcome of
ch/iis converted to adoublebecausef*disdouble. The outcome off+iisfloat, becausefis afloat. Thefinal result is
double.CastsYou can force an expression to be of a specific type by using a
cast. The general form ofa cast is(type) expressionchar ch;int i;
float f;
double d;
result=(ch/i)+(f*d)–(f+i);
intdoublefloat
intdoublefloat
doubleFigure2-2.
A type conversion exampleChapter2:Expressions
55THEFOUNDATIONOFC++:
THECSUBSET
where
typeis a valid data type. For example, to make sure that the expression
x/2evaluates to typefloat, write(float) x/2Casts are technically operators. As an operator, a cast is unary and has the same
precedence as any other unary operator.
Although casts are not usually used a great deal in programming, they can be very
helpfulwhenneeded.Forexample,supposeyouwishtouseanintegerforloopcontrol,
yet to perform computation on it requires a fractional part, as in the following program:
#include <stdio.h>int main(void) /* print i and i/2 with fractions */{int i;for(i=1; i<=100; ++i)printf("%d / 2 is: %f\n", i, (float) i /2);return 0;}Without the cast
(float), only an integer division would have been performed. The castensures that the fractional part of the answer is displayed.
C++ adds four more casting operators, such as
const_castandstatic_cast. Theseoperators are discussed in Part Two.
Spacing and Parentheses
You can add tabs and spaces to expressions to make them easier to read. For example,
the following two expressions are the same:
x=10/y~(127/x);x = 10 / y ~(127/x);Redundant or additional parentheses do not cause errors or slow down the execution
of an expression. You should use parentheses to clarify the exact order of evaluation,
both for yourself and for others. For example, which of the following two expressions
is easier to read?
x = y/3-34*temp+127;x = (y/3) - (34*temp) + 127;Compound AssignmentsThere is a variation on the assignment statement, called
compoundassignment
, thatsimplifies the coding of a certain type of assignment operation. For example,x = x+10;can be written asx += 10;The operator+=tells the compiler to assign toxthe value ofxplus 10.Compound assignment operators exist for all the binary operators (those thatrequire two operands). In general, statements like:
var = var operator expressioncan be rewritten as
var operator = expressionFor another example,x = x-100;is the same asx -= 100;Compound assignment is widely used in professionally written C/C++ programs;
you should become familiar with it. Compound assignment is also commonly referred
to asshorthand assignmentbecause it is more compact.
56C++:TheCompleteReference
Chapter3
Statements57Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
58C++:TheCompleteReference
This chapter discusses the statement. In the most general sense, astatementis apart of your program that can be executed. That is, a statement specifies anaction. C and C++ categorize statements into these groups:SelectionIterationJumpLabelExpression
BlockIncluded in the selection statements are
ifandswitch. (The termconditionalstatementis often used in place of "selection statement.") The iteration statements are
while,for, anddo-while. These are also commonly called
loop statements. The jumpstatements are
break,continue,goto, andreturn. The label statements include thecaseanddefaultstatements (discussed along with theswitchstatement) and the labelstatement (discussed withgoto). Expression statements are statements composed
of a valid expression. Block statements are simply blocks of code. (Remember, a

block begins with a { and ends with a }.) Block statements are also referred to as

compoundstatements
.C++addstwoadditionalstatementtypes:the
tryblock(usedbyexception 
handling) andthe declaration statement. These are discussed in Part Two.
Since many statements rely upon the outcome of some conditional test, let's begin
by reviewing the concepts of true and false.
True and False in C and C++
ManyC/C++statementsrelyuponaconditionalexpressionthatdetermineswhatcourse

ofactionistobetaken.Aconditionalexpressionevaluatestoeitheratrueorfalsevalue.

In C, a true value is any nonzero value, including negative numbers. Afalse value is 0.

This approach to true and false allows a wide range of routines to be coded extremely

efficiently.
C++ fully supports the zero/nonzero definition of true and false just described. But
C++ also defines a Boolean data type calledbool,which can have only the valuestrueandfalse. As explained in Chapter 2, in C++, a 0 value is automatically converted intofalseandanonzerovalueisautomaticallyconvertedinto
true.Thereversealsoapplies:
trueconvertsto1and
falseconvertsto0.InC++,theexpressionthatcontrolsa
conditional statement is technically of typebool. But since any nonzero value converts
totrueand any zero value converts to
false, there is no practical difference between C
and C++ on this point.C99 has added a Boolean type called_Bool, but it is incompatible with C++. See PartTwo for a discussion on how to achieve compatibility between C99’s
_Booland C++’s
booltypes.Selection StatementsC/C++ supports two types of selection statements:ifandswitch. In addition, the?operator is an alternative toifin certain circumstances.
ifThe general form of theifstatement isif (expression
)statement;elsestatement;where a
statementmay consist of a single statement, a block of statements, or nothing(in the case of empty statements). Theelseclause is optional.Ifexpression
evaluates to true (anything other than 0), the statement or block that
forms the target of
ifis executed; otherwise, the statement or block that is the target
ofelsewill be executed, if it exists. Remember, only the code associated with
ifor thecode associated withelseexecutes, never both.In C, the conditional statement controlling
ifmust produce a scalar result. A
scalaris either an integer, character, pointer, or floating-point type. In C++, it may also be of
typebool. It is rare to use a floating-point number to control a conditional statement
because this slows execution time considerably. (It takes several instructions to perform

a floating-point operation. It takes relatively few instructions to perform an integer or

character operation.)The following program contains an example of
if.Theprogram plays a very simple
version of the "guess the magic number" game. It prints the message** Right **whentheplayerguessesthemagicnumber.Itgeneratesthemagicnumberusingthestandard

random number generatorrand( ), which returns an arbitrary number between 0 and
RAND_MAX(which defines an integer value that is 32,767 or larger).
rand( )requires
the header filestdlib.h.(AC++ program may also use the new-style header
<cstdlib>.)/* Magic number program #1. */#include <stdio.h>
#include <stdlib.h>int main(void){int magic; /* magic number */Chapter3:Statements
59THEFOUNDATIONOFC++:
THECSUBSET
int guess; /* user's guess */magic = rand(); /* generate the magic number */
printf("Guess the magic number: ");scanf("%d", &guess);if(guess == magic) printf("** Right **");
return 0;}Taking the magic number program further, the next version illustrates the use of the
elsestatement to print a message in response to the wrong number.
/* Magic number program #2. */#include <stdio.h>
#include <stdlib.h>int main(void){int magic; /* magic number */
int guess; /* user's guess */magic = rand(); /* generate the magic number */
printf("Guess the magic number: ");scanf("%d", &guess);if(guess == magic) printf("** Right **");else printf("Wrong");return 0;}Nested ifsAnested
ifis anifthat is the target of another
iforelse. Nestedifs are very common in
programming. In a nested
if, anelsestatement always refers to the nearest
ifstatementthat is within the same block as theelseand that is not already associated with an
else.For example,60C++:TheCompleteReference
if(i){if(j) statement 1;
if(k) statement 2; /* this if */
else  statement 3; /* is associated with this else */}else statement 4; /* associated with if(i) */As noted, the finalelseis not associated withif(j)because it is not in the same block.Rather, the final
elseis associated withif(i). Also, the innerelseis associated withif(k),which is the nearest
if.The C  language guarantees at least 15 levels of nesting. In practice, most compilersallowsubstantiallymore.Moreimportantly,StandardC++suggeststhatatleast256levels
ofnested
ifsbeallowedinaC++program.However,nestingbeyondafewlevelsisseldom
necessary, and excessive nesting can quickly confuse the meaning of an algorithm.
You can use a nested
ifto further improve the magic number program by providing
the player with feedback about a wrong guess.
/* Magic number program #3. */#include <stdio.h>
#include <stdlib.h>int main(void){int magic; /* magic number */
int guess; /* user's guess */magic = rand(); /* get a random number */
printf("Guess the magic number: ");scanf("%d", &guess);if (guess == magic) {printf("** Right **");printf(" %d is the magic number\n", magic);}
else {printf("Wrong, ");
if(guess > magic) printf("too high\n");
else printf("too low\n");}Chapter3:Statements
61THEFOUNDATIONOFC++:
THECSUBSET
62C++:TheCompleteReference
return 0;}The if-else-if LadderAcommon programming construct is the
if-else-if ladder,sometimes called the
if-else-ifstaircase
because of its appearance. Its general form isif (expression)statement;elseif (expression)statement;elseif(expression)statement;..
.
elsestatement;The conditions are evaluated from the top downward. As soon as a true condition

is found, the statement associated with it is executed and the rest of the ladder is

bypassed. If none of the conditions are true, the final
elseis executed. That is, if allother conditional tests fail, the lastelsestatement is performed. If the finalelseis notpresent, no action takes place if all other conditions are false.
Although the indentation of the preceding if-else-if ladder is technically correct, it
can lead to overly deep indentation. For this reason, the if-else-if ladder is generally

indented like this:if (expression)statement;else if (expression)statement;else if (expression)statement;.
.
.
elsestatement;Using an if-else-if ladder, the magic number program becomes
/* Magic number program #4. */#include <stdio.h>#include <stdlib.h>int main(void){int magic; /* magic number */
int guess; /* user's guess */magic = rand(); /* generate the magic number */
printf("Guess the magic number: ");scanf("%d", &guess);if(guess == magic) {printf("** Right ** ");printf("%d is the magic number", magic);}
else if(guess > magic)printf("Wrong, too high");else printf("Wrong, too low");return 0;}The ? AlternativeYou can use the
?operator to replace
if-elsestatements of the general form:if(condition)expression;elseexpression;However, the target of both
ifandelsemust be a single expression—not another
statement.The?is called aternaryoperator
because it requires three operands. It takes the
general formExp1 ? Exp2 : Exp3where
Exp1,Exp2, andExp3are expressions. Notice the use and placement of the colon.
Thevalueofa
?expressionisdeterminedasfollows:
Exp1isevaluated.Ifitistrue,
Exp2isevaluatedandbecomesthevalueoftheentire
?expression.If
Exp1isfalse,then
Exp3isevaluatedanditsvaluebecomesthevalueoftheexpression.Forexample,consider
Chapter3:Statements
63THEFOUNDATIONOFC++:
THECSUBSET
x = 10;y = x>9 ? 100 : 200;In this example,yis assigned the value 100. Ifxhad been less than9,
ywould havereceived the value 200. The same code written with the
if-elsestatement would bex = 10;
if(x>9) y = 100;
else y = 200;The following program uses the
?operator to square an integer value entered by
the user. However, this program preserves the sign (10 squared is 100 and
−10 squared
is−100).#include <stdio.h>int main(void){int isqrd, i;printf("Enter a number: ");scanf("%d", &i);isqrd = i>0 ? i*i : -(i*i);
printf("%d squared is %d", i, isqrd);
return 0;}Theuseofthe
?operatortoreplace
if-elsestatementsisnotrestrictedtoassignments
only.Remember,allfunctions(exceptthosedeclaredas
void)returnavalue.Thus,
youcanuseoneormorefunctioncallsina
?expression.Whenthefunction'sname
isencountered,thefunctionisexecutedsothatitsreturnvaluemaybedetermined.
Therefore,youcanexecuteoneormorefunctioncallsusingthe
?operatorbyplacing
the calls in the expressions that form the
?'s operands. Here is an example.
#include <stdio.h>int f1(int n);int f2(void);64C++:TheCompleteReference
int main(void){int t;printf("Enter a number: ");scanf("%d", &t);/* print proper message */t ? f1(t) + f2() : printf("zero entered.\n");return 0;}
int f1(int n){printf("%d ", n);
return 0;}int f2(void){printf("entered.\n");
return 0;}Entering a 0 in this example calls theprintf( )function and displays the messagezeroentered. If you enter any other number, both
f1( )andf2( )execute. Note that the valueof the?expression is discarded in this example. You don't need to assign it to anything.
Aword of warning: Some C++ compilers rearrange the order of evaluation of an
expression in an attempt to optimize the object code. This could cause functions that
form the operands of the?operator to execute in an unintended sequence.Using the?operator, you can rewrite the magic number program yet again.
/* Magic number program #5. */#include <stdio.h>
#include <stdlib.h>int main(void){int magic;
int guess;Chapter3:Statements
65THEFOUNDATIONOFC++:
THECSUBSET
66C++:TheCompleteReference
magic = rand(); /* generate the magic number */printf("Guess the magic number: ");scanf("%d", &guess);if(guess == magic) {printf("** Right ** ");printf("%d is the magic number", magic);}
elseguess > magic ? printf("High") : printf("Low");return 0;}Here, the
?operator displays the proper message based on the outcome of the test
guess > magic.The Conditional Expression
Sometimes newcomers to C/C++ are confused by the fact that you can use any
valid expression to control the
ifor the?operator. That is, you are not restricted to
expressions involving the relational and logical operators (as is the case in languages

like BASIC or Pascal). The expression must simply evaluate to either a true or false

(zero or nonzero) value. For example, the following program reads two integers from

the keyboard and displays the quotient. It uses an
ifstatement, controlled by the
second number, to avoid a divide-by-zero error.
/* Divide the first number by the second. */#include <stdio.h>
int main(void){int a, b;printf("Enter two numbers: ");scanf("%d%d", &a, &b);if(b) printf("%d\n", a/b);else printf("Cannot divide by zero.\n");return 0;}Chapter3:Statements
67THEFOUNDATIONOFC++:
THECSUBSET
This approach works because if
bis 0, the condition controlling the
ifis false and theelseexecutes. Otherwise, the condition is true (nonzero) and the division takes place.
One other point: Writing the
ifstatement as shown here
if(b != 0) printf("%d\n", a/b);is redundant, potentially inefficient, and is considered bad style. Since the value of
balone is sufficient to control the
if, there is no need to test it against 0.
switchC/C++hasabuilt-inmultiple-branchselectionstatement,called
switch,which
successivelyteststhevalueofanexpressionagainstalistofintegerorcharacterconstants.
When a match is found, the statements associated with that constant are executed. The

general form of theswitchstatement isswitch (expression) {caseconstant1:statement sequence
break;caseconstant2:statement sequence
break;caseconstant3:statement sequence
break;.
.
.
defaultstatement sequence}Theexpression
must evaluate to a character or integer value. Floating-point expressions,
forexample,arenotallowed.Thevalueof
expression
istested,inorder,againstthe
values of the constants specified in thecasestatements. When a match is found, thestatement sequence associated with thatcaseis executed until thebreakstatement orthe end of theswitchstatement is reached. The
defaultstatement is executed if nomatches are found. The
defaultis optional and, if it is not present, no action takes place
if all matches fail.In C,  aswitchcan have at least 257casestatements. Standard C++ recommends
thatat least16,384casestatements be supported! In practice, you will want to limit thenumber ofcasestatements to a smaller amount for efficiency. Although
caseis a labelstatement, it cannot exist by itself, outside of aswitch.68C++:TheCompleteReference
Thebreakstatement is one of C/C++'s jump statements. You can use it in loops as
well as in theswitchstatement (see the section "Iteration Statements"). Whenbreakisencountered in a
switch, program execution "jumps" to the line of code following the
switchstatement.There are three important things to know about the
switchstatement:Theswitchdiffers from the
ifin thatswitchcan only test for equality,whereas
ifcan evaluate any type of relational or logical expression.
No twocaseconstants in the sameswitchcan have identical values. Of course,aswitchstatement enclosed by an outerswitchmay havecaseconstants thatare the same.
If character constants are used in the
switchstatement, they are automatically
converted to integers.Theswitchstatement is often used to process keyboard commands, such as menu
selection. As shown here, the function
menu( )displays a menu for a spelling-checkerprogram and calls the proper procedures:
void menu(void){char ch;printf("1. Check Spelling\n");printf("2. Correct Spelling Errors\n");
printf("3. Display Spelling Errors\n");
printf("Strike Any Other Key to Skip\n");
printf("      Enter your choice: ");ch = getchar(); /* read the selection fromthe keyboard */switch(ch) {case '1':check_spelling();break;case '2':correct_errors();
break;case '3':display_errors();
break;default :printf("No option selected");}}Technically, the
breakstatements inside theswitchstatement are optional. They
terminate the statement sequence associated with each constant. If thebreakstatementisomitted,executionwillcontinueonintothenext
case'sstatementsuntileithera
breakor the end of theswitchis reached. For example, the following function uses the "drop
through" nature of the
cases to simplify the code for a device-driver input handler:/* Process a value */void inp_handler(int i)
{int flag;flag = -1;
switch(i) {case 1:  /* These cases have common */case 2:  /* statement sequences. */
case 3:flag = 0;
break;case 4:flag = 1;case 5:error(flag);break;default:process(i);}}This example illustrates two aspects ofswitch. First, you can havecasestatementsthat have no statement sequence associated with them. When this occurs, executionsimply drops through to the next
case. In this example, the first three
cases all executethe same statements, which are
flag = 0;break;Chapter3:Statements
69THEFOUNDATIONOFC++:
THECSUBSET
70C++:TheCompleteReference
Second, execution of one statement sequence continues into the nextcaseif nobreakstatement is present. If
imatches 4,flagis set to 1 and, because there is no
breakstatementattheendofthat
case,executioncontinuesandthecallto
error(flag)isexecuted.
Ifihad matched 5,error(flag)would have been called with a flag value of−1 (ratherthan 1).Thefactthat
casescanruntogetherwhenno
breakispresentpreventsthe
unnecessary duplication of statements, resulting in more efficient code.
Nested switch StatementsYou can have a
switchas part of the statement sequence of an outerswitch. Even if thecaseconstants of the inner and outerswitchcontain common values, no conflicts arise.For example, the following code fragment is perfectly acceptable:switch(x) {case 1:switch(y) {case 0: printf("Divide by zero error.\n");break;case 1: process(x,y);}break;case 2:.
.
.Iteration StatementsIn C/C++, and all other modern programming languages, iteration statements (also
calledloops)allowasetofinstructionstobeexecutedrepeatedlyuntilacertaincondition
is reached. This condition may be predefined (as in the
forloop), or open-ended (as inthewhileanddo-whileloops).The for LoopThe general design of theforloop is reflected in some form or another in all procedural
programminglanguages.However,inC/C++,itprovidesunexpectedflexibility

and power.
The general form of theforstatement isfor(initialization;condition;increment)statement;Theforloop allows many variations, but its most common form works like this. Theinitializationis an assignment statement that is used to set the loop control variable. The
Chapter3:Statements
71THEFOUNDATIONOFC++:
THECSUBSET
conditionis a relational expression that determines when the loop exits. The
increment
defines how the loop control variable changes each time the loop is repeated. You must
separate these three major sections by semicolons. The
forloop continues to executeas long as the condition is true. Once the condition becomes false, program execution

resumes on the statement following the
for.In the following program, a
forloop is used to print the numbers 1 through 100 on
the screen:
#include <stdio.h>int main(void){int x;for(x=1; x <= 100; x++) printf("%d ", x);
return 0;}In the loop,xis initially set to 1 and then compared with 100. Since
xis less than 100,printf()
iscalledandtheloopiterates.Thiscauses
xtobeincreasedby1andagaintested
to see if it is still less than or equal to 100. If it is,printf( )is called. This process repeats
untilxis greater than 100, at which point the loop terminates. In this example,
xis theloop control variable, which is changed and checked each time the loop repeats.
The following example is aforloop that iterates multiple statements:for(x=100; x != 65; x -= 5) {z = x*x;printf("The square of %d, %f", x, z);}Both the squaring ofxand the call toprintf( )are executed until
xequals 65. Note thattheloopis
negativerunning
:xisinitializedto100and5issubtractedfromiteachtimethe
loop repeats.
Inforloops, the conditional test is always performed at the top of the loop. Thismeans that the code inside the loop may not be executed at all if the condition is falseto begin with. For example, inx = 10;for(y=10; y!=x; ++y) printf("%d", y);
printf("%d", y);  /* this is the only printf()statement that will execute */72C++:TheCompleteReference
the loop will never execute becausexandyare equal when the loop is entered. Because
this causes the conditional expression to evaluate to false, neither the body of the loop
nor the increment portion of the loop executes. Hence,
ystill has the value 10, and theonly output produced by the fragment is the number 10 printed once on the screen.
for Loop Variations
The previous discussion described the most common form of the
forloop. However,
several variations of theforare allowed that increase its power, flexibility, and
applicability to certain programming situations.
One of the most common variations uses the comma operator to allow two ormore variables to control the loop. (Remember, you use the comma operator to string

together a number of expressions in a "do this and this" fashion. See Chapter 2.) For

example, the variablesxandycontrol the following loop, and both are initialized
inside theforstatement:for(x=0, y=0; x+y<10; ++x) {y = getchar();y = y - '0'; /* subtract the ASCII code for 0from y */.
.
.}Commas separate the two initialization statements. Each time the loop repeats,
xisincremented and
y's value is set by keyboard input. Both
xandymust be at the correct
value for the loop to terminate. Even thoughy's value is set by keyboard input,
ymustbeinitializedto0sothatitsvalueisdefinedbeforethefirstevaluationoftheconditional
expression. (If
ywere not defined, it could by chance contain the value 10, making the
conditional test false and preventing the loop from executing.)
Theconverge( )function, shown next, demonstrates multiple loop control variables
in action. Theconverge( )function copies the contents of one string into another bymoving characters from both ends, converging in the middle.
/* Demonstrate multiple loop control variables. */#include <stdio.h>
#include <string.h>void converge(char *targ, char *src);
int main(void){Chapter3:Statements
73THEFOUNDATIONOFC++:
THECSUBSET
char target[80] = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXX";converge(target, "This is a test of converge().");printf("Final string: %s\n", target);return 0;}
/* This function copies one string into another.It copies characters to both the ends,converging at the middle. */void converge(char *targ, char *src)
{int i, j;printf("%s\n", targ);for(i=0, j=strlen(src); i<=j; i++, j--) {targ[i] = src[i];
targ[j] = src[j];
printf("%s\n", targ);}}Here is the output produced by the program.
XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
TXXXXXXXXXXXXXXXXXXXXXXXXXXXX
ThXXXXXXXXXXXXXXXXXXXXXXXXXX.
ThiXXXXXXXXXXXXXXXXXXXXXXXX).
ThisXXXXXXXXXXXXXXXXXXXXXX().
This XXXXXXXXXXXXXXXXXXXXe().
This iXXXXXXXXXXXXXXXXXXge().
This isXXXXXXXXXXXXXXXXrge().
This is XXXXXXXXXXXXXXerge().
This is aXXXXXXXXXXXXverge().
This is a XXXXXXXXXXnverge().
This is a tXXXXXXXXonverge().
This is a teXXXXXXconverge().
This is a tesXXXX converge().
This is a testXXf converge().
This is a test of converge().
Final string: This is a test of converge().74C++:TheCompleteReference
Inconverge( ), theforloop uses two loop control variables,
iandj, to index thestring from opposite ends. As the loop iterates,
iis increased and
jis decreased. The
loop stops wheniis greater than
j, thus ensuring that all characters are copied.
Theconditionalexpressiondoesnothavetoinvolvetestingtheloopcontrolvariable
againstsometargetvalue.Infact,theconditionmaybeanyrelationalorlogical
statement. This means that you can test for several possible terminating conditions.For example, you could use the following function to log a user onto a remote
system. The user has three tries to enter the password. The loop terminates when the

three tries are used up or the user enters the correct password.
void sign_on(void){char str[20] = "";
int x;for(x=0; x<3 && strcmp(str, "password"); ++x) {printf("Enter password please:");gets(str);}if(x==3) return;/* else log user in ... */}This function usesstrcmp( ), the standard library function that compares two strings
and returns 0 if they match.
Remember, each of the three sections of the
forloop may consist of any validexpression. The expressions need not actually have anything to do with what the
sections are generally used for. With this in mind, consider the following example:
#include <stdio.h>int sqrnum(int num);int readnum(void);
int prompt(void);int main(void){int t;for(prompt(); t=readnum(); prompt())sqrnum(t);return 0;}int prompt(void){printf("Enter a number: ");
return 0;}int readnum(void){int t;scanf("%d", &t);return t;}int sqrnum(int num){printf("%d\n", num*num);
return num*num;}Lookcloselyatthe
forloopin
main()
.Noticethateachpartofthe
forloopiscomposed
of function calls that prompt the user and read a number entered from the keyboard. If
the number entered is 0, the loop terminates because the conditional expression will be

false. Otherwise, the number is squared. Thus, this
forloop uses the initialization andincrement portions in a nontraditional but completely valid sense.
Another interesting trait of the
forloop is that pieces of the loop definition neednot be there. In fact, there need not be an expression present for any of the sections—

the expressions are optional. For example, this loop will run until the user enters
123:for(x=0; x!=123; ) scanf("%d", &x);Notice that the increment portion of the
fordefinition is blank. This means that eachtime the loop repeats,
xis tested to see if it equals 123, but no further action takes place.If you type123at the keyboard, however, the loop condition becomes false and the
loop terminates.Chapter3:Statements
75THEFOUNDATIONOFC++:
THECSUBSET
The initialization of the loop control variable can occur outside the
forstatement.This most frequently happens when the initial condition of the loop control variable
must be computed by some complex means as in this example:gets(s);  /* read a string into s */if(*s) x = strlen(s); /* get the string's length */
else x = 10;for( ; x<10; ) {printf("%d", x);++x;}Theinitializationsectionhasbeenleftblankand
xisinitializedbeforetheloopisentered.
The Infinite LoopAlthough you can use any loop statement to create an infinite loop,
foris traditionallyused for this purpose. Since none of the three expressions that form the
forloop are
required, you can make an endless loop by leaving the conditional expression empty:
for( ; ; ) printf("This loop will run forever.\n");When the conditional expression is absent, it is assumed to be true. You may have an
initialization and increment expression, but C++ programmers more commonly use

thefor(;;)construct to signify an infinite loop.
Actually, the
for(;;)construct does not guarantee an infinite loop because a
breakstatement, encountered anywhere inside the body of a loop, causes immediate

termination. (breakis discussed in detail later in this chapter.) Program control then
resumes at the code following the loop, as shown here:
ch = '\0';for( ; ; ) {ch = getchar(); /* get a character */if(ch=='A') break; /* exit the loop */}printf("you typed an A");This loop will run until the user types an
Aat the keyboard.
76C++:TheCompleteReference
for Loops with No BodiesAstatement may be empty.This means that the body of the
forloop (or any other loop)may also be empty.You can use this fact to improve the efficiency of certain algorithms
and to create time delay loops.
Removingspacesfromaninputstreamisacommonprogrammingtask.Forexample,
a database program may allow a query such as "show all balances less than 400." The

database needs to have each word fed to it separately,without leading spaces. That is,

the database input processor recognizes "
show" but not "show". The following loopshows one way to accomplish this. It advances past leading spaces in the string pointed
to bystr.for( ; *str == ' '; str++) ;As you can see, this loop has no body—and no need for one either.
Timedelay
loopsareoftenusedinprograms.Thefollowingcodeshowshowtocreate
one by usingfor:for(t=0; t<SOME_VALUE; t++) ;The while LoopThe second loop available in C/C++ is thewhileloop. Its general form iswhile(condition)statement;where
statementis either an empty statement, a single statement, or a block ofstatements. Theconditionmay be any expression, and true is any nonzero value. The
loop iterates while the condition is true. When the condition becomes false, program

control passes to the line of code immediately following the loop.
The following example shows a keyboard input routine that simply loops until the
user typesA:char wait_for_char(void){char ch;ch = '\0';  /* initialize ch */while(ch != 'A') ch = getchar();
return ch;}Chapter3:Statements
77THEFOUNDATIONOFC++:
THECSUBSET
First,chis initialized to null. As a local variable, its value is not known whenwait_for_char( )is executed. Thewhileloop then checks to see ifchis not equal toA.Becausechwas initialized to null, the test is true and the loop begins. Each time you
press a key, the condition is tested again. Once you enter an
A, the condition becomesfalse becausechequalsA, and the loop terminates.Likeforloops,whileloops check the test condition at the top of the loop, whichmeans that the body of the loop will not execute if the condition is false to begin with.This feature may eliminate the need to perform a separate conditional test before the

loop. Thepad( )function provides a good illustration of this. It adds spaces to the end
of a string to fill the string to a predefined length. If the string is already at the desired

length, no spaces are added.
#include <stdio.h>#include <string.h>void pad(char *s, int length);
int main(void){char str[80];strcpy(str, "this is a test");pad(str, 40);
printf("%d", strlen(str));return 0;}
/* Add spaces to the end of a string. */void pad(char *s, int length)
{int l;l = strlen(s); /* find out how long it is */
while(l<length) {s[l] = ' '; /* insert a space */l++;}
s[l]= '\0'; /* strings need to beterminated in a null */}78C++:TheCompleteReference
The two arguments of
pad( )are
s, a pointer to the string to lengthen, andlength, thenumber of characters thatsshould have. If the length of stringsis already equal to or
greater than
length, the code inside thewhileloop does not execute. Ifsis shorter thanlength,pad( )adds the required number of spaces. The
strlen( )function, part of thestandard library, returns the length of the string.
If several separate conditions need to terminate awhileloop, a single variablecommonly forms the conditional expression. The value of this variable is set at various
points throughout the loop. In this example,
void func1(void){int working;working = 1; /* i.e., true */
while(working) {working = process1();if(working)working = process2();if(working)working = process3();}}any of the three routines may return false and cause the loop to exit.
There need not be any statements in the body of the
whileloop. For example,while((ch=getchar()) != 'A') ;will simply loop until the user typesA. If you feel uncomfortable putting theassignment inside thewhileconditional expression, remember that the equal sign is
just an operator that evaluates to the value of the right-hand operand.The do-while LoopUnlikeforandwhileloops,whichtesttheloopconditionatthetopoftheloop,the
do-whileloopchecksitsconditionatthebottomoftheloop.Thismeansthata
do-whileloopalwaysexecutesatleastonce.Thegeneralformofthe
do-whileloopis
do {statement;} while(condition);Chapter3:Statements
79THEFOUNDATIONOFC++:
THECSUBSET
80C++:TheCompleteReference
Although the curly braces are not necessary when only one statement is present, they
are usually used to avoid confusion (to you, not the compiler) with the
while. Thedo-whileloop iterates untilconditionbecomes false.The followingdo-whileloop will read numbers from the keyboard until it finds a
number less than or equal to 100.do {scanf("%d", &num);} while(num > 100);Perhaps the most common use of the
do-whileloop is in a menu selection function.When the user enters a valid response, it is returned as the value of the function.

Invalid responses cause a reprompt. The following code shows an improved version

of the spelling-checker menu developed earlier in this chapter:void menu(void){char ch;printf("1. Check Spelling\n");printf("2. Correct Spelling Errors\n");
printf("3. Display Spelling Errors\n");
printf("      Enter your choice: ");do {ch = getchar(); /* read the selection fromthe keyboard */switch(ch) {case '1':check_spelling();break;case '2':correct_errors();
break;case '3':display_errors();
break;}} while(ch!='1' && ch!='2' && ch!='3');}Chapter3:Statements
81THEFOUNDATIONOFC++:
THECSUBSET
Here,the
do-whileloopisagoodchoicebecauseyouwillalwayswantamenufunction
to display the menu at least once. After the options have been displayed, the program
will loop until a valid option is selected.Declaring Variables within Selection
and Iteration StatementsInC++(butnotC89),itispossibletodeclareavariablewithintheconditionalexpression
ofan
iforswitch,withintheconditionalexpressionofa
whileloop,orwithinthe
initializationportionofa
forloop.Avariabledeclaredinoneoftheseplaceshasits
scope limited to the block of code controlled by that statement. For example, a variable

declared within a
forloop will be local to that loop.Here is an example that declares a variable within the initialization portion of a
forloop:/* i is local to for loop; j is known outside loop. */int j;
for(int i = 0; i<10; i++)j = i * i;/* i = 10; // *** Error *** -- i not known here! */Here,
iis declared within the initialization portion of the
forand is used to control the
loop. Outside the loop,iis unknown.Sinceoftenaloopcontrolvariableina
forisneededonlybythatloop,thedeclaration
of the variable in the initialization portion of theforis becoming common practice.Remember, however, that this is not supported by C89. (This restriction was removed
from C by C99.)
Whether a variable declared within the initialization portion of a
forloop is local to thatloop has changed over time. Originally, the variable was available after the
for. However,
Standard C++ restricts the variable to the scope of the
forloop as just described.If your compiler fully complies with Standard C++, then you can also declare a
variable within any conditional expression, such as those used by the
ifor awhile. Forexample, this fragment,if(int x = 20) {x = x - y;82C++:TheCompleteReference
if(x>10) y = 0;}declares
xand assigns it the value 20. Since this is a true value, the target of the
ifexecutes. Variables declared within a conditional statement have their scope limited
to the block of code controlled by that statement. Thus, in this case,
xis not knownoutside theif. Frankly,not all programmers believe that declaring variables within
conditional statements is good practice, and this technique will not be used in
this book.Jump StatementsC/C++ has four statements that perform an unconditional branch:return,goto,break,andcontinue. Of these, you may usereturnandgotoanywhere in your program. You
may use thebreakandcontinuestatements in conjunction with any of the loopstatements. As discussed earlier in this chapter, you can also use
breakwithswitch.The return Statement
Thereturnstatement is used to return from a function. It is categorized as a jump
statement because it causes execution to return (jump back) to the point at which the

call to the function was made. Areturnmay or may not have a value associated withit. Ifreturnhas a value associated with it, that value becomes the return value of the
function. In C89, a non-voidfunction does not technically have to return a value. If no
return value is specified, a garbage value is returned. However, in C++ (and in C99),

a non-voidfunctionmustreturn a value. That is, in C++, if a function is specified as
returning a value, any
returnstatement within it must have a value associated with it.(Even in C89, if a function is declared as returning a value, it is good practice to

actually return one!)
The general form of thereturnstatement isreturnexpression;Theexpression
is present only if the function is declared as returning a value. In this
case, the value ofexpression
will become the return value of the function.
You can use as many
returnstatements as you like within a function. However,
the function will stop executing as soon as it encounters the firstreturn. The}that endsafunctionalsocausesthefunctiontoreturn.Itisthesameasa
returnwithoutany
specified value. If this occurs within a non-voidfunction, then the return value of the
function is undefined.Afunction declared as
voidmay not contain areturnstatement that specifies avalue. Since avoidfunction has no return value, it makes sense that no
returnstatement within avoidfunction can return a value.
See Chapter 6 for more information on
return.The goto StatementSince C/C++ has a rich set of control structures and allows additional control using
breakandcontinue, there is little need for
goto. Most programmers' chief concern
about thegotois its tendency to render programs unreadable. Nevertheless, although
thegotostatement fell out of favor some years ago, it occasionally has its uses. There
are no programming situations that require
goto. Rather, it is a convenience, which,
if used wisely,can be a benefit in a narrow set of programming situations, such as

jumping out of a set of deeply nested loops. Thegotois not used outside of this section.Thegotostatement requires a label for operation. (A
labelis a valid identifierfollowed by a colon.) Furthermore, the label must be in the same function as the
gotothat uses it—you cannot jump between functions. The general form of thegotostatement isgotolabel;.
.
.
label:where
labelis any valid label either before or after
goto. For example, you could create a
loop from 1 to 100 using the
gotoand a label, as shown here:
x = 1;loop1:x++;
if(x<100) goto loop1;The break Statement
Thebreakstatement has two uses. You can use it to terminate a
casein theswitchstatement (covered in the section on
switchearlier in this chapter). You can also use it
to force immediate termination of a loop, bypassing the normal loop conditional test.
When thebreakstatement is encountered inside a loop,the loop is immediately
terminated and program control resumes at the next statement following the loop. For
example,#include <stdio.h>int main(void){int t;Chapter3:Statements
83THEFOUNDATIONOFC++:
THECSUBSET
for(t=0; t<100; t++) {printf("%d ", t);if(t==10) break;}return 0;}prints the numbers 0 through 10 on the screen. Then the loop terminates because
breakcauses immediate exit from the loop, overriding the conditional test
t<100.Programmers often use the
breakstatement in loops in which a special conditioncan cause immediate termination. For example, here a keypress can stop the execution
of thelook_up( )function:void look_up(char *name){do {/* look up names ... */
if(kbhit()) break;} while(!found);
/* process match */}Thekbhit( )function returns 0 if you do not press a key. Otherwise, it returns a
nonzero value. Because of the wide differences between computing environments,
neither Standard C nor Standard C++ defines
kbhit( ),but you will almost certainlyhave it (or one with a slightly different name) supplied with your compiler.
Abreakcauses an exit from only the innermost loop. For example,
for(t=0; t<100; ++t) {count = 1;for(;;) {printf("%d ", count);
count++;
if(count==10) break;}}printsthenumbers1through10onthescreen100times.Eachtimeexecutionencounters
break, control is passed back to the outer
forloop.84C++:TheCompleteReference
Chapter3:Statements
85THEFOUNDATIONOFC++:
THECSUBSET
Abreakused in aswitchstatement will affect only that
switch. It does not affect
any loop theswitchhappens to be in.The exit( ) FunctionAlthoughexit( )is not a program control statement, a short digression that discusses
it is in order at this time. Just as you can break out of a loop, you can break out of a
program by using the standard library function
exit( ).This function causes immediate
termination of the entire program, forcing a return to the operating system. In effect,

theexit( )function acts as if it were breaking out of the entire program.
The general form of theexit( )function isvoid exit(intreturn_code);Thevalueof
return_code
isreturnedtothecallingprocess,whichisusuallytheoperating
system.Zeroisgenerallyusedasareturncodetoindicatenormalprogramtermination.

Other arguments are used to indicate some sort of error. You can also use the macros

EXIT_SUCCESSandEXIT_FAILURE
for thereturn_code
. Theexit( )function requires
the headerstdlib.h. AC++ program may also use the C++-style header
<cstdlib>.Programmers frequently use
exit( )when a mandatory condition for program
execution is not satisfied. For example, imagine a virtual reality computer game that

requires a special graphics adapter. The
main( )function of this game might looklike this:#include <stdlib.h>int main(void){if(!virtual_graphics()) exit(1);
play();
/* ... */}
/* .... */where
virtual_graphics()
isauser-definedfunctionthatreturnstrueifthevirtual-reality
graphics adapter is present. If the adapter is not in the system,
virtual_graphics( )returns false and the program terminates.
As another example, this version ofmenu( )usesexit( )to quit the program and
return to the operating system:
void menu(void)
{86C++:TheCompleteReference
char ch;printf("1. Check Spelling\n");printf("2. Correct Spelling Errors\n");
printf("3. Display Spelling Errors\n");
printf("4. Quit\n");
printf("      Enter your choice: ");do {ch = getchar(); /* read the selection fromthe keyboard */switch(ch) {case '1':check_spelling();break;case '2':correct_errors();
break;case '3':display_errors();
break;case '4':exit(0); /* return to OS */}} while(ch!='1' && ch!='2' && ch!='3');}The continue StatementThecontinuestatement works somewhat like thebreakstatement. Instead of forcing
termination, however,
continueforces the next iteration of the loop to take place,
skipping any code in between. For theforloop,continuecauses the conditional testand increment portions of the loop to execute. For the
whileanddo-whileloops,program control passes to the conditional tests. For example, the following program
counts the number of spaces contained in the string entered by the user:
/* Count spaces */#include <stdio.h>int main(void){char s[80], *str;int space;printf("Enter a string: ");gets(s);
str = s;for(space=0; *str; str++) {if(*str != ' ') continue;space++;}
printf("%d spaces\n", space);return 0;}Each character is tested to see if it is a space. If it is not, thecontinuestatement forces
theforto iterate again. If the characterisa space,spaceis incremented.
The following example shows how you can usecontinueto expedite the exit from
a loop by forcing the conditional test to be performed sooner:
void code(void){char done, ch;done = 0;while(!done) {ch = getchar();if(ch=='$') {done = 1;
continue;}
putchar(ch+1); /* shift the alphabet oneposition higher */}}This function codes a message by shifting all characters you type one letter higher. For
example, anAbecomes aB. The function will terminate when you type a$. After a$has been input, no further output will occur because the conditional test, brought into

effect by
continue, will finddoneto be true and will cause the loop to exit.
Chapter3:Statements
87THEFOUNDATIONOFC++:
THECSUBSET
Expression Statements
Chapter2coveredexpressionsthoroughly.However,afewspecialpointsarementioned
here. Remember, an expression statement is simply a valid expression followed by a

semicolon, as infunc();  /* a function call */a = b+c; /* an assignment statement */
b+f();   /* a valid, but strange statement */
;        /* an empty statement */The first expression statement executes a function call. The second is an assignment.
The third expression, though strange, is still evaluated by the C++ compiler and

the functionf( )is called. The final example shows that a statement can be empty(sometimes called anullstatement
).Block StatementsBlock statements are simply groups of related statements that are treated as a unit. The

statements that make up a block are logically bound together. Block statements are also

calledcompound statements. Ablock is begun with a
{and terminated by its matching}.Programmers use block statements most commonly to create a multistatement target

for some other statement, such asif. However, you may place a block statement
anywhere you would put any other statement. For example, this is perfectly valid

(although unusual) C/C++ code:#include <stdio.h>int main(void){int i;{  /* a block statement */i = 120;printf("%d", i);}return 0;}88C++:TheCompleteReference
Chapter4
Arrays andNull-Terminated Strings
89Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
90C++:TheCompleteReference
Anarrayis a collection of variables of the same type that are referred to throughacommonname.Aspecificelementinanarrayisaccessedbyanindex.
In  C/C++, all arrays consist of contiguous memory locations. The lowestaddress corresponds to the first element and the highest address to the last element.Arrays may have from one to several dimensions. The most common array is the
null-terminatedstring
, which is simply an array of characters terminated by a null.Arrays and pointers are closely related; a discussion of one usually refers to the
other. This chapter focuses on arrays, while Chapter 5 looks closely at pointers. You

should read both to understand fully these important constructs.
Single-Dimension ArraysThe general form for declaring a single-dimension array istype var_name[size];Likeothervariables,arraysmustbeexplicitlydeclaredsothatthecompilermayallocate

space for them in memory. Here,
typedeclares the base type of the array, which is the
type of each element in the array, and
sizedefines how many elements the array willhold. For example, to declare a 100-element array called
balanceof typedouble, usethis statement:double balance[100];An element is accessed by indexing the array name. This is done by placing theindex of the element within square brackets after the name of the array. For example,
balance[3] = 12.23;assigns element number 3 inbalancethe value 12.23.In C/C++, all arrays have 0 as the index of their first element. Therefore, when
you writechar p[10];youaredeclaringacharacterarraythathastenelements,
p[0]through
p[9].Forexample,
the following program loads an integer array with the numbers 0 through 99:
#include <stdio.h>int main(void){int x[100]; /* this declares a 100-integer array */int t;/* load x with values 0 through 99 */for(t=0; t<100; ++t) x[t] = t;/* display contents of x */for(t=0; t<100; ++t) printf("%d ", x[t]);return 0;}The amount of storage required to hold an array is directly related to its type and
size. For a single-dimension array, the total size in bytes is computed as shown here:
total bytes = sizeof(base type) x size of arrayC/C++ has no bounds checking on arrays. You could overwrite either end of an
array and write into some other variable's data or even into the program's code. As the
programmer,itisyourjobtoprovideboundscheckingwhereneeded.Forexample,

this code will compile without error, but is incorrect because the
forloop will causethe arraycountto be overrun.
int count[10], i;/* this causes count to be overrun */for(i=0; i<100; i++) count[i] = i;Single-dimension arrays are essentially lists of information of the same type that
are stored in contiguous memory locations in index order. For example, Figure 4-1
shows how arrayaappears in memory if it starts at memory location 1000 and isdeclared as shown here:
char a[7];Chapter4:ArraysandNull-TerminatedStrings
91THEFOUNDATIONOFC++:
THECSUBSET
Element          a[0]          a[1]          a[2]          a[3]          a[4]          a[5]          a[6]
Address          1000         1001        1002        1003         1004         1005        1006
Figure4-1.
A seven-element character array beginning at location 1000
Generating a Pointer to an ArrayYou can generate a pointer to the first element of an array by simply specifying the
array name, without any index. For example, givenint sample[10];you can generate a pointer to the first element by using the namesample. Thus, thefollowing program fragment assigns
pthe address of the first element of
sample:int *p;int sample[10];p = sample;Youcanalsospecifytheaddressofthefirstelementofanarrayusingthe
&operator.
Forexample,
sampleand&sample[0]bothproducethesameresults.However,in
professionally written C/C++ code, you will almost never see
&sample[0].Passing Single-Dimension Arrays to FunctionsIn C/C++, you cannot pass an entire array as an argument to a function. You can,
however, pass to the function a pointer to an array by specifying the array's name

without an index. For example, the following program fragment passes the address

ofitofunc1( ):int main(void){int i[10];func1(i);.
.
.}Ifafunctionreceivesasingle-dimensionarray,youmaydeclareitsformalparameter
in one of three ways: as a pointer, as a sized array, or as an unsized array. For example,
to receive
i, a function calledfunc1( )can be declared as
void func1(int *x) /* pointer */{92C++:TheCompleteReference
..
.}orvoid func1(int x[10]) /* sized array */{.
.
.}or finally asvoid func1(int x[]) /* unsized array */
{.
.
.}Allthreedeclarationmethodsproducesimilarresultsbecauseeachtellsthe
compiler that an integer pointer is going to be received. The first declaration actually
uses a pointer. The second employs the standard array declaration. In the final version,

a modified version of an array declaration simply specifies that an array of typeintofsome length is to be received. As you can see, the length of the array doesn't matter as

far as the function is concerned because C/C++ performs no bounds checking. In fact,
as far as the compiler is concerned,void func1(int x[32]){.
.
.}also works because the compiler generates code that instructs
func1( )to receive
a pointer—it does not actually create a 32-element array.
Chapter4:ArraysandNull-TerminatedStrings
93THEFOUNDATIONOFC++:
THECSUBSET
Null-Terminated Strings
By far the most common use of the one-dimensional array is as a character string.C++ supports two types of strings. The first is thenull-terminated string, which is anull-terminated character array. (Anull is zero.) Thus a null-terminated string contains

the characters that comprise the string followed by a null. This is the only type of string
defined by C, and it is still the most widely used. Sometimes null-terminated strings
are called
C-strings. C++ also defines a string class, calledstring, which provides an
object-oriented approach to string handling. It is described later in this book. Here,

null-terminated strings are examined.
When declaring a character array that will hold a null-terminated string, you needtodeclareittobeonecharacterlongerthanthelargeststringthatitistohold.For

example, to declare an array
strthat can hold a 10-character string, you would writechar str[11];This makes room for the null at the end of the string.
When you use a quoted string constant in your program, you are also creating a
null-terminated string. Astringconstant
is a list of characters enclosed in double quotes.For example,"hello there"You do not need to add the null to the end of string constants manually—the compiler

does this for you automatically.
C/C++ supports a wide range of functions that manipulate null-terminated strings.The most common are
NameFunctionstrcpy(
s1,s2)Copiess2intos1.strcat(
s1,s2)Concatenatess2onto the end ofs1.strlen(s1)Returns the length ofs1.strcmp(
s1,s2)Returns 0 if
s1ands2are the same; less than 0 if
s1<s2;greater than 0 if
s1>s2.strchr(
s1,ch)Returns a pointer to the first occurrence of
chins1.strstr(s1,s2)Returns a pointer to the first occurrence of
s2ins1.These functions use the standard header file
string.h. (C++ programs can also use the
C++-style header<cstring>.) The following program illustrates the use of these string
functions:94C++:TheCompleteReference
#include <stdio.h>#include <string.h>int main(void){char s1[80], s2[80];gets(s1);gets(s2);printf("lengths: %d %d\n", strlen(s1), strlen(s2));
if(!strcmp(s1, s2)) printf("The strings are equal\n");
strcat(s1, s2);printf("%s\n", s1);strcpy(s1, "This is a test.\n");printf(s1);
if(strchr("hello", 'e')) printf("e is in hello\n");
if(strstr("hi there", "hi")) printf("found hi");return 0;}If you run this program and enter the strings "
hello" and "hello", the output islengths: 5 5The strings are equal
hellohello
This is a test.
e is in hello
found hiRemember,
strcmp( )returns false if the strings are equal. Be sure to use the logical
operator!to reverse the condition, as just shown, if you are testing for equality.
Although C++ defines a string class, null-terminated strings are still widely used
in existing programs. They will probably stay in wide use because they offer a high
level of efficiency and afford the programmer detailed control of string operations.

However,formanysimplestring-handlingchores,C++'sstringclassprovides

a convenient alternative.THEFOUNDATIONOFC++:
THECSUBSET
Chapter4:ArraysandNull-TerminatedStrings
95Two-Dimensional Arrays
C/C++ supports multidimensional arrays. The simplest form of the multidimensionalarray is the two-dimensional array. Atwo-dimensional array is, essentially, an array of

one-dimensional arrays. To declare a two-dimensional integer array
dof size 10,20, youwould writeint d[10][20];Pay careful attention to the declaration. Some other computer languages use commas

to separate the array dimensions; C/C++, in contrast, places each dimension in its own
set of brackets.Similarly, to access point 1,2 of array
d, you would used[1][2]The following example loads a two-dimensional array with the numbers 1 through 12

and prints them row by row.
#include <stdio.h>int main(void){int t, i, num[3][4];for(t=0; t<3; ++t)for(i=0; i<4; ++i)num[t][i] = (t*4)+i+1;/* now print them out */for(t=0; t<3; ++t) {for(i=0; i<4; ++i)printf("%3d ", num[t][i]);printf("\n");}return 0;}Inthisexample,
num[0][0]hasthevalue1,
num[0][1]thevalue2,
num[0][2]thevalue3,
andsoon.Thevalueof
num[2][3]willbe12.Youcanvisualizethe
numarrayas
shown here:
96C++:TheCompleteReference
Two-dimensional arrays are stored in a row-column matrix, where the first index
indicates the row and the second indicates the column. This means that the rightmost
index changes faster than the leftmost when accessing the elements in the array in
the order in which they are actually stored in memory. See Figure 4-2 for a graphic

representation of a two-dimensional array in memory.
In the case of a two-dimensional array, the following formula yields the number of
bytes of memory needed to hold it:bytes = size of 1st index x size of 2nd index x sizeof(base type)Therefore, assuming 4-byte integers, an integer array with dimensions 10,5 would have
10 x 5 x 4or 200 bytes allocated.THEFOUNDATIONOFC++:
THECSUBSET
Chapter4:ArraysandNull-TerminatedStrings
97Figure4-2.
A two-dimensional array in memory
When a two-dimensional array is used as an argument to a function, only a pointer
tothefirstelementisactuallypassed.However,theparameterreceivingatwo-dimensional
array must define at least the size of the rightmost dimension. (You can specify the left

dimensionifyoulike,butitisnotnecessary.)Therightmostdimensionisneeded

becausethecompilermustknowthelengthofeachrowifitistoindexthearray

correctly. For example, a function that receives a two-dimensional integer array with

dimensions 10,10 is declared like this:
void func1(int x[][10]){.
.
.}The compiler needs to know the size of the right dimension in order to correctly
execute expressions such as
x[2][4]insidethefunction.Ifthelengthoftherowsisnotknown,thecompilercannotdetermine

where the third row begins.
Thefollowingshortprogramusesatwo-dimensionalarraytostorethenumeric
grade for each student in a teacher's classes. The program assumes that the teacher has

three classes and a maximum of 30 students per class. Notice the way the array
gradeis accessed by each of the functions./* A simple student grades database. */#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>#define CLASSES  3#define GRADES  30int grade[CLASSES][GRADES];
void enter_grades(void);int get_grade(int num);
void disp_grades(int g[][GRADES]);98C++:TheCompleteReference
int main(void){char ch, str[80];for(;;) {do {printf("(E)nter grades\n");printf("(R)eport grades\n");
printf("(Q)uit\n");
gets(str);
ch = toupper(*str);} while(ch!='E' && ch!='R' && ch!='Q');switch(ch) {case 'E':enter_grades();break;case 'R':disp_grades(grade);
break;case 'Q':exit(0);}}return 0;}
/* Enter the student's grades. */void enter_grades(void)
{int t, i;for(t=0; t<CLASSES; t++) {printf("Class # %d:\n", t+1);for(i=0; i<GRADES; ++i)grade[t][i] = get_grade(i);}}/* Read a grade. */int get_grade(int num)Chapter4:ArraysandNull-TerminatedStrings
99THEFOUNDATIONOFC++:
THECSUBSET
100C++:TheCompleteReference
{char s[80];printf("Enter grade for student # %d:\n", num+1);gets(s);
return(atoi(s));}/* Display grades. */void disp_grades(int g[][GRADES])
{int t, i;for(t=0; t<CLASSES; ++t) {printf("Class # %d:\n", t+1);for(i=0; i<GRADES; ++i)printf("Student #%d is %d\n", i+1, g[t][i]);}}Arrays of StringsIt is not uncommon in programming to use an array of strings. For example, the input
processortoadatabasemayverifyusercommandsagainstanarrayofvalidcommands.

To create an array of null-terminated strings, use a two-dimensional character array.

Thesizeoftheleftindexdeterminesthenumberofstringsandthesizeoftheright

indexspecifiesthemaximumlengthofeachstring.Thefollowingcodedeclaresanarray

of 30 strings, each with a maximum length of 79 characters, plus the null terminator.
char str_array[30][80];It is easy to access an individual string: You simply specify only the left index.
For example, the following statement callsgets( )with the third string in
str_array.gets(str_array[2]);The preceding statement is functionally equivalent to
gets(&str_array[2][0]);but the first of the two forms is much more common in professionally written

C/C++ code.THEFOUNDATIONOFC++:
THECSUBSET
To better understand how string arrays work, study the following short program,
which uses a string array as the basis for a very simple text editor:/* A very simple text editor. */#include <stdio.h>#define MAX 100#define LEN 80char text[MAX][LEN];
int main(void){register int t, i, j;printf("Enter an empty line to quit.\n");
for(t=0; t<MAX; t++) {printf("%d: ", t);gets(text[t]);
if(!*text[t]) break; /* quit on blank line */}for(i=0; i<t; i++) {for(j=0; text[i][j]; j++) putchar(text[i][j]);putchar('\n');}return 0;}This program inputs lines of text until a blank line is entered. Then it redisplays
each line one character at a time.Multidimensional ArraysC/C++ allows arrays of more than two dimensions. The exact limit, if any, is

determined by your compiler. The general form of a multidimensional array

declaration istype name[Size1][Size2][Size3]. . .[SizeN];Chapter4:ArraysandNull-TerminatedStrings
101102C++:TheCompleteReference
Arrays of more than three dimensions are not often used because of the amount
of memory they require. For example, a four-dimensional character array with

dimensions 10,6,9,4 requires
10 * 6 * 9 * 4or 2,160 bytes. If the array held 2-byte integers, 4,320 bytes would be needed. If the
array helddoubles (assuming 8 bytes perdouble), 17,280 bytes would be required.
The storage required increases exponentially with the number of dimensions. For

example, if a fifth dimension of size 10 was added to the preceding array, then 172,

800 bytes would be required.
Inmultidimensionalarrays,ittakesthecomputertimetocomputeeachindex.
This means that accessing an element in a multidimensional array can be slower than
accessing an element in a single-dimension array.
When passing multidimensional arrays into functions, you must declare all but
the leftmost dimension. For example, if you declare array
masint m[4][3][6][5];a function,func1( ), that receives
m, would look like this:void func1(int d[][3][6][5]){.
.
.}Of course, you can include the first dimension if you like.Indexing PointersIn C/C++, pointers and arrays are closely related. As you know, an array name
without an index is a pointer to the first element in the array. For example, consider

the following array.
char p[10];The following statements are identical:
p&p[0]Put another way,
p == &p[0]evaluates to true because the address of the first element of an array is the same as the
address of the array.
As stated, an array name without an index generates a pointer. Conversely, a
pointer can be indexed as if it were declared to be an array. For example, consider

this program fragment:
int *p, i[10];p = i;
p[5] = 100;  /* assign using index */
*(p+5) = 100; /* assign using pointer arithmetic */Both assignment statements place the value 100 in the sixth element ofi. The firststatement indexesp; the second uses pointer arithmetic. Either way, the result is the
same. (Chapter 5 discusses pointers and pointer arithmetic.)This same concept also applies to arrays of two or more dimensions. For example,
assuming thatais a 10-by-10 integer array, these two statements are equivalent:
a
&a[0][0]Furthermore,the0,4elementof
amaybereferencedtwoways:eitherbyarrayindexing,
a[0][4],orbythepointer,
*((int*)a+4)
.Similarly,element1,2iseither
a[1][2]or*((int *)a+12). In general, for any two-dimensional arraya[j][k] is equivalent to *((base-type*)a+(j*row length)+k)The cast of the pointer to the array into a pointer of its base type is necessary in order
for the pointer arithmetic to operate properly. Pointers are sometimes used to access

arrays because pointer arithmetic is often faster than array indexing.Atwo-dimensionalarraycanbereducedtoapointertoanarrayofone-dimensional
arrays. Therefore, using a separate pointer variable is one easy way to use pointers

to access elements within a row of a two-dimensional array. The following function

illustrates this technique. It will print the contents of the specified row for the global

integer arraynum:int num[10][10];.Chapter4:ArraysandNull-TerminatedStrings
103THEFOUNDATIONOFC++:
THECSUBSET
..void  pr_row(int j){int *p, t;p = (int *) &num[j][0]; /* get address of firstelement in row j */for(t=0; t<10; ++t) printf("%d ", *(p+t));}You can generalize this routine by making the calling arguments be the row, the row
length, and a pointer to the first array element, as shown here:
void pr_row(int j, int row_dimension, int *p){int t;p = p + (j * row_dimension);
for(t=0; t<row_dimension; ++t)printf("%d ", *(p+t));}..
.void f(void)
{int num[10][10];pr_row(0, 10, (int *) num); /* print first row */}Arraysofgreaterthantwodimensionsmaybereducedinasimilarway.Forexample,
athree-dimensionalarraycanbereducedtoapointertoatwo-dimensionalarray,which
can be reduced to a pointer to a single-dimension array. Generally, an
n-dimensionalarray can be reduced to a pointer and an (
n-1)-dimensional array. This new array can be
reduced again with the same method. The process ends when a single-dimension array

is produced.
104C++:TheCompleteReference
Chapter4:ArraysandNull-TerminatedStrings
105THEFOUNDATIONOFC++:
THECSUBSET
Array InitializationC/C++ allows the initialization of arrays at the time of their declaration. The generalform of array initialization is similar to that of other variables, as shown here:
type_specifier array_name[size1]. . .[sizeN] = {value_list};Thevalue_listis a comma-separated list of values whose type is compatible withtype_specifier. The first value is placed in the first position of the array, the second
value in the second position, and so on. Note that a semicolon follows the}.In the following example, a 10-element integer array is initialized with the numbers1 through 10:
int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};This means thati[0]will have the value 1 andi[9]will have the value 10.Character arrays that hold strings allow a shorthand initialization that takesthe form:chararray_name[size] = "string";For example, this code fragment initializesstrto the phrase "I like C++".char str[11] = "I like C++";This is the same as writingchar str[11] = {'I', ' ', 'l', 'i', 'k', 'e',' ', 'C','+', '+', '\0'};Because null-terminated strings end with a null, you must make sure that the array

you declare is long enough to include the null. This is why
stris 11 characters long
even though "I like C++" is only 10. When you use the string constant, the compiler
automatically supplies the null terminator.
Multidimensional arrays are initialized the same as single-dimension ones. For
example,thefollowinginitializes
sqrswiththenumbers1through10andtheir
squares.
int sqrs[10][2] = {1, 1,2, 4,3, 9,
4, 16,
5, 25,
6, 36,
7, 49,
8, 64,
9, 81,
10, 100};Wheninitializingamultidimensionalarray,youmayaddbracesaroundthe
initializers for each dimension. This is calledsubaggregate grouping
. For example, here
is another way to write the preceding declaration.
int sqrs[10][2] = {{1, 1},{2, 4},
{3, 9},
{4, 16},
{5, 25},
{6, 36},
{7, 49},
{8, 64},
{9, 81},
{10, 100}};When using subaggregate grouping, if you don't supply enough initializers for
a given group, the remaining members will be set to zero automatically.
Unsized Array InitializationsImagine that you are using array initialization to build a table of error messages,
as shown here:
char e1[12] = "Read error\n";char e2[13] = "Write error\n";
char e3[18] = "Cannot open file\n";As you might guess, it is tedious to count the characters in each message manuallytodeterminethecorrectarraydimension.Fortunately,youcanletthecompiler
106C++:TheCompleteReference
automaticallycalculatethedimensionsofthearrays.If,inanarrayinitialization
statement,thesizeofthearrayisnotspecified,theC/C++compilerautomatically

creates an array big enough to hold all the initializers present. This is called an
unsizedarray. Using this approach, the message table becomes
char e1[] = "Read error\n";char e2[] = "Write error\n";
char e3[] = "Cannot open file\n";Given these initializations, this statementprintf("%s has length %d\n",  e2,  sizeof e2);will printWrite error has length 13Besides being less tedious, unsized array initialization allows you to change any ofthe messages without fear of using incorrect array dimensions.
Unsizedarrayinitializationsarenotrestrictedtoone-dimensionalarrays.For
multidimensional arrays, you must specify all but the leftmost dimension. (The other
dimensions are needed to allow the compiler to index the array properly.) In this way,

youmaybuildtablesofvaryinglengthsandthecompilerautomaticallyallocates

enoughstorageforthem.Forexample,thedeclarationof
sqrsasanunsizedarray
is shown here:
int sqrs[][2] = {{1, 1},{2, 4},
{3, 9},
{4, 16},
{5, 25},
{6, 36},
{7, 49},
{8, 64},
{9, 81},
{10, 100}};The advantage of this declaration over the sized version is that you may lengthen orshorten the table without changing the array dimensions.Chapter4:ArraysandNull-TerminatedStrings
107THEFOUNDATIONOFC++:
THECSUBSET
A Tic-Tac-Toe Example
The longer example that follows illustrates many of the ways that you can manipulatearrayswithC/C++.Thissectiondevelopsasimpletic-tac-toeprogram.Two-dimensional

arrays are commonly used to simulate board game matrices.
The computer plays a very simple game. When it is the computer's turn, it usesget_computer_move( )to scan the matrix, looking for an unoccupied cell. When itfinds one, it puts anOthere. If it cannot find an empty location, it reports a draw
game and exits. Theget_player_move( )function asks you where you want to place
anX.The upper-left corner is location 1,1; the lower-right corner is 3,3.
The matrix array is initialized to contain spaces. Each move made by the playeror the computer changes a space into either an X or an O. This makes it easy to display
the matrix on the screen.
Each time a move has been made, the program calls the
check( )function. Thisfunction returns a space if there is no winner yet, an X if you have won, or an O if the

computer has won. It scans the rows, the columns, and then the diagonals, looking for

one that contains either all X's or all O's.Thedisp_matrix( )function displays the current state of the game. Notice how
initializing the matrix with spaces simplified this function.The routines in this example all access the
matrixarray differently. Study them to
make sure that you understand each array operation.
/* A simple Tic Tac Toe game. */#include <stdio.h>
#include <stdlib.h>char matrix[3][3];  /* the tic tac toe matrix */
char check(void);void init_matrix(void);
void get_player_move(void);
void get_computer_move(void);
void disp_matrix(void);int main(void){char done;printf("This is the game of Tic Tac Toe.\n");printf("You will be playing against the computer.\n");done =  ' ';108C++:TheCompleteReference
init_matrix();do{disp_matrix();get_player_move();
done = check(); /* see if winner */
if(done!= ' ') break; /* winner!*/
get_computer_move();
done = check(); /* see if winner */} while(done== ' ');
if(done=='X') printf("You won!\n");
else printf("I won!!!!\n");
disp_matrix(); /* show final positions */return 0;}
/* Initialize the matrix. */void init_matrix(void)
{int i, j;for(i=0; i<3; i++)for(j=0; j<3; j++) matrix[i][j] =  ' ';}
/* Get a player's move. */void get_player_move(void)
{int x, y;printf("Enter X,Y coordinates for your move: ");scanf("%d%*c%d", &x, &y);x--; y--;
if(matrix[x][y]!= ' '){printf("Invalid move, try again.\n");get_player_move();}
else matrix[x][y] = 'X';}Chapter4:ArraysandNull-TerminatedStrings
109THEFOUNDATIONOFC++:
THECSUBSET
/* Get a move from the computer. */void get_computer_move(void)
{int i, j;for(i=0; i<3; i++){for(j=0; j<3; j++)if(matrix[i][j]==' ') break;if(matrix[i][j]==' ') break;}if(i*j==9)  {printf("draw\n");exit(0);}
elsematrix[i][j] = 'O';}/* Display the matrix on the screen. */void disp_matrix(void)
{int t;for(t=0; t<3; t++) {printf(" %c | %c | %c ",matrix[t][0],matrix[t][1], matrix [t][2]);if(t!=2) printf("\n---|---|---\n");}printf("\n");}/* See if there is a winner. */char check(void)
{int i;for(i=0; i<3; i++)  /* check rows */if(matrix[i][0]==matrix[i][1] &&matrix[i][0]==matrix[i][2]) return matrix[i][0];for(i=0; i<3; i++)  /* check columns */if(matrix[0][i]==matrix[1][i] &&110C++:TheCompleteReference
matrix[0][i]==matrix[2][i]) return matrix[0][i];/* test diagonals */if(matrix[0][0]==matrix[1][1] &&matrix[1][1]==matrix[2][2])return matrix[0][0];if(matrix[0][2]==matrix[1][1] &&matrix[1][1]==matrix[2][0])return matrix[0][2];return ' ';}Chapter4:ArraysandNull-TerminatedStrings
111THEFOUNDATIONOFC++:
THECSUBSET
This page intentionally left blank Chapter5
Pointers113Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
The correct understanding and use of pointers is critical to successful C/C++programming. There are three reasons for this: First, pointers provide the means
by which functions can modify their calling arguments. Second, pointers supportdynamic allocation. Third, pointers can improve the efficiency of certain routines. Also,
as you will see in Part Two, pointers take on additional roles in C++.Pointersareoneofthestrongestbutalsooneofthemostdangerousfeaturesin
C/C++.Forexample,uninitializedpointers(orpointerscontaininginvalidvalues)

cancauseyoursystemtocrash.Perhapsworse,itiseasytousepointersincorrectly,

causing bugs that are very difficult to find.
Becauseofboththeirimportanceandtheirpotentialforabuse,thischapterexamines
the subject of pointers in detail.What Are Pointers?
Apointeris a variable that holds a memory address. This address is the location of
another object (typically another variable) in memory. For example, if one variable

contains the address of another variable, the first variable is said to
pointto
the second.Figure 5-1 illustrates this situation.
114C++:TheCompleteReference
Figure5-1.
One variable points to anotherChapter5:Pointers
115THEFOUNDATIONOFC++:
THECSUBSET
Pointer Variables
Ifavariableisgoingtoholdapointer,itmustbedeclaredassuch.Apointerdeclaration
consists of a base type, an *, and the variable name. The general form for declaring a
pointer variable istype *name;where
typeis the base type of the pointer and may be any valid type. The name ofthe pointer variable is specified byname.The base type of the pointer defines what type of variables the pointer can point to.Technically, any type of pointer can point anywhere in memory. However, all pointer

arithmeticisdonerelativetoitsbasetype,soitisimportanttodeclarethepointercorrectly.

(Pointer arithmetic is discussed later in this chapter.)
The Pointer OperatorsThe pointer operators were discussed in Chapter 2. We will take a closer look at them

here, beginning with a review of their basic operation. There are two special pointer

operators:*and&. The&is a unary operator that returns the memory address of
its operand. (Remember, a unary operator only requires one operand.) For example,
m = &count;places intomthe memory address of the variable
count. This address is the computer's
internal location of the variable. It has nothing to do with the value ofcount. You can
think of&as returning "the address of." Therefore, the preceding assignment statement
means "mreceives the address of
count."To understand the above assignment better, assume that the variable
countusesmemory location 2000 to store its value. Also assume that
counthas a value of 100.Then, after the preceding assignment,
mwill have the value 2000.The second pointer operator,
*, is the complement of&. It is a unary operator thatreturns the value located at the address that follows. For example, if
mcontains thememory address of the variable
count,q = *m;places the value ofcountintoq. Thus,qwill have the value 100 because 100 is stored
at location 2000, which is the memory address that was stored in
m. You can think of
*as "at address." In this case, the preceding statement means "
qreceives the value at
address
m."116C++:TheCompleteReference
Both&and*have a higher precedence than all other arithmetic operators except
the unary minus, with which they are equal.
You must make sure that your pointer variables always point to the correct type of
data. For example, when you declare a pointer to be of type
int, the compiler assumesthat any address that it holds points to an integer variable—whether it actually does
ornot.Becauseyoucanassignanyaddressyouwanttoapointervariable,the

following program compiles without error, but does not produce the desired result:
#include <stdio.h>int main(void){double x = 100.1, y;
int  *p;/* The next statement causes p (which is aninteger pointer) to point to a double. */p = (int *)&x;
/* The next statement does not operate asexpected. */y = *p;printf("%f", y); /* won't output 100.1 */return 0;}This will not assign the value ofxtoy. Becausepis declared as an integer pointer,
only 4 bytes of information (assuming 4-byte integers) will be transferred to
y,not
the 8 bytes that normally make up adouble.In C++, it is illegal to convert one type of pointer into another without the use of anexplicit type cast. In C, casts should be used for most pointer conversions.Pointer Expressions
In general, expressions involving pointers conform to the same rules as other

expressions. This section examines a few special aspects of pointer expressions.
Chapter5:Pointers
117THEFOUNDATIONOFC++:
THECSUBSET
Pointer AssignmentsAs with any variable, you may use a pointer on the right-hand side of an assignmentstatement to assign its value to another pointer. For example,
#include <stdio.h>int main(void){int x;
int *p1, *p2;p1 = &x;p2 = p1;printf(" %p", p2); /* print the address of x, not x's value! */
return 0;}Bothp1andp2now point tox. The address of
xis displayed by using the%pprintf( )
format specifier, which causes
printf( )to display an address in the format used by the
host computer.
Pointer ArithmeticThere are only two arithmetic operations that you may use on pointers: addition
and subtraction. To understand what occurs in pointer arithmetic, let
p1be aninteger pointer with a current value of 2000. Also, assume integers are 2 bytes long.

After the expression
p1++;p1contains 2002, not 2001. The reason for this is that each time
p1is incremented, it
will point to the next integer. The same is true of decrements. For example, assuming

thatp1has the value 2000, the expression
p1--;causesp1to have the value 1998.Generalizingfromtheprecedingexample,thefollowingrulesgovernpointer
arithmetic.Eachtimeapointerisincremented,itpointstothememorylocation
ofthenextelementofitsbasetype.Eachtimeitisdecremented,itpointstothe
locationofthepreviouselement.Whenappliedtocharacterpointers,thiswill

appearas"normal"arithmeticbecausecharactersarealways1bytelong.Allother

pointerswillincreaseordecreasebythelengthofthedatatypetheypointto.This

approachensuresthatapointerisalwayspointingtoanappropriateelementofits

basetype.Figure5-2illustratesthisconcept.
You are not limited to the increment and decrement operators. For example, you
may add or subtract integers to or from pointers. The expression
p1 = p1 + 12;makesp1pointtothetwelfthelementof
p1'stypebeyondtheoneitcurrentlypointsto.
Besidesadditionandsubtractionofapointerandaninteger,onlyoneother
arithmetic operation is allowed: You may subtract one pointer from another in order to

find the number of objects of their base type that separate the two. All other arithmetic
operationsareprohibited.Specifically,youmaynotmultiplyordividepointers;you

maynotaddtwopointers;youmaynotapplythebitwiseoperatorstothem;and

you may not add or subtract typefloatordoubleto or from pointers.
118C++:TheCompleteReference
Figure5-2.
All pointer arithmetic is relative to its base type (assume 2-byte
integers)Chapter5:Pointers
119THEFOUNDATIONOFC++:
THECSUBSET
Pointer ComparisonsYou can compare two pointers in a relational expression. For instance, given two
pointerspandq, the following statement is perfectly valid:if(p<q) printf("p points to lower memory than q\n");Generally,pointercomparisonsareusedwhentwoormorepointerspointto
acommonobject,suchasanarray.Asanexample,apairofstackroutinesare

developedthatstoreandretrieveintegervalues.Astackisalistthatusesfirst-in,

last-outaccessing.Itisoftencomparedtoastackofplatesonatable—thefirst

onesetdownisthelastonetobeused.Stacksareusedfrequentlyincompilers,

interpreters,spreadsheets,andothersystem-relatedsoftware.Tocreateastack,

youneedtwofunctions:
push( )andpop( ).The
push( )functionplacesvalueson
thestackand
pop( )takesthemoff.Theseroutinesareshownherewithasimple
main()
functiontodrivethem.Theprogramputsthevaluesyouenterintothestack.
Ifyouenter
0,avalueispoppedfromthestack.Tostoptheprogram,enter
1.#include <stdio.h>#include <stdlib.h>#define SIZE 50
void push(int i);int pop(void);int  *tos, *p1, stack[SIZE];
int main(void){int value;tos = stack; /* tos points to the top of stack */p1 = stack; /* initialize p1 */do {printf("Enter value: ");scanf("%d", &value);
if(value!=0) push(value);
else printf("value on top is %d\n", pop());} while(value!=-1);120C++:TheCompleteReference
return 0;}void push(int i){p1++;if(p1==(tos+SIZE)) {printf("Stack Overflow.\n");exit(1);}
*p1 = i;}int pop(void){if(p1==tos) {printf("Stack Underflow.\n");
exit(1);}
p1--;
return *(p1+1);}Youcanseethatmemoryforthestackisprovidedbythearray
stack.Thepointer
p1issettopointtothefirstelementin
stack.The
p1variableaccessesthestack.The
variabletosholdsthememoryaddressofthetopofthestack.Itisusedtoprevent
stackoverflowsandunderflows.Oncethestackhasbeeninitialized,
push( )andpop()
maybeused.Boththe
push( )andpop( )functionsperformarelationaltest
onthepointer
p1todetectlimiterrors.In
push( ),p1istestedagainsttheendof
stackbyadding
SIZE(thesizeofthestack)to
tos.Thispreventsanoverflow.In
pop( ),p1ischeckedagainst
tostobesurethatastackunderflowhasnotoccurred.
Inpop( ), the parentheses are necessary in the return statement. Without them, the
statement would look like this:return *p1 +1;whichwouldreturnthevalueatlocation
p1plusone,notthevalueofthelocation
p1+1.Chapter5:Pointers
121THEFOUNDATIONOFC++:
THECSUBSET
Pointers and ArraysThere is a close relationship between pointers and arrays. Consider this program
fragment:char str[80], *p1;p1 = str;Here,
p1has been set to the address of the first array element in
str. To access the fifth
element instr, you could writestr[4]or*(p1+4)Both statements will return the fifth element. Remember, arrays start at 0. To access
the fifth element, you must use 4 to indexstr. You also add 4 to the pointer
p1toaccess the fifth element becausep1currently points to the first element of
str. (Recallthat an array name without an index returns the starting address of the array, which

is the address of the first element.)
Theprecedingexamplecanbegeneralized.Inessence,C/C++providestwomethods
ofaccessingarrayelements:pointerarithmeticandarrayindexing.Althoughthe

standardarray-indexingnotationissometimeseasiertounderstand,pointerarithmetic

canbefaster.Sincespeedisoftenaconsiderationinprogramming,C/C++programmers

commonlyusepointerstoaccessarrayelements.
These two versions ofputstr( )—one with array indexing and one with pointers—illustrate how you can use pointers in place of array indexing. Theputstr( )functionwrites a string to the standard output device one character at a time.
/* Index s as an array. */void putstr(char *s)
{register int t;for(t=0; s[t]; ++t) putchar(s[t]);}122C++:TheCompleteReference
/* Access s as a pointer. */void putstr(char *s)
{while(*s) putchar(*s++);}Most professional C/C++ programmers would find the second version easier to
read and understand. In fact, the pointer version is the way routines of this sort

are commonly written in C/C++.
Arrays of PointersPointers may be arrayed like any other data type. The declaration for anintpointerarray of size 10 isint *x[10];To assign the address of an integer variable called
varto the third element of the
pointer array, write
x[2] = &var;To find the value of
var, write*x[2]If you want to pass an array of pointers into a function, you can use the samemethod that you use to pass other arrays—simply call the function with the array
name without any indexes. For example, a function that can receive array
xlookslike this:void display_array(int *q[]){int t;for(t=0; t<10; t++)printf("%d ", *q[t]);}Chapter5:Pointers
123THEFOUNDATIONOFC++:
THECSUBSET
Remember,
qis not a pointer to integers, but rather a pointer to an array of pointers tointegers. Therefore you need to declare the parameter
qas an array of integer pointers,as just shown. You cannot declare
qsimply as an integer pointer because that is notwhat it is.Pointer arrays are often used to hold pointers to strings. You can create a function
that outputs an error message given its code number, as shown here:
void syntax_error(int num){static char *err[] = {"Cannot Open File\n",
"Read Error\n",
"Write Error\n",
"Media Failure\n"};printf("%s", err[num]);}Thearray
errholdspointerstoeachstring.Asyoucansee,
printf()
insidesyntax_error( )iscalledwithacharacterpointerthatpointstooneofthevarious
errormessagesindexedbytheerrornumberpassedtothefunction.Forexample,
ifnumispasseda2,themessage
WriteError
isdisplayed.
As a point of interest, note that the command line argument
argvis an array ofcharacter pointers. (See Chapter 6.)Multiple Indirection
You can have a pointer point to another pointer that points to the target value. This

situation is calledmultipleindirection
, orpointerstopointers
. Pointers to pointers canbe confusing. Figure 5-3 helps clarify the concept of multiple indirection. As you can

see, the value of a normal pointer is the address of the object that contains the value

desired. In the case of a pointer to a pointer, the first pointer contains the address of

the second pointer, which points to the object that contains the value desired.
Multiple indirection can be carried on to whatever extent rquired, but more than a
pointer to a pointer is rarely needed. In fact, excessive indirection is difficult to follow

and prone to conceptual errors.
Do not confuse multiple indirection with high-level data structures, such as linked lists,

that use pointers. These are two fundamentally different concepts.
124C++:TheCompleteReference
Avariable that is a pointer to a pointer must be declared as such. You do this by
placing an additional asterisk in front of the variable name. For example, the following
declaration tells the compiler thatnewbalanceis a pointer to a pointer of typefloat:float **newbalance;You should understand that
newbalanceis not a pointer to a floating-point number butrather a pointer to afloatpointer.
To access the target value indirectly pointed to by a pointer to a pointer, you must
apply the asterisk operator twice, as in this example:#include <stdio.h>int main(void){int x, *p, **q;x = 10;p = &x;
q = &p;printf("%d", **q); /* print the value of x */
return 0;}Here,
pis declared as a pointer to an integer and
qas a pointer to a pointer to aninteger. The call to
printf( )prints the number10on the screen.
Figure5-3.
Single and multiple indirection
Chapter5:Pointers
125THEFOUNDATIONOFC++:
THECSUBSET
Initializing PointersAfteranonstaticlocalpointerisdeclaredbutbeforeithasbeenassignedavalue,
itcontainsanunknownvalue.(Globaland
staticlocalpointersareautomatically
initializedtonull.)Shouldyoutrytousethepointerbeforegivingitavalidvalue,

youwillprobablycrashyourprogram—andpossiblyyourcomputer'soperating

systemaswell—averynastytypeoferror!
ThereisanimportantconventionthatmostC/C++programmersfollowwhen
workingwithpointers:Apointerthatdoesnotcurrentlypointtoavalidmemory

locationisgiventhevaluenull(whichiszero).Byconvention,anypointerthatis

nullimpliesthatitpointstonothingandshouldnotbeused.However,justbecause

apointerhasanullvaluedoesnotmakeit"safe."Theuseofnullissimplyaconvention

thatprogrammersfollow.ItisnotaruleenforcedbytheCorC++languages.For

example,ifyouuseanullpointerontheleftsideofanassignmentstatement,youstill

runtheriskofcrashingyourprogramoroperatingsystem.
Because a null pointer is assumed to be unused, you can use the null pointer tomake many of your pointer routines easier to code and more efficient. For example,

you could use a null pointer to mark the end of a pointer array. Aroutine that accesses

that array knows that it has reached the end when it encounters the null value. The

search( )function shown here illustrates this type of approach.
/* look up a name */int search(char *p[], char *name)
{register int t;for(t=0; p[t]; ++t)if(!strcmp(p[t], name)) return t;
return -1; /* not found */}Theforloop insidesearch( )runs until either a match is found or a null pointer
is encountered. Assuming the end of the array is marked with a null, the condition
controlling the loop fails when it is reached.
C/C++programmerscommonlyinitializestrings.Yousawanexampleofthisinthe
syntax_error( )function in the section "Arrays of Pointers." Another variation on theinitialization theme is the following type of string declaration:char *p = "hello world";Asyoucansee,thepointer
pisnotanarray.Thereasonthissortofinitialization
worksisbecauseofthewaythecompileroperates.AllC/C++compilerscreate
whatiscalleda
stringtable
,whichisusedtostorethestringconstantsusedby
theprogram.Therefore,theprecedingdeclarationstatementplacestheaddress
ofhelloworld
,asstoredinthestringtable,intothepointer
p.Throughouta
program,
pcanbeusedlikeanyotherstring(exceptthatitshouldnotbealtered).
Forexample,thefollowingprogramisperfectlyvalid:
#include <stdio.h>#include <string.h>char *p = "hello world";
int main(void){register int t;/* print the string forward and backwards */printf(p);
for(t=strlen(p)-1; t>-1; t--) printf("%c", p[t]);return 0;}In Standard C++, the type of a string literal is technically
const char *. But C++provides an automatic conversion to
char *. Thus, the preceding program is still valid.
However,thisautomaticconversionisadeprecatedfeature,whichmeansthatyou
shouldnotrelyuponitfornewcode.Fornewprograms,youshouldassumethatstring

literals are indeed constants and the declaration of
pin the preceding program should
be written like this.const char *p = "hello world";Pointers to FunctionsAparticularly confusing yet powerful feature of C++ is the
function pointer. Eventhough a function is not a variable, it still has a physical location in memory that
can be assigned to a pointer. This address is the entry point of the function and it is

the address used when the function is called. Once a pointer points to a function, the

function can be called through that pointer. Function pointers also allow functions

to be passed as arguments to other functions.
You obtain the address of a function by using the function's name without any
parentheses or arguments. (This is similar to the way an array's address is obtained
126C++:TheCompleteReference
when only the array name, without indexes, is used.) To see how this is done, study
the following program, paying close attention to the declarations:
#include <stdio.h>#include <string.h>void check(char *a, char *b,int (*cmp)(const char *, const char *));int main(void){char s1[80], s2[80];
int (*p)(const char *, const char *);p = strcmp;
gets(s1);gets(s2);check(s1, s2, p);
return 0;}
void check(char *a, char *b,int (*cmp)(const char *, const char *)){printf("Testing for equality.\n");if(!(*cmp)(a, b)) printf("Equal");
else printf("Not Equal");}When thecheck( )function is called, two character pointers and one function pointerare passed as parameters. Inside the function
check( ), the arguments are declared as
character pointers and a function pointer. Notice how the function pointer is declared.
You must use a similar form when declaring other function pointers, although the

return type and parameters of the function may differ. The parentheses around the

*cmpare necessary for the compiler to interpret this statement correctly.
Insidecheck( ), the expression
(*cmp)(a, b)Chapter5:Pointers
127THEFOUNDATIONOFC++:
THECSUBSET
callsstrcmp( ), which is pointed to bycmp, with the arguments
aandb. Theparentheses around
*cmpare necessary. This is one way to call a function through
a pointer. Asecond, simpler syntax, as shown here, may also be used.
cmp(a, b);The reason that you will frequently see the first style is that it tips off anyone reading
your code that a function is being called through a pointer. (That is, that
cmpis afunction pointer, not the name of a function.) Other than that, the two expressions

are equivalent.
Note that you can callcheck( )by usingstrcmp( )directly, as shown here:
check(s1, s2, strcmp);This eliminates the need for an additional pointer variable.Youmaywonderwhyanyonewouldwriteaprograminthisway.Obviously,
nothingisgainedandsignificantconfusionisintroducedinthepreviousexample.

However,attimesitisadvantageoustopassfunctionsasparametersortocreatean

arrayoffunctions.Forexample,whenacompilerorinterpreteriswritten,theparser

(thepartthatevaluatesexpressions)oftencallsvarioussupportfunctions,suchas

thosethatcomputemathematicaloperations(sine,cosine,tangent,etc.),perform

I/O,oraccesssystemresources.Insteadofhavingalarge
switchstatementwithall
ofthesefunctionslistedinit,anarrayoffunctionpointerscanbecreated.Inthis

approach,theproperfunctionisselectedbyitsindex.Youcangettheflavorofthis

typeofusagebystudyingtheexpandedversionofthepreviousexample.Inthis

program,
check( )canbemadetocheckforeitheralphabeticalequalityornumeric
equalitybysimplycallingitwithadifferentcomparisonfunction.
#include <stdio.h>#include <ctype.h>
#include <stdlib.h>
#include <string.h>void check(char *a, char *b,int (*cmp)(const char *, const char *));int numcmp(const char *a, const char *b);
int main(void){char s1[80], s2[80];128C++:TheCompleteReference
gets(s1);gets(s2);if(isalpha(*s1))check(s1, s2, strcmp);elsecheck(s1, s2, numcmp);return 0;}
void check(char *a, char *b,int (*cmp)(const char *, const char *)){printf("Testing for equality.\n");if(!(*cmp)(a, b)) printf("Equal");
else printf("Not Equal");}int numcmp(const char *a, const char *b){if(atoi(a)==atoi(b)) return 0;
else return 1;}In this program, if you enter a letter,
strcmp( )is passed tocheck( ). Otherwise,numcmp( )is used. Sincecheck( )calls the function that it is passed, it can usedifferent comparison functions in different cases.
C's Dynamic Allocation FunctionsPointersprovidenecessarysupportforC/C++'sdynamicallocationsystem.
Dynamicallocationisthemeansbywhichaprogramcanobtainmemorywhileitisrunning.
Asyouknow,globalvariablesareallocatedstorageatcompiletime.Localvariables
usethestack.However,neitherglobalnorlocalvariablescanbeaddedduringprogram

execution.Yettherewillbetimeswhenthestorageneedsofaprogramcannotbe

knownaheadoftime.Forexample,aprogrammightuseadynamicdatastructure,

suchasalinkedlistorbinarytree.Suchstructuresareinherentlydynamicinnature,

growingorshrinkingasneeded.Toimplementsuchadatastructurerequiresthata

programbeabletoallocateandfreememory.
Chapter5:Pointers
129THEFOUNDATIONOFC++:
THECSUBSET
130C++:TheCompleteReference
C++ actually supports two complete dynamic allocation systems: the one definedbyCandtheonespecifictoC++.ThesystemspecifictoC++containsseveral
improvements
over that used by C, and this approach is discussed in Part Two.
Here, C's dynamic allocation functions are described.
MemoryallocatedbyC'sdynamicallocationfunctionsisobtainedfromthe
heap—theregionoffreememorythatliesbetweenyourprogramanditspermanent

storageareaandthestack.Althoughthesizeoftheheapisunknown,itgenerally

containsafairlylargeamountoffreememory.
The core of C's allocation system consists of the functions
malloc( )andfree( ).(Most compilers supply several other dynamic allocation functions, but these two
are the most important.) These functions work together using the free memory region

to establish and maintain a list of available storage. Themalloc( )function allocatesmemory and thefree( )function releases it. That is, each time a
malloc( )memoryrequest is made, a portion of the remaining free memory is allocated. Each time a

free( )memory release call is made, memory is returned to the system. Any program
that uses these functions should include the header filestdlib.h. (AC++ program may
also use the C++-style header<cstdlib>.)Themalloc( )function has this prototype:
void *malloc(size_tnumber_of_bytes);Here,
number_of_bytesis the number of bytes of memory you wish to allocate. (Thetypesize_tis defined instdlib.has, more or less, an
unsignedinteger.) The
malloc( )function returns a pointer of type
void *, which means that you can assign it to anytype of pointer. After a successful call,
malloc( )returns a pointer to the first byte
of the region of memory allocated from the heap. If there is not enough available

memory to satisfy themalloc( )request, an allocation failure occurs and
malloc( )returns a null.
The code fragment shown here allocates 1,000 bytes of contiguous memory:
char *p;p = malloc(1000); /* get 1000 bytes */After the assignment,ppoints to the start of 1,000 bytes of free memory.
Intheprecedingexample,noticethatnotypecastisusedtoassignthereturn
valueof
malloc( )top.InC,a
void*
pointerisautomaticallyconvertedtothetype
ofthepointerontheleftsideofanassignment.However,itisimportanttounderstand
thatthisautomaticconversion
doesnot
occurinC++.InC++,anexplicittypecastis
neededwhena
void*
pointerisassignedtoanothertypeofpointer.Thus,inC++,the
precedingassignmentmustbewrittenlikethis:
Chapter5:Pointers
131THEFOUNDATIONOFC++:
THECSUBSET
p = (char *) malloc(1000);As a general rule, in C++ you must use a type cast when assigning (or otherwise
converting) one type of pointer to another. This is one of the few fundamental

differences between C and C++.
The next example allocates space for 50 integers. Notice the use ofsizeofto ensure
portability.
int *p;p = (int *) malloc(50*sizeof(int));Since the heap is not infinite, whenever you allocate memory,you must check
the value returned by
malloc( )to make sure that it is not null before using the pointer.
Using a null pointer will almost certainly crash your program. The proper way to
allocate memory and test for a valid pointer is illustrated in this code fragment:p = (int *) malloc(100);if(!p) {printf("Out of memory.\n");
exit(1);}Of course, you can substitute some other sort of error handler in place of the call to
exit( ).Just make sure that you do not use the pointer
pif it is null.Thefree()
functionistheoppositeof
malloc()
inthatitreturnspreviouslyallocated
memorytothesystem.Oncethememoryhasbeenfreed,itmaybereusedbyasubsequent

call tomalloc( ). The functionfree( )has this prototype:
void free(void *p);Here,
pisapointertomemorythatwaspreviouslyallocatedusing
malloc( ).Itis
criticalthatyou
nevercallfree( )withaninvalidargument;otherwise,youwill
destroythefreelist.
Problems with Pointers
Nothing will get you into more trouble than a wild pointer! Pointers are a mixed

blessing. They give you tremendous power and are necessary for many programs.

At the same time, when a pointer accidentally contains a wrong value, it can be the

most difficult bug to find.
Anerroneouspointerisdifficulttofindbecausethepointeritselfisnottheproblem.
The problem is that each time you perform an operation using the bad pointer, you are
reading or writing to some unknown piece of memory. If you read from it, the worst

thatcanhappenisthatyougetgarbage.However,ifyouwritetoit,youmightbe

writing over other pieces of your code or data. This may not show up until later in the
execution of your program, and may lead you to look for the bug in the wrong place.

There may be little or no evidence to suggest that the pointer is the original cause of

the problem. This type of bug causes programmers to lose sleep time and time again.
Because pointer errors are such nightmares, you should do your best never to
generate one. To help you avoid them, a few of the more common errors are discussed

here. The classic example of a pointer error is the
uninitializedpointer
. Consider thisprogram.
/* This program is wrong. */int main(void)
{int x, *p;x = 10;*p = x;return 0;}This program assigns the value 10 to some unknown memory location. Here is why:
Since the pointerphas never been given a value, it contains an unknown value whenthe assignment*p = xtakes place. This causes the value ofxto be written to someunknown memory location. This type of problem often goes unnoticed when your

program is small because the odds are in favor of
pcontaining a "safe" address—one
that is not in your code, data area, or operating system. However, as your program

grows, the probability increases of
ppointing to something vital. Eventually, your
program stops working. The solution is to always make sure that a pointer is pointing

at something valid before it is used.
Asecond common error is caused by a simple misunderstanding of how to use
a pointer. Consider the following:
/* This program is wrong. */#include <stdio.h>int main(void){132C++:TheCompleteReference
Chapter5:Pointers
133THEFOUNDATIONOFC++:
THECSUBSET
int x, *p;x = 10;p = x;printf("%d", *p);
return 0;}The call toprintf( )does not print the value ofx, which is 10, on the screen. It prints
some unknown value because the assignmentp = x;is wrong. That statement assigns the value 10 to the pointer
p. However,
pis supposedto contain an address, not a value. To correct the program, write
p = &x;Another error that sometimes occurs is caused by incorrect assumptions about
the placement of variables in memory. You can never know where your data will be
placed in memory,or if it will be placed there the same way again, or whether each

compiler will treat it in the same way. For these reasons, making any comparisons

between pointers that do not point to a common object may yield unexpected results.

For example,char s[80], y[80];char *p1, *p2;p1 = s;p2 = y;
if(p1 < p2) . . .is generally an invalid concept. (In very unusual situations, you might use somethinglike this to determine the relative position of the variables. But this would be rare.)
Arelated error results when you assume that two adjacent arrays may be indexed
as one by simply incrementing a pointer across the array boundaries. For example,
int first[10], second[10];int *p, t;134C++:TheCompleteReference
p = first;for(t=0; t<20; ++t)  *p++ = t;Thisisnotagoodwaytoinitializethearrays
firstandsecondwiththenumbers0
through19.Eventhoughitmayworkonsomecompilersundercertaincircumstances,
itassumesthatbotharrayswillbeplacedbacktobackinmemorywith
firstfirst.This
maynotalwaysbethecase.
The next program illustrates a very dangerous type of bug. See if you can find it.
/* This program has a bug. */#include <string.h>
#include <stdio.h>int main(void){char *p1;
char s[80];p1 = s;do {gets(s);  /* read a string *//* print the decimal equivalent of eachcharacter */while(*p1) printf(" %d", *p1++);} while(strcmp(s, "done"));
return 0;}This program uses
p1to print the ASCII values associated with the characterscontained ins. The problem is that
p1is assigned the address of
sonly once. Thefirst time through the loop,
p1points to the first character ins. However, the second
time through, it continues where it left off because it is not reset to the start of
s. Thisnext character may be part of the second string, another variable, or a piece of theprogram! The proper way to write this program is
/* This program is now correct. */#include <string.h>#include <stdio.h>int main(void){char *p1;
char s[80];do {p1 = s;gets(s);  /* read a string *//* print the decimal equivalent of eachcharacter */while(*p1) printf(" %d", *p1++);} while(strcmp(s, "done"));
return 0;}Here,eachtimetheloopiterates,
p1issettothestartofthestring.Ingeneral,youshould
remember to reinitialize a pointer if it is to be reused.
The fact that handling pointers incorrectly can cause tricky bugs is no reason to
avoid using them. Just be careful, and make sure that you know where each pointer
is pointing before you use it.
Chapter5:Pointers
135THEFOUNDATIONOFC++:
THECSUBSET
This page intentionally left blank Chapter6
Functions137Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
138C++:TheCompleteReference
Functions are the building blocks of C and C++ and the place where all programactivity occurs. This chapter examines their C-like features, including passing
arguments, returning values, prototypes, and recursion. Part Two discussesthe C++-specific features of functions, such as function overloading and reference
parameters.The General Form of a Function
The general form of a function isret-type function-name(parameter list)
{body of the function}Theret-type
specifiesthetypeofdatathatthefunctionreturns.Afunctionmayreturn
anytypeofdataexceptanarray.The
parameterlist
isacomma-separatedlistofvariable
namesandtheirassociatedtypesthatreceivethevaluesoftheargumentswhenthe

functioniscalled.Afunctionmaybewithoutparameters,inwhichcasetheparameter

listisempty.However,eveniftherearenoparameters,theparenthesesarestillrequired.
In variable declarations, you can declare many variables to be of a common type
by using a comma-separated list of variable names. In contrast, all function parameters
mustbedeclaredindividually,eachincludingboththetypeandname.Thatis,the

parameter declaration list for a function takes this general form:f(type varname1, type varname2, . . . , type varnameN)For example, here are correct and incorrect function parameter declarations:
f(int i, int k, int j) /* correct */f(int i, k, float j)   /* incorrect */Scope Rules of FunctionsThescoperules
of a language are the rules that govern whether a piece of code knows
about or has access to another piece of code or data.Eachfunctionisadiscreteblockofcode.Afunction'scodeisprivatetothatfunction
andcannotbeaccessedbyanystatementinanyotherfunctionexceptthroughacallto
thatfunction.(Forinstance,youcannotuse
gototojumpintothemiddleofanother
function.)Thecodethatconstitutesthebodyofafunctionishiddenfromtherestofthe

programand,unlessitusesglobalvariablesordata,itcanneitheraffectnorbeaffected
byotherpartsoftheprogram.Statedanotherway,thecodeanddatathataredefined
withinonefunctioncannotinteractwiththecodeordatadefinedinanotherfunction

becausethetwofunctionshaveadifferentscope.
Variables that are defined within a function are called
localvariables. Alocal
variable comes into existence when the function is entered and is destroyed upon

exit. That is, local variables cannot hold their value between function calls. The only
exception to this rule is when the variable is declared with the
staticstorage classspecifier. This causes the compiler to treat the variable as if it were a global variable

for storage purposes, but limits its scope to within the function. (Chapter 2 covers
global and local variables in depth.)In C (and C++) you cannot define a function within a function. This is why neitherC nor C++ are technically block-structured languages.
Function Arguments
If a function is to use arguments, it must declare variables that accept the values

of the arguments. These variables are called the
formalparameters
of the function.They behave like other local variables inside the function and are created upon entry

into the function and destroyed upon exit. As shown in the following function, the

parameter declarations occur after the function name:/* Return 1 if c is part of string s; 0 otherwise. */int is_in(char *s,  char c)
{while(*s)if(*s==c) return 1;
else s++;return 0;}The functionis_in( )has two parameters:sandc. This function returns 1 if the
charactercis part of the strings; otherwise, it returns 0.
Aswithlocalvariables,youmaymakeassignmentstoafunction'sformalparameters
or use them in an expression. Even though these variables perform the special task of
receiving the value of the arguments passed to the function, you can use them as you

do any other local variable.Call by Value, Call by Reference
Inacomputerlanguage,therearetwowaysthatargumentscanbepassedtoa

subroutine.Thefirstisknownas
callbyvalue
.Thismethodcopiesthe
valueof
anChapter6:Functions
139THEFOUNDATIONOFC++:
THECSUBSET
argument into the formal parameter of the subroutine. In this case, changes made to
the parameter have no effect on the argument.
Callbyreference
is the second way of passing arguments to a subroutine. In this
method, theaddress
of an argument is copied into the parameter. Inside the subroutine,
theaddressisusedtoaccesstheactualargumentusedinthecall.Thismeansthat

changes made to the parameter affect the argument.
By default, C/C++ uses call by value to pass arguments. In general, this means that
code within a function cannot alter the arguments used to call the function. Consider

the following program:
#include <stdio.h>int sqr(int x);
int main(void){int t=10;printf("%d %d", sqr(t), t);
return 0;}
int sqr(int x){x = x*x;
return(x);}In this example, the value of the argument to
sqr( ), 10, is copied into the parameterx. When the assignmentx = x*xtakes place, only the local variablexis modified. Thevariablet, used to callsqr( ), still has the value 10. Hence, the output is100 10.Rememberthatitisacopyofthevalueoftheargumentthatispassedintothefunction.
What occurs inside the function has no effect on the variable used in the call.
Creating a Call by Reference
EventhoughC/C++usescallbyvalueforpassingparameters,youcancreatea
call by reference by passing a pointer to an argument, instead of the argument itself.

Since the address of the argument is passed to the function, code within the function

can change the value of the argument outside the function.
Pointersarepassedtofunctionsjustlikeanyothervalue.Ofcourse,youneed
todeclaretheparametersaspointertypes.Forexample,thefunction
swap( ),140C++:TheCompleteReference
whichexchangesthevaluesofthetwointegervariablespointedtobyitsarguments,
showshow.
void swap(int *x, int *y){int temp;temp = *x;  /* save the value at address x */*x = *y;    /* put y into x */
*y = temp;  /* put x into y */}swap()
isabletoexchangethevaluesofthetwovariablespointedtoby
xandybecausetheir addresses (not their values) are passed. Thus, within the function, the contents of
the variables can be accessed using standard pointer operations, and the contents of the

variables used to call the function are swapped.
Remember thatswap( )(or any other function that uses pointer parameters) mustbe called with theaddresses of the arguments
. The following fragment shows the correct
way to callswap( ):void swap(int *x, int *y);int main(void){int i, j;i = 10;j = 20;
printf("%d %d", i, j);
swap(&i, &j); /* pass the addresses of i and j */
printf("%d %d", i, j);
return 0;}Inthisexample,thevariable
iisassignedthevalue10and
jisassignedthevalue20.
Thenswap( )is called with the addresses of
iandj. (The unary operator&is used toproducetheaddressofthevariables.)Therefore,theaddressesof
iandj,nottheirvalues,
are passed into the function
swap( ). Afterswap( )returns, the values of
iandjwill beexchanged.C++ allows you to fully automate a call by reference through the use of reference
parameters. This feature is described in Part Two.
Chapter6:Functions
141THEFOUNDATIONOFC++:
THECSUBSET
Calling Functions with ArraysArrays are covered in detail in Chapter 4. However, this section discusses passing
arrays as arguments to functions because it is an exception to the normal call-by-value

parameter passing.When an array is used as a function argument, its address is passed to a function.
This is an exception to the call-by-value parameter passing convention. In this case, the
code inside the function is operating on, and potentially altering, the actual contents of
the array used to call the function. For example, consider the functionprint_upper( ),which prints its string argument in uppercase:
#include <stdio.h>#include <ctype.h>void print_upper(char *string);
int main(void){char s[80];gets(s);print_upper(s);
printf("\ns is now uppercase: %s", s);
return 0;}/* Print a string in uppercase. */void print_upper(char *string)
{register int t;for(t=0; string[t]; ++t)  {string[t] = toupper(string[t]);putchar(string[t]);}}Afterthecallto
print_upper()
,thecontentsofarray
sinmain()
havealsobeenchanged
touppercase.Ifthisisnotwhatyouwant,youcouldwritetheprogramlikethis:
#include <stdio.h>
#include <ctype.h>142C++:TheCompleteReference
Chapter6:Functions
143THEFOUNDATIONOFC++:
THECSUBSET
void print_upper(char *string);int main(void){char s[80];gets(s);print_upper(s);
printf("\ns is unchanged: %s", s);return 0;}
void print_upper(char *string){register int t;for(t=0; string[t]; ++t)putchar(toupper(string[t]));}In this version, the contents of arraysremain unchanged because its values are not
altered inside
print_upper( ).The standard library function
gets( )is a classic example of passing arrays intofunctions. Although thegets( )in your standard library is more sophisticated, the
following simpler version, calledxgets( ), will give you an idea of how it works./* A simple version of the standardgets() library function. */char *xgets(char *s){char ch, *p;
int t;p = s;  /* gets() returns a pointer to s */
for(t=0; t<80; ++t){ch = getchar();
switch(ch) {144C++:TheCompleteReference
case '\n':s[t] = '\0'; /* terminate the string */return p;case '\b':if(t>0) t--;break;default:s[t] = ch;}}
s[79] = '\0';
return p;}Thexgets( )function must be called with a character pointer. This, of course, can
be the name of a character array, which by definition is a character pointer. Upon entry,
xgets()
establishesa
forloopfrom0to79.Thispreventslargerstringsfrombeing
entered at the keyboard. If more than 80 characters are entered, the function returns.

(The real
gets( )function does not have this restriction.) Because C/C++ has no built-in
bounds checking, you should make sure that any array used to call
xgets( )can acceptatleast80characters.Asyoutypecharactersonthekeyboard,theyareplacedinthestring.

Ifyoutypeabackspace,thecounter
tisreducedby1,effectivelyremovingtheprevious
characterfromthearray.Whenyoupress
ENTER,anullisplacedattheendofthestring,
signalingitstermination.Becausetheactualarrayusedtocall
xgets()
ismodified,upon
return it contains the characters that you type.
argc and argv—Arguments to main( )
Sometimesitisusefultopassinformationintoaprogramwhenyourunit.Generally,you

pass information into themain( )function via command line arguments. A
commandlineargument
is the information that follows the program's name on the command line
of the operating system. For example, when you compile a program, you might type

something like the following after the command prompt:
ccprogram_namewhere
program
_nameis a command line argument that specifies the name of the
program you wish to compile.
There are two special built-in arguments,
argvandargc, that are used to receive
command line arguments. The
argcparameter holds the number of arguments on
the command line and is an integer. It is always at least 1 because the name of the

program qualifies as the first argument. The
argvparameter is a pointer to an arrayChapter6:Functions
145THEFOUNDATIONOFC++:
THECSUBSET
of character pointers. Each element in this array points to a command line argument.
All command line arguments are strings—any numbers will have to be converted by

the program into the proper internal format. For example, this simple program prints

Helloand your name on the screen if you type it directly after the program name.
#include <stdio.h>#include <stdlib.h>int main(int argc, char *argv[]){if(argc!=2) {printf("You forgot to type your name.\n");
exit(1);}
printf("Hello %s", argv[1]);return 0;}If you called this program
nameand your name were Tom, you would type
nameTom
to run the program. The output from the program would be
HelloTom
.In many environments, each command line argument must be separated by a space
or a tab. Commas, semicolons, and the like are not considered separators. For example,
run Spot, runis made up of three strings, while
Herb,Rick,Fredis a single string since commas are not generally legal separators.
Some environments allow you to enclose within double quotes a string containing
spaces.Thiscausestheentirestringtobetreatedasasingleargument.Checkyour
operatingsystemdocumentationfordetailsonthedefinitionofcommandlineparameters

for your system.You must declare
argvproperly. The most common method is
char *argv[];The empty brackets indicate that the array is of undetermined length. You can now

access the individual arguments by indexing
argv. For example,argv[0]points to the146C++:TheCompleteReference
first string, which is always the program's name;
argv[1]points to the first argument,
and so on.Another short example using command line arguments is the program called
countdown,shownhere.Itcountsdownfromastartingvalue(whichisspecified
onthecommandline)andbeepswhenitreaches0.Noticethatthefirstargument

containing the number is converted into an integer by the standard function
atoi( ).Ifthe string "display" is the second command line argument, the countdown will also be

displayed on the screen.
/* Countdown program. */#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>int main(int argc, char *argv[]){int disp, count;if(argc<2) {printf("You must enter the length of the count\n");printf("on the command line.  Try again.\n");
exit(1);}if(argc==3 && !strcmp(argv[2], "display")) disp = 1;else disp = 0;for(count=atoi(argv[1]); count; --count)if(disp) printf("%d\n", count);putchar('\a');  /* this will ring the bell */printf("Done");return 0;}Notice that if no command line arguments have been specified, an error message is
printed.Aprogramwithcommandlineargumentsoftenissuesinstructionsifthe

user attempts to run the program without entering the proper information.
To access an individual character in one of the command line arguments, add a
second index toargv. For example, the next program displays all of the arguments
with which it was called, one character at a time:Chapter6:Functions
147THEFOUNDATIONOFC++:
THECSUBSET
#include <stdio.h>int main(int argc, char *argv[]){int t, i;for(t=0; t<argc; ++t) {i = 0;
while(argv[t][i]) {putchar(argv[t][i]);++i;}
printf("\n");}return 0;}Remember, the first index accesses the string, and the second index accesses the
individual characters of the string.Normally, you use
argcandargvto get initial commands into your program. In
theory, you can have up to 32,767 arguments, but most operating systems do not allow

more than a few. You typically use these arguments to indicate a filename or an option.

Using command line arguments gives your program a professional appearance and

facilitates its use in batch files.Whenaprogramdoesnotrequirecommandlineparameters,itiscommon
practicetoexplicitlydeclare
main( )ashavingnoparameters.ForCprogramsthisis
accomplishedbyusingthe
voidkeywordinitsparameterlist.(Thisistheapproach
usedbytheprogramsinPartOneofthisbook.)However,forC++programsyoumay

simplyspecifyanemptyparameterlist.InC++,theuseof
voidtoindicateanempty
parameterlistisallowed,butredundant.
Thenames
argcandargvaretraditionalbutarbitrary.Youmaynamethesetwo
parameters tomain( )anything you like. Also, some compilers may support additionalarguments to
main( ), so be sure to check your user's manual.
The return Statement
ThereturnstatementitselfisdescribedinChapter3.Asexplained,ithastwoimportant
uses.First,itcausesanimmediateexitfromthefunctionthatitisin.Thatis,itcauses

programexecutiontoreturntothecallingcode.Second,itmaybeusedtoreturnavalue.

Thissectionexamineshowthe
returnstatementisused.
148C++:TheCompleteReference
Returning from a Function
There are two ways that a function terminates execution and returns to the caller. The
firstoccurswhenthelaststatementinthefunctionhasexecutedand,conceptually,

thefunction'sendingcurlybrace(
})isencountered.(Ofcourse,thecurlybraceisn't
actually present in the object code, but you can think of it in this way.) For example, the

pr_reverse( )function in this program simply prints the string "I like C++" backwards
on the screen and then returns.
#include <string.h>#include <stdio.h>void pr_reverse(char *s);
int main(void){pr_reverse("I like C++");return 0;}
void pr_reverse(char *s){register int t;for(t=strlen(s)-1; t>=0; t--) putchar(s[t]);}Once the string has been displayed, there is nothing left for
pr_reverse( )to do, so itreturns to the place from which it was called.
Actually,notmanyfunctionsusethisdefaultmethodofterminatingtheirexecution.
Mostfunctionsrelyonthe
returnstatementtostopexecutioneitherbecauseavalue
mustbereturnedortomakeafunction'scodesimplerandmoreefficient.
Afunction may contain several
returnstatements. For example, thefind_substr( )function in the following program returns the starting position of a substring within
a string, or returns
−1 if no match is found.#include <stdio.h>int find_substr(char *s1, char *s2);
int main(void){THEFOUNDATIONOFC++:
THECSUBSET
if(find_substr("C++ is fun", "is") != -1)printf("substring is found");return 0;}/* Return index of first match of s2 in s1. */int find_substr(char *s1, char *s2)
{register int t;
char *p, *p2;for(t=0; s1[t]; t++) {p = &s1[t];p2 = s2;while(*p2 && *p2==*p) {p++;p2++;}
if(!*p2) return t; /* 1st return */}return -1; /* 2nd return */}Returning Values
All functions, except those of typevoid, return a value. This value is specified by the
returnstatement. In C89, if a non-voidfunction does not explicitly return a value via
areturnstatement, then a garbage value is returned. In C++ (and C99), a non-
voidfunctionmustcontaina
returnstatementthatreturnsavalue.Thatis,inC++,ifafunction
isspecifiedasreturningavalue,any
returnstatementwithinitmusthaveavalue
associated with it. However, if execution reaches the end of a non-
voidfunction, thena garbage value is returned. Although this condition is not a syntax error, it is still a
fundamental flaw and should be avoided.As long as a function is not declared as
void, you may use it as an operand in anexpression. Therefore, each of the following expressions is valid:
x = power(y);if(max(x,y) > 100) printf("greater");
for(ch=getchar(); isdigit(ch); ) ... ;Chapter6:Functions
149150C++:TheCompleteReference
As a general rule, a function cannot be the target of an assignment. Astatement
such asswap(x,y) = 100; /* incorrect statement */is wrong. The C/C++ compiler will flag it as an error and will not compile a program
that contains it. (As is discussed in Part Two, C++ allows some interesting exceptions

to this general rule, enabling some types of functions to occur on the left side of an

assignment.)When you write programs, your functions generally will be of three types. The
firsttypeissimplycomputational.Thesefunctionsarespecificallydesignedto

perform operations on their arguments and return a value based on that operation.

Acomputationalfunctionisa"pure"function.Examplesarethestandardlibrary

functionssqrt()
andsin()
,whichcomputethesquarerootandsineoftheirarguments.
The second type of function manipulates information and returns a value that
simply indicates the success or failure of that manipulation. An example is the library

functionfclose()
,whichisusedtocloseafile.Ifthecloseoperationissuccessful,
the function returns 0; if the operation is unsuccessful, it returns
EOF.The last type of function has no explicit return value. In essence, the function is
strictly procedural and produces no value. An example is
exit( ), which terminates aprogram. All functions that do not return values should be declared as returning type

void. By declaring a function asvoid, you keep it from being used in an expression,
thus preventing accidental misuse.
Sometimes,functionsthatreallydon'tproduceaninterestingresultreturnsomething
anyway. For example,
printf( )returns the number of characters written. Yet it would
be unusual to find a program that actually checked this. In other words, although all

functions, except those of typevoid, return values, you don't have to use the return
value for anything. Acommon question concerning function return values is, "Don't I

have to assign this value to some variable since a value is being returned?" The answer

is no. If there is no assignment specified, the return value is simply discarded. Consider

the following program, which uses the function
mul( ):#include <stdio.h>int mul(int a, int b);
int main(void){int x, y, z;x = 10;   y = 20;z = mul(x, y);           /* 1 */printf("%d", mul(x,y));  /* 2 */
mul(x, y);               /* 3 */return 0;}
int mul(int a, int b){return a*b;}In line 1, the return value of
mul( )is assigned toz. In line 2, the return value is not
actually assigned, but it is used by theprintf( )function. Finally, in line 3, the return
value is lost because it is neither assigned to another variable nor used as part of anexpression.
Returning PointersAlthough functions that return pointers are handled just like any other type of

function, a few important concepts need to be discussed.Pointerstovariablesareneitherintegersnorunsignedintegers.Theyarethememory
addresses of a certain type of data. The reason for this distinction is because pointer

arithmetic is relative to the base type. For example, if an integer pointer is incremented,

itwillcontainavaluethatis4greaterthanitspreviousvalue(assuming4-byteintegers).

In general, each time a pointer is incremented (or decremented), it points to the next (or

previous)itemofitstype.Sincethelengthofdifferentdatatypesmaydiffer,thecompiler

must know what type of data the pointer is pointing to. For this reason, a function that

returnsapointermustdeclareexplicitlywhattypeofpointeritisreturning.Forexample,

you should not use a return type of
int *to return a
char *pointer!To return a pointer, a function must be declared as having a pointer return type.
For example, this function returns a pointer to the first occurrence of the character
cin strings:/* Return pointer of first occurrence of c in s. */char *match(char c, char *s)
{while(c!=*s && *s) s++;
return(s);}Chapter6:Functions
151THEFOUNDATIONOFC++:
THECSUBSET
152C++:TheCompleteReference
If no match is found, a pointer to the null terminator is returned. Here is a short
program that uses
match( ):#include <stdio.h>char *match(char c, char *s);  /* prototype */
int main(void){char s[80], *p, ch;gets(s);ch = getchar();
p = match(ch, s);if(*p)  /* there is a match */printf("%s ", p);elseprintf("No match found.");return 0;}Thisprogramreadsastringandthenacharacter.Ifthecharacterisinthestring,the
programprintsthestringfromthepointofmatch.Otherwise,itprints
Nomatchfound
.Functions of Type void
Oneof
void'susesistoexplicitlydeclarefunctionsthatdonotreturnvalues.This
prevents their use in any expression and helps avert accidental misuse. For example,

the functionprint_vertical( )prints its string argument vertically down the side of the
screen. Since it returns no value, it is declared as
void.void print_vertical(char *str){while(*str)printf("%c\n", *str++);}Here is an example that uses
print_vertical( ).#include <stdio.h>Chapter6:Functions
153THEFOUNDATIONOFC++:
THECSUBSET
void print_vertical(char *str);  /* prototype */int main(int argc, char *argv[]){if(argc > 1) print_vertical(argv[1]);return 0;}
void print_vertical(char *str){while(*str)printf("%c\n", *str++);}One last point: Early versions of C did not define thevoidkeyword. Thus, in
early C programs, functions that did not return values simply defaulted to type
int.Therefore, don't be surprised to see many examples of this in older code.
What Does main( ) Return?Themain( )function returns an integer to the calling process, which is generally the
operating system. Returning a value from
main( )is the equivalent of callingexit( )with the same value. Ifmain( )does not explicitly return a value, the value passed
to the calling process is technically undefined. In practice, most C/C++ compilers
automatically return 0, but do not rely on this if portability is a concern.
RecursionIn C/C++, a function can call itself. Afunction is said to be
recursive
if a statement inthebodyofthefunctioncallsitself.Recursionistheprocessofdefiningsomething

in terms of itself, and is sometimes calledcircular definition
.Asimple example of a recursive function is
factr( ), which computes the factorialofaninteger.Thefactorialofanumber
nistheproductofallthewholenumbers
between 1 andn. For example, 3 factorial is 1 x 2 x 3, or 6. Bothfactr( )and its iterativeequivalent are shown here:
/* recursive */int factr(int n) {int answer;if(n==1) return(1);154C++:TheCompleteReference
answer = factr(n-1)*n; /* recursive call */return(answer);}/* non-recursive */int fact(int n) {int t, answer;answer = 1;
for(t=1; t<=n; t++)answer=answer*(t);return(answer);}The nonrecursive version of
fact( )should be clear. It uses a loop that runs from 1 to
nand progressively multiplies each number by the moving product.
The operation of the recursive
factr( )is a little more complex. When
factr( )iscalled with an argument of 1, the function returns 1. Otherwise, it returns the product
offactr(n−1)*n. To evaluate this expression,
factr( )is called withn−1. This happensuntilnequals 1 and the calls to the function begin returning.
Computing the factorial of 2, the first call tofactr( )causes a second, recursive call
with the argument of 1. This call returns 1, which is then multiplied by 2 (the original

nvalue). The answer is then 2. Try working through the computation of 3 factorial on
your own. (You might want to insert
printf( )statements intofactr( )to see the level ofeach call and what the intermediate answers are.)
Whenafunctioncallsitself,anewsetoflocalvariablesandparametersareallocated
storage on the stack, and the function code is executed from the top with these new

variables. Arecursive call does not make a new copy of the function. Only the values

beingoperateduponarenew.Aseachrecursivecallreturns,theoldlocalvariables

and parameters are removed from the stack and execution resumes at the point of the

function call inside the function. Recursive functions could be said to "telescope" out
and back.Often, recursive routines do not significantly reduce code size or improve memory
utilizationovertheiriterativecounterparts.Also,therecursiveversionsofmostroutines

may execute a bit slower than their iterative equivalents because of the overhead of the

repeated function calls. In fact, many recursive calls to a function could cause a stack

overrun. Because storage for function parameters and local variables is on the stack

and each new call creates a new copy of these variables, the stack could be exhausted.

However, you probably will not have to worry about this unless a recursive function

runs wild.
Chapter6:Functions
155THEFOUNDATIONOFC++:
THECSUBSET
The main advantage to recursive functions is that you can use them to create clearer
andsimplerversionsofseveralalgorithms.Forexample,theQuicksortalgorithmis
difficult to implement in an iterative way. Also, some problems, especially ones related

to artificial intelligence, lend themselves to recursive solutions. Finally, some people

seem to think recursively more easily than iteratively.
Whenwritingrecursivefunctions,youmusthaveaconditionalstatement,such
asan
if,somewheretoforcethefunctiontoreturnwithouttherecursivecallbeing
executed.Ifyoudon't,thefunctionwillneverreturnonceyoucallit.Omittingthe

conditionalstatementisacommonerrorwhenwritingrecursivefunctions.Use
printf()
liberallyduringprogramdevelopmentsothatyoucanwatchwhatisgoingonand

abortexecutionifyouseeamistake.
Function Prototypes
InC++allfunctionsmustbedeclaredbeforetheyareused.Thisisnormallyaccomplished

using afunctionprototype
. Function prototypes were not part of the original C language.
Theywere,however,addedwhenCwasstandardized.Whileprototypesarenot

technically required by Standard C, their use is strongly encouraged. Prototypes have

alwaysbeen
required
byC++.Inthisbook,allexamplesincludefullfunctionprototypes.
Prototypes enable both C and C++ to provide stronger type checking, somewhat like

that provided by languages such as Pascal. When you use prototypes, the compiler can

find and report any illegal type conversions between the type of arguments used to call

afunctionandthetypedefinitionofitsparameters.Thecompilerwillalsocatchdifferences

betweenthenumberofargumentsusedtocallafunctionandthenumberofparameters

in the function.The general form of a function prototype is
type func_name(type parm_name1, type parm_name2,. . .,type parm_nameN);The use of parameter names is optional. However, they enable the compiler to identify
anytypemismatchesbynamewhenanerroroccurs,soitisagoodideatoincludethem.
The following program illustrates the value of function prototypes. It produces an
error message because it contains an attempt to call
sqr_it( )with an integer argument
instead of the integer pointer required. (It is illegal to convert an integer into a pointer.)
/* This program uses a function prototype toenforce strong type checking. */void sqr_it(int *i); /* prototype */int main(void){156C++:TheCompleteReference
int x;x = 10;sqr_it(x);  /* type mismatch */return 0;}
void sqr_it(int *i){*i = *i * *i;}Afunction's definition can also serve as its prototype if the definition occurs prior
to the function's first use in the program. For example, this is a valid program.
#include <stdio.h>/* This definition will also serveas a prototype within this program. */void f(int a, int b){printf("%d ", a % b);}int main(void){f(10,3);return 0;}Inthisexample,since
f()
isdefinedpriortoitsusein
main(),
noseparateprototype
is required. While it is possible for a function's definition to serve as its prototype in
small programs, it is seldom possible in large ones
especially when several files are

used. The programs in this book include a separate prototype for each function because

that is the way C/C++ code is normally written in practice.The only function that does not require a prototype is
main( ),since it is the firstfunction called when your program begins.
BecauseoftheneedforcompatibilitywiththeoriginalversionofC,thereisa
small but important difference between how C and C++ handle the prototyping of
a function that has no parameters. In C++, an empty parameter list is simply indicatedin the prototype by the absence of any parameters. For example,
int f(); /* C++ prototype for a function with no parameters */However,inCthisprototypemeanssomethingdifferent.Forhistoricalreasons,
an empty parameter list simply says thatno parameter informationis given. As far as thecompiler is concerned, the function could have several parameters or no parameters. In
C, when a function has no parameters, its prototype uses
voidinside the parameter list.For example, here is
f( )'s prototype as it would appear in a C program.
float f(void);This tells the compiler that the function has no parameters, and any call to that function
that has parameters is an error. In C++, the use of
voidinside an empty parameter listis still allowed, but is redundant.
In C++,f( )andf(void)are equivalent.
Function prototypes help you trap bugs before they occur. In addition, they help
verify that your program is working correctly by not allowing functions to be called

with mismatched arguments.
One last point: Since early versions of C did not support the full prototype syntax,
prototypesaretechnicallyoptionalinC.Thisisnecessarytosupportpre-prototype

Ccode.IfyouareportingolderCcodetoC++,youmayneedtoaddfullfunction

prototypes before it will compile. Remember: Although prototypes are optional in C,

they are required by C++. This means that every function in a C++ program must be

fully prototyped.
Standard Library Function Prototypes
Anystandardlibraryfunctionusedbyyourprogrammustbeprototyped.Toaccomplish

this,youmustincludetheappropriate
headerforeachlibraryfunction.Allnecessary
headersareprovidedbytheC/C++compiler.InC,thelibraryheadersare(usually)

files that use the .H extension. In C++, headers may be either separate files or built into
the compiler itself. In either case, a header contains two main elements: any definitions
used by the library functions and the prototypes for the library functions. For example,

stdio.hisincludedinalmostallprogramsinthispartofthebookbecauseitcontainsthe
prototype for
printf( ). The headers for the standard library are described in Part Three.
Chapter6:Functions
157THEFOUNDATIONOFC++:
THECSUBSET
158C++:TheCompleteReference
Declaring Variable-Length Parameter Lists
Youcanspecifyafunctionthathasavariablenumberofparameters.Themostcommon
exampleis
printf( ).Totellthecompilerthatanunknownnumberofargumentsmay
bepassedtoafunction,youmustendthedeclarationofitsparametersusingthree

periods.Forexample,thisprototypespecifiesthat
func( )willhaveatleasttwointeger
parametersandanunknownnumber(including0)ofparametersafterthat.
int func(int a, int b, ...);This form of declaration is also used by a function's definition.Any function that uses a variable number of parameters must have at least oneactual parameter. For example, this is incorrect:
int func(...); /* illegal */Old-Style Versus Modern
Function Parameter DeclarationsEarly versions of C used a different parameter declaration method than does either
Standard C or Standard C++. This early approach is sometimes called the
classicform.This book uses a declaration approach called the
modernform. Standard C supports
both forms, but strongly recommends the modern form. Standard C++ only supports

the modern parameter declaration method. However, you should know the old-style

form because many older C programs still use it.
Theold-stylefunctionparameterdeclarationconsistsoftwoparts:aparameter
list,whichgoesinsidetheparenthesesthatfollowthefunctionname,andtheactual

parameterdeclarations,whichgobetweentheclosingparenthesesandthefunction's

openingcurlybrace.Thegeneralformoftheold-styleparameterdefinitionis
type func_name(parm1, parm2, . . .parmN)type parm1;
type parm2;.
.
.type parmN;
{function code}For example, this modern declaration:float f(int a, int b, char ch){/* ... */}will look like this in its old-style form:float f(a, b, ch)
int a, b;
char ch;
{/* ... */}Notice that the old-style form allows the declaration of more than one parameter in
a list after the type name.The old-style form of parameter declaration is designated as obsolete by the C language
and is not supported by C++.Chapter6:Functions
159THEFOUNDATIONOFC++:
THECSUBSET
This page intentionally left blank Chapter7
Structures, Unions,Enumerations, and
User-Defined Types
161Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
The C language gives you five ways to create a custom data type:1.The
structure
, which is a grouping of variables under one name and is called an
aggregate
datatype.(Theterms
compoundorconglomeratearealsocommonlyused.)
2.The
bit-field, which is a variation on the structure and allows easy access to
individual bits.3.The
union, which enables the same piece of memory to be defined as two ormore different types of variables.
4.The
enumeration, which is a list of named integer constants.5.The
typedefkeyword, which defines a new name for an existing type.
C++ supports all of the above and adds classes, which are described in Part Two.
The other methods of creating custom data types are described here.
In C++, structures and unions have both object-oriented and non-object-oriented
attributes. This chapter discusses only their C-like, non-object-oriented features.

Their object-oriented qualities are described later in this book.
Structures
Astructureisacollectionofvariablesreferencedunderonename,providinga

convenientmeansofkeepingrelatedinformationtogether.A
structuredeclaration
forms a template that may be used to create structure objects (that is, instances of

a structure). The variables that make up the structure are called
members. (Structure
members are also commonly referred to as
elementsorfields.)Generally,all of the members of a structure are logically related. For example, the
name and address information in a mailing list would normally be represented in a

structure. The following code fragment shows how to declare a structure that defines

the name and address fields. The keyword
structtells the compiler that a structure is
being declared.
struct addr{char name[30];
char street[40];
char city[20];
char state[3];
unsigned long int zip;};162C++:TheCompleteReference
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
163THEFOUNDATIONOFC++:
THECSUBSET
Notice that the declaration is terminated by a semicolon. This is because a structure
declaration is a statement. The type name of the structure is
addr. As such,addridentifies this particular data structure and is its type specifier.
At this point,no variable has actually been created
. Only the form of the data has beendefined. When you define a structure, you are defining a compound variable type, not

a variable. Not until you declare a variable of that type does one actually exist. In C, to

declare a variable (i.e., a physical object) of type
addr, writestruct addr addr_info;Thisdeclaresavariableoftype
addrcalledaddr_info.InC++,youmayusethis
shorter form.addr addr_info;As you can see, the keyword
structis not needed. In C++, once a structure has been
declared,youmaydeclarevariablesofitstypeusingonlyitstypename,withoutpreceding

it with the keyword
struct.The reason for this difference is that in C, a structure's name
does not define a complete type name. In fact, Standard C refers to a structure's name

asa
tag.InC,youmustprecedethetagwiththekeyword
structwhendeclaringvariables.
However, in C++, a structure's name is a complete type name and may be used by itself

todefinevariables.Keepinmind,however,thatitisstillperfectlylegaltousetheC-style

declaration in a C++ program. Since the programs in Part One of this book are valid for

bothCandC++,theywillusetheCdeclarationmethod.JustrememberthatC++allows

the shorter form.Whenastructurevariable(suchas
addr_info)isdeclared,thecompilerautomatically
allocates sufficient memory to accommodate all of its members. Figure 7-1 shows how

addr_infoappears in memory assuming 1-byte characters and 4-byte long integers.You may also declare one or more structure variables when you declare a structure.
For example,struct addr {char name[30];char street[40];
char city[20];
char state[3];
unsigned long int zip;} addr_info, binfo, cinfo;defines a structure type called
addrand declares variables
addr_info,binfo, andcinfoof that type. It is important to understand that each structure object contains its own
164C++:TheCompleteReference
copies of the structure’s members. For example, the
zipfield ofbinfois separate from
thezipfield ofcinfo. Thus, changes tozipinbinfodo not affect the
zipincinfo.If you only need one structure variable, the structure type name is not needed.
That means thatstruct {char name[30];char street[40];
char city[20];
char state[3];
unsigned long int zip;} addr_info;declares one variable named
addr_infoas defined by the structure preceding it.
The general form of a structure declaration is
structstruct-type-name{type member-name;type member-name;
type member-name;
.
.Figure7-1.
Theaddr_infostructure in memory
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
165THEFOUNDATIONOFC++:
THECSUBSET
.}structure-variables;where either
struct-type-nameorstructure-variables
may be omitted, but not both.Accessing Structure Members
Individual members of a structure are accessed through the use of the
.operator(usually called thedot operator). For example, the following code assigns the ZIPcode 12345 to thezipfield of the structure variable
addr_infodeclared earlier:
addr_info.zip = 12345;The structure variable name followed by a period and the member name references
that individual member. The general form for accessing a member of a structure is
structure-name.member-nameTherefore, to print the ZIPcode on the screen, write
printf("%lu", addr_info.zip);ThisprintstheZIPcodecontainedinthe
zipmemberofthestructurevariable
addr_info.In the same fashion, the character arrayaddr_info.namecan be used to callgets( ),as shown here:
gets(addr_info.name);This passes a character pointer to the start ofname.Sincenameis a character array, you can access the individual characters of
addr_info.nameby indexingname. For example, you can print the contentsofaddr_info.nameone character at a time by using the following code:register int t;for(t=0; addr_info.name[t]; ++t)putchar(addr_info.name[t]);Structure Assignments
The information contained in one structure may be assigned to another structure of the
same type using a single assignment statement. That is, you do not need to assign the166C++:TheCompleteReference
value of each member separately. The following program illustrates structure
assignments:#include <stdio.h>int main(void){struct {int a;
int b;} x, y;x.a = 10;
y = x;  /* assign one structure to another */
printf("%d", y.a);
return 0;}After the assignment,y.a
will contain the value 10.Arrays of Structures
Perhaps the most common usage of structures is in arrays of structures. To declare
an array of structures, you must first define a structure and then declare an array

variable of that type. For example, to declare a 100-element array of structures of

typeaddr, defined earlier, write
struct addr addr_info[100];This creates 100 sets of variables that are organized as defined in the structure
addr.To access a specific structure, index the structure name. For example, to print the
ZIPcode of structure 3, write
printf("%lu", addr_info[2].zip);Like all array variables, arrays of structures begin indexing at 0.
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
167THEFOUNDATIONOFC++:
THECSUBSET
Passing Structures to Functions
This section discusses passing structures and their members to functions.
Passing Structure Members to Functions
Whenyoupassamemberofastructuretoafunction,youareactuallypassingthe
valueofthatmembertothefunction.Therefore,youarepassingasimplevariable

(unless,ofcourse,thatelementiscompound,suchasanarray).Forexample,

considerthisstructure:
struct fred{char x;
int y;
float z;
char s[10];} mike;Here are examples of each member being passed to a function:
func(mike.x);    /* passes character value of x */
func2(mike.y);   /* passes integer value of y */
func3(mike.z);   /* passes float value of z */
func4(mike.s);   /* passes address of string s */
func(mike.s[2]); /* passes character value of s[2] */If you wish to pass theaddress
of an individual structure member, put the
&operatorbefore the structure name. For example, to pass the address of the members of the
structure
mike, writefunc(&mike.x);    /* passes address of character x */func2(&mike.y);   /* passes address of integer y */
func3(&mike.z);   /* passes address of float z */
func4(mike.s);    /* passes address of string s */
func(&mike.s[2]); /* passes address of character s[2] */Note that the&operator precedes the structure name, not the individual member
name. Note also thatsalready signifies an address, so no
&is required.
168C++:TheCompleteReference
Passing Entire Structures to Functions
When a structure is used as an argument to a function, the entire structure is passed
usingthestandardcall-by-valuemethod.Ofcourse,thismeansthatanychanges

madeto the contents of the structure inside 
the function to which it is passed do notaffect the structure used as an argument.
When using a structure as a parameter, remember that the type of the argument
must match the type of the parameter. For example, in the following program both the

argument
argand the parameterparmare declared as the same type of structure.
#include <stdio.h>/* Define a structure type. */struct struct_type {int a, b;
char ch;} ;void f1(struct struct_type parm);
int main(void){struct struct_type arg;arg.a = 1000;
f1(arg);
return 0;}
void f1(struct struct_type parm){printf("%d", parm.a);}Asthisprogramillustrates,ifyouwillbedeclaringparametersthatarestructures,
youmustmakethedeclarationofthestructuretypeglobalsothatallpartsofyour

programcanuseit.Forexample,had
struct_typebeendeclaredinside
main()
(forexample),thenitwouldnothavebeenvisibleto
f1().
As just stated, when passing structures, the type of the argument must match
the type of the parameter. It is not sufficient for them to simply be physically similar;

their type names must match. For example, the following version of the preceding
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
169THEFOUNDATIONOFC++:
THECSUBSET
program is incorrect and will not compile because the type name of the argument
used to callf1( )differs from the type name of its parameter.
/* This program is incorrect and will not compile. */#include <stdio.h>/* Define a structure type. */struct struct_type {int a, b;
char ch;} ;/* Define a structure similar to struct_type,but with a different name. */struct struct_type2 {int a, b;char ch;} ;void f1(struct struct_type2 parm);
int main(void){struct struct_type arg;arg.a = 1000;
f1(arg); /* type mismatch */
return 0;}
void f1(struct struct_type2 parm){printf("%d", parm.a);}Structure Pointers
C/C++ allows pointers to structures just as it allows pointers to any other type
of variable. However, there are some special aspects to structure pointers that

you should know.
170C++:TheCompleteReference
Declaring a Structure Pointer
Like other pointers, structure pointers are declared by placing
*in front of a structure
variable's name. For example, assuming the previously defined structure
addr, thefollowing declares
addr_pointeras a pointer to data of that type:struct addr *addr_pointer;Remember, in C++ it is not necessary to precede this declaration with the keyword
struct.Using Structure Pointers
Therearetwoprimaryusesforstructurepointers:topassastructuretoafunctionusing

call by reference, and to create linked lists and other dynamic data structures that rely

on dynamic allocation. This chapter covers the first use.Thereisonemajordrawbacktopassingallbutthesimpleststructurestofunctions:
theoverheadneededtopushthestructureontothestackwhenthefunctioncallis

executed.(Recallthatargumentsarepassedtofunctionsonthestack.)Forsimple

structureswithfewmembers,thisoverheadisnottoogreat.Ifthestructurecontains

manymembers,however,orifsomeofitsmembersarearrays,run-timeperformance

maydegradetounacceptablelevels.Thesolutiontothisproblemistopassonlya

pointertothestructure.
Whenapointertoastructureispassedtoafunction,onlytheaddressofthe
structureispushedonthestack.Thismakesforveryfastfunctioncalls.Asecond

advantage,insomecases,iswhenafunctionneedstoreferencetheactualstructure

usedastheargument,insteadofacopy.Bypassingapointer,thefunctioncan

modify the contents of the structure used in the call.
Tofindtheaddressofastructure,placethe
&operatorbeforethe
structure'sname.
For example, given the following fragment:struct bal {float balance;char name[80];} person;struct bal *p;  /* declare a structure pointer */thenp = &person;places the address of the structure
personinto the pointerp.To access the members of a structure using a pointer to that structure, you must
use the>operator. For example, this references the
balancefield:p->balanceThe>is usually called thearrowoperator
, and consists of the minus sign followedby a greater-than sign. The arrow is used in place of the dot operator when you are
accessing a structure member through a pointer to the structure.
To see how a structure pointer can be used, examine this simple program, which
prints the hours, minutes, and seconds on your screen using a software timer.
/* Display a software timer. */#include <stdio.h>#define DELAY 128000
struct my_time {int hours;int minutes;
int seconds;} ;void display(struct my_time *t);void update(struct my_time *t);
void delay(void);int main(void){struct my_time systime;systime.hours = 0;systime.minutes = 0;
systime.seconds = 0;for(;;) {update(&systime);display(&systime);}return 0;}Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
171THEFOUNDATIONOFC++:
THECSUBSET
void update(struct my_time *t){t->seconds++;if(t->seconds==60) {t->seconds = 0;
t->minutes++;}if(t->minutes==60) {t->minutes = 0;t->hours++;}if(t->hours==24) t->hours = 0;delay();}void display(struct my_time *t){printf("%02d:", t->hours);
printf("%02d:", t->minutes);
printf("%02d\n", t->seconds);}void delay(void){long int t;/* change this as needed */for(t=1; t<DELAY; ++t) ;}The timing of this program is adjusted by changing the definition of
DELAY
.As you can see, a global structure called
my_timeis defined but no variable isdeclared. Inside
main( ), the structure
systimeis declared and initialized to 00:00:00.
This means thatsystimeis known directly only to the
main( )function.The functionsupdate( )(which changes the time) anddisplay( )(which printsthe time) are passed the address of
systime. In both functions, their arguments are
declared as a pointer to a
my_timestructure.
Insideupdate( )anddisplay( ), each member ofsystimeis accessed via a pointer.
Becauseupdate( )receives a pointer to the
systimestructure, it can update its value.
172C++:TheCompleteReference
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
173THEFOUNDATIONOFC++:
THECSUBSET
For example, to set the hours back to 0 when 24:00:00 is reached,
update( )containsthis line of code:if(t->hours==24) t->hours = 0;This tells the compiler to take the address in
t(which points tosystimeinmain( ))and use it to reset
hoursto zero.
Remember, use the dot operator to access structure elements when operating on
the structure itself. When you have a pointer to a structure, use the arrow operator.
Arrays and Structures Within Structures
Amemberofastructuremaybeeitherasimpleoraggregatetype.Asimplemember
isonethatisofanyofthebuilt-indatatypes,suchasintegerorcharacter.Youhave

alreadyseenonetypeofaggregateelement:thecharacterarraysusedin
addr.Other
aggregatedatatypesincludeone-dimensionalandmultidimensionalarraysofthe

otherdatatypes,andstructures.
Amember of a structure that is an array is treated as you might expect from the
earlier examples. For example, consider this structure:
struct x {int a[10][10]; /* 10 x 10 array of ints */float b;} y;To reference integer 3,7 in
aof structure
y, writey.a[3][7]When a structure is a member of another structure, it is called a
nestedstructure
.For example, the structure
addressis nested insideempin this example:struct emp {struct addr address; /* nested structure */
float wage;} worker;Here, structure
emphas been defined as having two members. The first is a structure
of typeaddr, which contains an employee's address. The other is
wage, which holds174C++:TheCompleteReference
the employee's wage. The following code fragment assigns 93456 to thezipelementofaddress.worker.address.zip = 93456;As you can see, the members of each structure are referenced from outermost to
innermost. C guarantees that structures can be nested to at least 15 levels. Standard

C++ suggests that at least 256 levels of nesting be allowed.Bit-FieldsUnlike some other computer languages, C/C++ has a built-in feature called a
bit-fieldthat allows you to access a single bit. Bit-fields can be useful for a number of reasons,

such as:If storage is limited, you can store several Boolean (true/false) variables in

one byte.Certain devices transmit status information encoded into one or more bits

within a byte.Certain encryption routines need to access the bits within a byte.
Although these tasks can be performed using the bitwise operators, a bit-field can
add more clarity (and possibly efficiency) to your code.
To access individual bits, C/C++ uses a method based on the structure. In fact,
a bit-field is really just a special type of structure member that defines how long,

in bits, the field is to be. The general form of a bit-field definition isstruct
struct-type-name{typename1:length;typename2
:length;.
.
.
typenameN
:length;}variable_list;Here,
typeisthetypeofthebit-fieldand
lengthisthenumberofbitsinthefield.Abit-field
must be declared as an integral or enumeration type. Bit-fields of length 1 should be

declared as
unsigned, because a single bit cannot have a sign.Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
175THEFOUNDATIONOFC++:
THECSUBSET
Bit-fields are frequently used when analyzing input from a hardware device.
For example, the status port of a serial communications adapter might return a
status byte organized like this:
BitMeaning When Set
0Change in clear-to-send line
1Change in data-set-ready

2Trailing edge detected

3Change in receive line

4Clear-to-send

5Data-set-ready

6Telephone ringing

7Received signal
You can represent the information in a status byte using the following bit-field:
struct status_type {unsigned delta_cts: 1;unsigned delta_dsr: 1;
unsigned tr_edge:   1;
unsigned delta_rec: 1;
unsigned cts:       1;
unsigned dsr:       1;
unsigned ring:      1;
unsigned rec_line:  1;} status;You might use a routine similar to that shown here to enable a program to determine
when it can send or receive data.
status = get_port_status();if(status.cts) printf("clear to send");
if(status.dsr) printf("data ready");To assign a value to a bit-field, simply use the form you would use for any other type
of structure element. For example, this code fragment clears the
ringfield:status.ring = 0;176C++:TheCompleteReference
Asyoucanseefromthisexample,eachbit-fieldisaccessedwiththedotoperator.However,
ifthestructureisreferencedthroughapointer,youmustusethe
>operator.
Youdonothavetonameeachbit-field.Thismakesiteasytoreachthebityouwant,
bypassing unused ones. For example, if you only care about the
ctsanddsrbits, youcould declare the
status_typestructure like this:
struct status_type {unsigned :    4;unsigned cts: 1;
unsigned dsr: 1;} status;Also, notice that the bits afterdsrdo not need to be specified if they are not used.
It is valid to mix normal structure members with bit-fields. For example,
struct emp {struct addr address;
float pay;
unsigned lay_off:    1; /* lay off or active */
unsigned hourly:     1; /* hourly pay or wage */
unsigned deductions: 3; /* IRS deductions */};defines an employee record that uses only 1 byte to hold three pieces of information:
the employee's status, whether the employee is salaried, and the number of deductions.
Without the bit-field, this information would have taken 3 bytes.
Bit-fields have certain restrictions. You cannot take the address of a bit-field. Bit-
fields cannot be arrayed. They cannot be declared as
static. You cannot know,from
machine to machine, whether the fields will run from right to left or from left to right;

this implies that any code using bit-fields may have some machine dependencies.
Other restrictions may be imposed by various specific implementations.
UnionsAunionis a memory location that is shared by two or more different types of variables.
Aunion provides a way of interpreting the same bit pattern in two or more different

ways.  Declaring aunionis similar to declaring a structure. Its general form is
unionunion-type-name{type member-name;Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
177THEFOUNDATIONOFC++:
THECSUBSET
type member-name;type member-name;.
.
.}union-variables;For example:union u_type {int i;char ch;};This declaration does not create any variables. You may declare a variable either
by placing its name at the end of the declaration or by using a separate declaration
statement. In C, to declare a
unionvariable calledcnvtof typeu_typeusing thedefinition just given, writeunion u_type cnvt;When declaringunionvariables in C++, you need use only the type name—you don't need to precede it with the keyword
union. For example, this is howcnvtis declared in C++:
u_type cnvt;In C++, preceding this declaration with the keyword
unionis allowed, but redundant.
In C++, the name of auniondefines a complete type name. In C, a union name is itstag and it must be preceded by the keyword
union. (This is similar to the situation withstructures described earlier.) However, since the programs in this chapter are valid for

both C and C++, the C-style declaration form will be used.Incnvt, both integeriand characterchshare the same memory location. Of
course,ioccupies 2 bytes (assuming 2-byte integers) andchuses only 1. Figure 7-2
shows howiandchshare the same address. At any point in your program, you can
refer to the data stored in a
cnvtas either an integer or a character.
When aunionvariable is declared, the compiler automatically allocates enough
storagetoholdthelargestmemberofthe
union.Forexample(assuming2-byteintegers),
cnvtis 2 bytes long so that it can holdi,even thoughchrequires only 1 byte.
178C++:TheCompleteReference
To access a member of a
union, use the same syntax that you would use forstructures: the dot and arrow operators. If you are operating on the
uniondirectly,
use the dot operator. If the
unionis accessed through a pointer, use the arrow
operator. For example, to assign the integer 10 to element
iofcnvt, writecnvt.i = 10;In the next example, a pointer tocnvtis passed to a function:void func1(union u_type *un){un->i = 10; /* assign 10 to cnvt througha pointer */}Unionsareusedfrequentlywhenspecializedtypeconversionsareneededbecauseyou
can refer to the data held in the
unionin fundamentally different ways. For example,
youmayusea
uniontomanipulatethebytesthatcomprisea
doubleinordertoalterits
precisionortoperformsomeunusualtypeofrounding.
Togetanideaoftheusefulnessofa
unionwhennonstandardtypeconversions
areneeded,considertheproblemofwritingashortintegertoadiskfile.TheC/C++
standard library defines no function specifically designed to write a short integer to

afile.Whileyoucanwriteanytypeofdatatoafileusing
fwrite(),
usingfwrite()
incurs excessive overhead for such a simple operation. However, using a
unionyoucan easily create a function called
putw( ), which writes the binary representation of
ashortintegertoafileonebyteatatime.(Thisexampleassumesthatshortintegers

are 2 bytes long.) To see how, first create a
unionconsisting of one short integer anda 2-byte character array:union pw {short int i;Figure7-2.
Howiandchutilize the unioncnvt(assume 2-byte integers)Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
179THEFOUNDATIONOFC++:
THECSUBSET
char ch[2];};Now,youcanuse
pwtocreatetheversionof
putw( )showninthefollowingprogram.
#include <stdio.h>union pw {short int i;char ch[2];};int putw(short int num, FILE *fp);
int main(void){FILE *fp;fp = fopen("test.tmp", "wb+");
putw(1000, fp);  /* write the value 1000 as an integer */fclose(fp);return 0;}
int putw(short int num, FILE *fp){union pw word;word.i = num;
putc(word.ch[0], fp); /* write first half */return putc(word.ch[1], fp); /* write second half */}Althoughputw( )is called with a short integer, it can still use the standard function
putc( )to write each byte in the integer to a disk file one byte at a time.C++ supports a special type of unioncalled ananonymous unionwhich is discussed in
Part Two of this book.
180C++:TheCompleteReference
EnumerationsAnenumerationis a set of named integer constants that specify all the legal valuesa variable of that type may have. Enumerations are common in everyday life. For
example, an enumeration of the coins used in the United States ispenny, nickel, dime, quarter, half-dollar, dollarEnumerations are defined much like structures; the keyword
enumsignals the startof an enumeration type. The general form for enumerations isenumenum-type-name{enumeration list}variable_list;Here, both the type name and the variable list are optional. (But at least one must

be present.) The following code fragment defines an enumeration called
coin:enum coin { penny, nickel, dime, quarter,half_dollar, dollar};The enumeration type name can be used to declare variables of its type. In C, the
following declares
moneyto be a variable of typecoin.enum coin money;In C++, the variablemoneymay be declared using this shorter form:
coin money;In C++, an enumeration name specifies a complete type. In C, an enumeration name is
its tag and it requires the keyword
enumto complete it. (This is similar to the situationas it applies to structures and unions, described earlier.)
Given these declarations, the following types of statements are perfectly valid:
money = dime;if(money==quarter) printf("Money is a quarter.\n");The key point to understand about an enumeration is that each of the symbolsstands for an integer value. As such, they may be used anywhere that an integer may
be used. Each symbol is given a value one greater than the symbol that precedes it.

The value of the first enumeration symbol is 0. Therefore,
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
181THEFOUNDATIONOFC++:
THECSUBSET
printf("%d %d", penny, dime);displays0 2on the screen.
Youcanspecifythevalueofoneormoreofthesymbolsbyusinganinitializer.
Dothisbyfollowingthesymbolwithanequalsignandanintegervalue.Symbols
thatappearafterinitializersareassignedvaluesgreaterthanthepreviousinitialization

value.Forexample,thefollowingcodeassignsthevalueof100to
quarter:enum coin { penny, nickel, dime, quarter=100,half_dollar, dollar};Now, the values of these symbols are
penny0
nickel1

dime2

quarter100

half_dollar101

dollar102
One common but erroneous assumption about enumerations is that the symbols
can be input and output directly. This is not the case. For example, the following code
fragment will not perform as desired:
/* this will not work */money = dollar;
printf("%s", money);Remember,
dollaris simply a name for an integer; it is not a string. For the samereason, you cannot use this code to achieve the desired results:
/* this code is wrong */
strcpy(money, "dime");That is, a string that contains the name of a symbol is not automatically converted tothat symbol.Actually, creating code to input and output enumeration symbols is quite tedious
(unless you are willing to settle for their integer values). For example, you need the
following code to display, in words, the kind of coins that
moneycontains:switch(money) {case penny: printf("penny");break;case nickel: printf("nickel");break;case dime: printf("dime");break;case quarter: printf("quarter");break;case half_dollar: printf("half_dollar");break;case dollar: printf("dollar");}Sometimes you can declare an array of strings and use the enumeration value as an
index to translate that value into its corresponding string. For example, this code also

outputs the proper string:
char name[][12]={"penny","nickel",
"dime",
"quarter",
"half_dollar",
"dollar"};
printf("%s", name[money]);Of course, this only works if no symbol is initialized, because the string array mustbe indexed starting at 0 in strictly ascending order using increments of 1.
Since enumeration values must be converted manually to their human-readable
string values for I/O operations, they are most useful in routines that do not make

such conversions. An enumeration is often used to define a compiler's symbol table,
for example. Enumerations are also used to help prove the validity of a program by

providing a compile-time redundancy check confirming that a variable is assigned

only valid values.182C++:TheCompleteReference
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
183THEFOUNDATIONOFC++:
THECSUBSET
Using sizeof to Ensure Portability
You have seen that structures and unions can be used to create variables of different
sizes, and that the actual size of these variables may change from machine to machine.

Thesizeofoperator computes the size of any variable or type and can help eliminatemachine-dependent code from your programs. This operator is especially useful where

structures or unions are concerned.
For the following discussion, assume an implementation, common to many C/C++compilers, that has the sizes for data types shown here:
Type
Size in Byteschar1int4
double8
Therefore, the following code will print the numbers 1, 4, and 8 on the screen:
char ch;int i;
double f;printf("%d", sizeof(ch));printf("%d", sizeof(i));
printf("%d", sizeof(f));The size of a structure is equal to
or greater than
the sum of the sizes of its members.For example,struct s {char ch;
int i;
double f;} s_var;Here,
sizeof(s_var)is at least 13 (8 + 4 + 1). However, the size of
s_varmight begreater because the compiler is allowed to pad a structure in order to achieve word
or paragraph alignment. (Aparagraph is 16 bytes.) Since the size of a structure may

be greater than the sum of the sizes of its members, you should always use
sizeofwhen you need to know the size of a structure.
184C++:TheCompleteReference
Sincesizeofis a compile-time operator, all the information necessary to compute
the size of any variable is known at compile time. This is especially meaningful forunions, because the size of aunionis always equal to the size of its largest member.
For example, considerunion u {char ch;int i;
double f;} u_var;Here, the
sizeof(u_var)is 8. At run time, it does not matter what
u_varis actuallyholding. All that matters is the size of its largest member, because any
unionmustbe as large as its largest element.
typedefYoucandefinenewdatatypenamesbyusingthekeyword
typedef.Youarenot
actuallycreating
anewdatatype,butratherdefininganewnameforanexisting
type.Thisprocesscanhelpmakemachine-dependentprogramsmoreportable.If
youdefineyourowntypenameforeachmachine-dependentdatatypeusedbyyour

program,thenonlythe
typedefstatementshavetobechangedwhencompilingfora
newenvironment.
typedefalsocanaidinself-documentingyourcodebyallowing
descriptivenamesforthestandarddatatypes.Thegeneralformofthe
typedefstatementis
typedeftype newname;where
typeis any valid data type andnewnameis the new name for this type. Thenew name you define is in addition to, not a replacement for, the existing type name.
For example, you could create a new name for
floatby usingtypedef float balance;This statement tells the compiler to recognize
balanceas another name forfloat.Next, you could create a
floatvariable usingbalance:balance over_due;Here,
over_dueis a floating-point variable of typebalance, which is another word
forfloat.Now thatbalancehas been defined, it can be used in anothertypedef. For example,typedef balance overdraft;tells the compiler to recognize
overdraftas another name forbalance, which is anothername forfloat.Usingtypedefcan make your code easier to read and easier to port to a new
machine, but you are not creating a new physical type.
Chapter7:Structures,Unions,Enumerations,andUser-DefinedTypes
185THEFOUNDATIONOFC++:
THECSUBSET
This page intentionally left blank Chapter8
C-Style Console I/O187Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
188C++:TheCompleteReference
C++ supports two complete I/O systems. The first it inherits from C. The secondis the object-oriented I/O system defined by C++. This and the next chapter
discusstheC-likeI/Osystem.(PartTwoexaminesC++I/O.)Whileyou
willprobablywanttousetheC++I/Osystemformostnewprojects,C-styleI/O

isstillquitecommon,andknowledgeofitsfeaturesisfundamentaltoacomplete

understanding of C++.In C, input and output are accomplished through library functions. There are both
console and file I/O functions. Technically,there is little distinction between console

I/OandfileI/O,butconceptuallytheyareinverydifferentworlds.Thischapter

examinesindetailtheconsoleI/Ofunctions.ThenextchapterpresentsthefileI/O

system and describes how the two systems relate.
Withoneexception,thischaptercoversonlyconsoleI/Ofunctionsdefinedby
StandardC++.StandardC++doesnotdefineanyfunctionsthatperformvarious

screencontroloperations(suchascursorpositioning)orthatdisplaygraphics,

becausetheseoperationsvarywidelybetweenmachines.Nordoesitdefineany

functionsthatwritetoawindowordialogboxunderWindows.Instead,theconsole

I/OfunctionsperformonlyTTY-basedoutput.However,mostcompilersincludein

theirlibrariesscreencontrolandgraphicsfunctionsthatapplytothespecificenvironment

inwhichthecompilerisdesignedtorun.And,ofcourse,youmayuseC++towrite

Windowsprograms,butkeepinmindthattheC++languagedoesnotdirectlydefine

functionsthatperformthesetasks.
The Standard C I/O functions all use the header file
stdio.h. C++ programs can
also use the C++-style header<cstdio>.ThischapterreferstotheconsoleI/Ofunctionsasperforminginputfromthe
keyboardandoutputtothescreen.However,thesefunctionsactuallyhavethe

standardinputandstandardoutputofthesystemasthetargetand/orsourceof

theirI/Ooperations.Furthermore,standardinputandstandardoutputmaybe

redirectedtootherdevices.TheseconceptsarecoveredinChapter9.
An Important Application Note
PartOneofthisbookusestheC-likeI/OsystembecauseitistheonlystyleofI/O

thatisdefinedfortheCsubsetofC++.Asexplained,C++alsodefinesitsown

object-orientedI/Osystem.FormostC++applications,youwillwanttousethe

C++-specificI/Osystem,nottheCI/Osystemdescribedinthischapter.However,

anunderstandingofC-basedI/Oisimportantforthefollowingreasons:
Atsomepointinyourcareeryoumaybecalledupontowritecodethatis

restrictedtotheCsubset.Inthiscase,youwillneedtousetheC-likeI/O

functions.For the foreseeable future, C and C++ will coexist. Also, many programs will be

hybrids of both C and C++ code. Further, it will be common for C programs to

be "upgraded" into C++ programs. Thus, knowledge of both the C and the C++
Chapter8:C-StyleConsoleI/O
189THEFOUNDATIONOFC++:
THECSUBSET
I/O system will be necessary. For example, in order to change the C-style I/O
functions into their C++ object-oriented equivalents, you will need to know
how both the C and C++ I/O systems operate.An understanding of the basic principles behind the C-like I/O system is
crucial to an understanding of the C++ object-oriented I/O system. (Both

share the same general concepts.)
In certain situations (for example, in very short programs), it may be easier to

use C's non-object-oriented approach to I/O than it is to use the object-oriented

I/O defined by C++.In addition, there is an unwritten rule that any C++ programmer must also be a C
programmer. If you don't know how to use the C I/O system, you will be limiting your

professional horizons.
Reading and Writing Characters
The simplest of the console I/O functions are
getchar( ), which reads a character from
the keyboard, and
putchar( ), which prints a character to the screen. The
getchar( )function waits until a key is pressed and then returns its value. The key pressed is also

automatically echoed to the screen. The
putchar( )function writes a character to thescreen at the current cursor position. The prototypes for
getchar( )andputchar( )are
shown here:
int getchar(void);
int putchar(intc);As its prototype shows, the
getchar( )function is declared as returning an integer.
However, you can assign this value to a
charvariable, as is usually done, because thecharacter is contained in the low-order byte. (The high-order byte is normally zero.)

getchar( )returns
EOFif an error occurs.
In the case ofputchar( ),even though it is declared as taking an integer parameter,
you will generally call itusing a character argument. Only the low-order byte of its

parameter is actually output to the screen. The
putchar( )function returns the character
written, orEOFif an error occurs. (The
EOFmacro is defined in
stdio.hand isgenerally equal to−1.)The following program illustrates
getchar( )andputchar( ).It inputs charactersfrom the keyboard and displays them in reverse case
that is, it prints uppercase as

lowercase and lowercase as uppercase. To stop the program, enter a period.
#include <stdio.h>#include <ctype.h>int main(void){char ch;printf("Enter some text (type a period to quit).\n");do {ch = getchar();if(islower(ch)) ch = toupper(ch);else ch = tolower(ch);putchar(ch);} while (ch != '.');
return 0;}A Problem with getchar( )
Therearesomepotentialproblemswith
getchar( ).Normally,
getchar( )isimplemented
insuchawaythatitbuffersinputuntil
ENTERispressed.Thisiscalled
line-buffered
input;youhavetopress
ENTERbeforeanythingyoutypedisactuallysenttoyourprogram.
Also,since
getchar( )inputsonlyonecharactereachtimeitiscalled,line-bufferingmay
leaveoneormorecharacterswaitingintheinputqueue,whichisannoyingininteractive
environments.EventhoughStandardC/C++specifythat
getchar( )canbeimplemented
asaninteractivefunction,itseldomis.Therefore,iftheprecedingprogramdidnot

behaveasyouexpected,younowknowwhy.
Alternatives to getchar( )getchar( )mightnotbeimplementedbyyourcompilerinsuchawaythatitisusefulin
aninteractiveenvironment.Ifthisisthecase,youmightwanttouseadifferentfunction

toreadcharactersfromthekeyboard.StandardC++doesnotdefineanyfunctionthatis

guaranteedtoprovideinteractiveinput,butvirtuallyallC++compilersdo.Although

thesefunctionsarenotdefinedbyStandardC++,theyarecommonlyusedsince
getchar()
doesnotfilltheneedsofmostprogrammers.
Two of the most common alternative functions,
getch( )andgetche( ), have theseprototypes:
int getch(void);
int getche(void);190C++:TheCompleteReference
Chapter8:C-StyleConsoleI/O
191THEFOUNDATIONOFC++:
THECSUBSET
For most compilers, the prototypes for these functions are found in the header file
conio.h. For some compilers, these functions have a leading underscore. For example,

in Microsoft's Visual C++, they are called
_getch( )and_getche( ).Thegetch( )functionwaitsforakeypress,afterwhichitreturnsimmediately.
Itdoesnotechothecharactertothescreen.The
getche()
functionisthesameas
getch()
,butthekeyisechoed.Youwillfrequentlysee
getche()
orgetch()
usedinsteadof
getchar()
whenacharacterneedstobereadfromthekeyboardinan
interactiveprogram.However,ifyourcompilerdoesnotsupportthesealternative

functions,orif
getchar( )isimplementedasaninteractivefunctionbyyourcompiler,
youshouldsubstitute
getchar( )whennecessary.
Forexample,thepreviousprogramisshownhereusing
getch( )insteadof
getchar( ):#include <stdio.h>#include <conio.h>
#include <ctype.h>int main(void){char ch;printf("Enter some text (type a period to quit).\n");do {ch = getch();if(islower(ch)) ch = toupper(ch);else ch = tolower(ch);putchar(ch);} while (ch != '.');
return 0;}Whenyourunthisversionoftheprogram,eachtimeyoupressakey,itis
immediatelytransmittedtotheprogramanddisplayedinreversecase.Inputisno
longerline-buffered.Whilethecodeinthisbookwillnotmakefurtheruseof
getch( )orgetche( ),theymaybeusefulintheprogramsthatyouwrite.
Atthetimeofthiswriting,whenusingMicrosoft'sVisualC++compiler,
_getche( )and_getch( )arenotcompatiblewiththestandardC/C++inputfunctions,suchas
scanf( )orgets( ).Instead,youmustusespecialversionsofthestandardfunctions,suchas
cscanf()
orcgets()
.YouwillneedtoexaminetheVisualC++documentationfordetails.
192C++:TheCompleteReference
Reading and Writing Strings
The next step up in console I/O, in terms of complexity and power, are the functions
gets( )andputs( ). They enable you to read and write strings of characters.
Thegets()
functionreadsastringofcharactersenteredatthekeyboardand
placesthemattheaddresspointedtobyitsargument.Youmaytypecharactersat

thekeyboarduntilyoupress
ENTER.Thecarriagereturndoesnotbecomepartofthe
string;instead,anullterminatorisplacedattheendand
gets( )returns.Infact,you
cannotuse
gets( )toreturnacarriagereturn(although
getchar( )candoso).Youcan
correcttypingmistakesbyusingthebackspacekeybeforepressing
ENTER.Theprototypefor
gets( )ischar *gets(char *str);where
stris a character array that receives the characters input by the user.
gets( )alsoreturns
str. The following program reads a string into the array
strand prints its length:#include <stdio.h>#include <string.h>int main(void){char str[80];gets(str);printf("Length is %d", strlen(str));return 0;}Youneedtobecarefulwhenusing
gets()
becauseitperformsnoboundarychecksonthe
arraythatisreceivinginput.Thus,itispossiblefortheusertoentermorecharactersthan
thearraycanhold.While
gets()
isfineforsampleprogramsandsimpleutilitiesthat
onlyyouwilluse,youwillwanttoavoiditsuseincommercialcode.Onealternativeis

thefgets()
functiondescribedinthenextchapter,whichallowsyoutopreventan
arrayoverrun.
Theputs( )function writes its string argument to the screen followed by a newline.
Its prototype is:
int puts(const char *str);puts( )recognizes the same backslash codes as
printf( ), such as '\t' for tab. Acall
toputs( )requires far less overhead than the same call to
printf( )becauseputs( )can only output a string of charactersit cannot output numbers or do formatconversions. Therefore,
puts( )takes up less space and runs faster than
printf( ). Forthis reason, the
puts( )function is often used when it is important to have highlyoptimized code. Theputs( )function returns
EOFif an error occurs. Otherwise, it
returns a nonnegative value. However, when writing to the console, you can usually
assume that no error will occur, so the return value of
puts( )is seldom monitored.
The following statement displayshello:puts("hello");Table 8-1 summarizes the basic console I/O functions.
Thefollowingprogram,asimplecomputerizeddictionary,demonstratesseveral
ofthebasicconsoleI/Ofunctions.Itpromptstheusertoenterawordandthen

checkstoseeifthewordmatchesoneinitsbuilt-indatabase.Ifamatchisfound,

theprogramprintstheword'smeaning.Payspecialattentiontotheindirectionused

inthisprogram.Ifyouhaveanytroubleunderstandingit,rememberthatthe
dicarrayisanarrayofpointerstostrings.Noticethatthelistmustbeterminatedby

twonulls.
Chapter8:C-StyleConsoleI/O
193THEFOUNDATIONOFC++:
THECSUBSET
FunctionOperationgetchar( )Reads a character from the keyboard;

waits for carriage return.
getche( )Reads a character with echo; does not
wait for carriage return; not defined by

Standard C/C++, but a common extension.
getch( )Reads a character without echo; does not
wait for carriage return; not defined by

Standard C/C++, but a common extension.
putchar( )Writes a character to the screen.
gets( )Reads a string from the keyboard.
puts( )Writes a string to the screen.
Table8-1.
The Basic I/O Functions/* A simple dictionary. */#include <stdio.h>
#include <string.h>
#include <ctype.h>/* list of words and meanings */char  *dic[][40] = {"atlas", "A volume of maps.",
"car", "A motorized vehicle.",
"telephone", "A communication device.",
"airplane", "A flying machine.",
"", ""  /* null terminate the list */};int main(void){char word[80], ch;
char **p;do {puts("\nEnter word: ");scanf("%s", word);p = (char **)dic;
/* find matching word and print its meaning */do {if(!strcmp(*p, word)) {puts("Meaning:");
puts(*(p+1));
break;}
if(!strcmp(*p, word)) break;
p = p + 2;  /* advance through the list */} while(*p);
if(!*p) puts("Word not in dictionary.");
printf("Another? (y/n): ");
scanf(" %c%*c", &ch);} while(toupper(ch) != 'N');return 0;}194C++:TheCompleteReference
Formatted Console I/O
The functionsprintf( )andscanf( )perform formatted output and inputthat is, theycan read and write data in various formats that are under your control. The
printf( )function writes data to the console. Thescanf( )function, its complement, reads data
from the keyboard. Both functions can operate on any of the built-in data types,
including characters, strings, and numbers.printf( )The prototype for
printf( )isint printf(const char *control_string, ...);Theprintf( )function returns the number of characters written or a negative value if an
error occurs.
Thecontrol
_stringconsists of two types of items. The first type is composed ofcharacters that will be printed on the screen. The second type contains format specifiers

that define the way the subsequent arguments are displayed. Aformat specifier begins

with a percent sign and is followed by the format code. There must be exactly the same

number of arguments as there are format specifiers, and the format specifiers and the

arguments are matched in order from left to right. For example, this
printf( )callprintf("I like %c%s", 'C', "++ very much!");displaysI like C++ very much!Theprintf( )functionacceptsawidevarietyofformatspecifiers,asshownin
Table8-2.
Chapter8:C-StyleConsoleI/O
195THEFOUNDATIONOFC++:
THECSUBSET
CodeFormat
%cCharacter%dSigned decimal integersTable8-2.
printf( )Format Specifiers
Printing CharactersTo print an individual character, use
%c. This causes its matching argument to be
output, unmodified, to the screen.
To print a string, use%s.Printing NumbersYou may use either
%dor%ito indicate a signed decimal number. These format
specifiers are equivalent; both are supported for historical reasons.
To output an unsigned value, use%u.The%fformat specifier displays numbers in floating point.196C++:TheCompleteReference
CodeFormat
%iSigned decimal integers%eScientific notation (lowercase e)
%EScientific notation (uppercase E)
%fDecimal floating point%gUses %e or %f, whichever is shorter%GUses %E or %F, whichever is shorter
%oUnsigned octal%sString of characters%uUnsigned decimal integers%xUnsigned hexadecimal (lowercase letters)
%XUnsigned hexadecimal (uppercase letters)
%pDisplays a pointer%nThe associated argument must be a pointer to
an integer. This specifier causes the number of

characters written so far to be put into that integer.
%%Prints a % signTable8-2.
printf( )Format Specifiers
(continued)The%eand%Especifiers tellprintf( )to display adoubleargument in scientific
notation. Numbers represented in scientific notation take this general form:
x.dddddE+/−yyIf you want to display the letter "E" in uppercase, use the
%Eformat; otherwise use%e.Youcantell
printf( )touseeither
%for%ebyusingthe
%gor%Gformatspecifiers.
Thiscauses
printf( )toselecttheformatspecifierthatproducestheshortestoutput.
Whereapplicable,use
%Gifyouwant"E"showninuppercase;otherwise,use
%g.The
followingprogramdemonstratestheeffectofthe
%gformatspecifier:
#include <stdio.h>int main(void){double f;for(f=1.0; f<1.0e+10; f=f*10)printf("%g ", f);return 0;}It produces the following output.
1 10 100 1000 10000 100000 1e+006 1e+007 1e+008 1e+009You can display unsigned integers in octal or hexadecimal format using
%oand%x, respectively. Since the hexadecimal number system uses the letters Athrough F
to represent the numbers 10 through 15, you can display these letters in either upper-

or lowercase. For uppercase, use the
%Xformat specifier; for lowercase, use
%x, asshown here:
#include <stdio.h>int main(void){unsigned num;for(num=0; num<255; num++) {printf("%o ", num);printf("%x ", num);Chapter8:C-StyleConsoleI/O
197THEFOUNDATIONOFC++:
THECSUBSET
198C++:TheCompleteReference
printf("%X\n", num);}return 0;}Displaying an Address
If you wish to display an address, use
%p. This format specifier causesprintf( )todisplay a machine address in a format compatible with the type of addressing used
by the computer. The next program displays the address of
sample:#include <stdio.h>int sample;
int main(void){printf("%p", &sample);return 0;}The %nSpecifier
The%nformatspecifierisdifferentfromtheothers.Insteadoftelling
printf()
todisplaysomething,itcauses
printf( )toloadthevariablepointedtobyitscorresponding
argumentwithavalueequaltothenumberofcharactersthathavebeenoutput.Inother
words,thevaluethatcorrespondstothe
%nformatspecifiermustbeapointertoa
variable.Afterthecallto
printf()
hasreturned,thisvariablewillholdthenumberof
charactersoutput,uptothepointatwhichthe
%nwasencountered.Examinethis
programtounderstandthissomewhatunusualformatcode.
#include <stdio.h>int main(void){int count;printf("this%n is a test\n", &count);printf("%d", count);Chapter8:C-StyleConsoleI/O
199THEFOUNDATIONOFC++:
THECSUBSET
return 0;}This program displays
this is a testfollowed by the number 4. The%nformat specifieris used primarily to enable your program to perform dynamic formatting.
Format Modifiers
Manyformatspecifiersmaytakemodifiersthataltertheirmeaningslightly.For
example,youcanspecifyaminimumfieldwidth,thenumberofdecimalplaces,and

leftjustification.Theformatmodifiergoesbetweenthepercentsignandtheformat

code. These modifiers are discussed next.
The Minimum Field Width Specifier
An integer placed between the % sign and the format code acts as aminimumfieldwidth
specifier. This pads the output with spaces to ensure that it reaches a certain minimum
length. If the string or number is longer than that minimum, it will still be printed in
full. The default padding is done with spaces. If you wish to pad with 0's, place a 0
before the field width specifier. For example,
%05dwill pad a number of less than fivedigits with 0's so that its total length is five. The following program demonstrates the

minimum field width specifier:#include <stdio.h>int main(void){double item;item = 10.12304;
printf("%f\n", item);printf("%10f\n", item);
printf("%012f\n", item);return 0;}This program produces the following output:
10.12304010.12304000010.123040200C++:TheCompleteReference
The minimum field width modifier is most commonly used to produce tables in which
the columns line up. For example, the next program produces a table of squares and

cubes for the numbers between 1 and 19:#include <stdio.h>int main(void){int i;/* display a table of squares and cubes */for(i=1; i<20; i++)printf("%8d %8d %8d\n", i, i*i, i*i*i);return 0;}Asample of its output is shown here:
1        1        1
2        4        8
3        9       27
4       16       64
5       25      125
6       36      216
7       49      343
8       64      512
9       81      72910      100     1000
11      121     1331
12      144     1728
13      169     2197
14      196     2744
15      225     3375
16      256     4096
17      289     4913
18      324     5832
19      361     6859The Precision Specifier
Theprecisionspecifier
follows the minimum field width specifier (if there is one). It
consists of a period followed by an integer. Its exact meaning depends upon the
type of data it is applied to.Chapter8:C-StyleConsoleI/O
201THEFOUNDATIONOFC++:
THECSUBSET
When you apply the precision specifier to floating-point data using the
%f,%e,or%Especifiers, it determines the number of decimal places displayed. For example,%10.4fdisplays a number at least ten characters wide with four decimal places.When the precision specifier is applied to
%gor%G,it specifies the number ofsignificant digits.Applied to strings, the precision specifier specifies the maximum field length. For
example,%5.7sdisplays a string at least five and not exceeding seven characters long.Ifthestringislongerthanthemaximumfieldwidth,theendcharacterswillbetruncated.
When applied to integer types, the precision specifier determines the minimum
number of digits that will appear for each number. Leading zeros are added to achieve
the required number of digits.
The following program illustrates the precision specifier:
#include <stdio.h>int main(void){printf("%.4f\n", 123.1234567);
printf("%3.8d\n", 1000);
printf("%10.15s\n", "This is a simple test.");return 0;}It produces the following output:
123.123500001000
This is a simplJustifying OutputBy default, all output is right-justified. That is, if the field width is larger than the data
printed, the data will be placed on the right edge of the field. You can force output to

be left-justified by placing a minus sign directly after the %. For example,
%10.2fleft-justifies a floating-point number with two decimal places in a 10-character field.The following program illustrates left justification:
#include <stdio.h>int main(void){printf("right-justified:%8d\n", 100);
printf("left-justified:%-8d\n", 100);202C++:TheCompleteReference
return 0;}Handling Other Data Types
Therearetwoformatmodifiersthatallow
printf( )todisplay
shortandlongintegers.Thesemodifiersmaybeappliedtothe
d,i,o,u,and
xtypespecifiers.The
l(ell)modifier
tellsprintf( )thata
longdatatypefollows.Forexample,
%ldmeansthata
longint
isto
bedisplayed.The
hmodifierinstructs
printf( )todisplaya
shortinteger.Forinstance,
%huindicatesthatthedataisoftype
shortunsignedint
.Thelandhmodifiers can also be applied to thenspecifier, to indicate that the
corresponding argument is a pointer to a long or short integer, respectively.
If your compiler fully complies with Standard C++, then you can use the
lmodifierwith thecformat to indicate a wide-character. You can also use the
lmodifier with thesformat to indicate a wide-character string.TheLmodifier may prefix the floating-point specifiers
e,f, andg, and indicates thatalongdouble
follows.The * and # ModifiersTheprintf()
functionsupportstwoadditionalmodifierstosomeofitsformatspecifiers:
*and#.Preceding
g,G,f,E,or
especifierswitha
#ensuresthattherewillbeadecimalpoint
even if there are no decimal digits. If you precede the
xorXformat specifier with a#,the hexadecimal number will be printed with a0xprefix. Preceding the
ospecifier with#causes the number to be printed with a leading zero. You cannot apply
#to any otherformat specifiers.Insteadofconstants,theminimumfieldwidthandprecisionspecifiersmaybe
provided by arguments to
printf( ). To accomplish this, use an
*as a placeholder. When
theformatstringisscanned,
printf()
willmatchthe
*toanargumentintheorderinwhich
they occur. For example, in Figure 8-1, the minimum field width is 10, the precision is 4,
and the value to be displayed is123.3.Figure8-1.
How the*is matched to its valueChapter8:C-StyleConsoleI/O
203THEFOUNDATIONOFC++:
THECSUBSET
The following program illustrates both
#and*:#include <stdio.h>int main(void){printf("%x %#x\n", 10, 10);
printf("%*.*f", 10, 4, 1234.34);return 0;}scanf( )scanf( )is the general-purpose console input routine. It can read all the built-in data
types and automatically convert numbers into the proper internal format. It is much
like the reverse of
printf( ). The prototype for
scanf( )isint scanf(const char *control_string, ...);Thescanf( )function returns the number of data items successfully assigned a value. If
an error occurs,
scanf( )returns
EOF. Thecontrol_string
determines how values are read
into the variables pointed to in the argument list.
The control string consists of three classifications of characters:
Format specifiersWhite-space charactersNon-white-space charactersLet's take a look at each of these now.
Format Specifiers
The input format specifiers are preceded by a % sign and tell
scanf( )what type ofdata is to be read next. These codes are listed in Table 8-3. The format specifiers are

matched, in order from left to right, with the arguments in the argument list. Let's

look at some examples.Inputting NumbersTo read an integer, use either the
%dor%ispecifier. To read a floating-point number
represented in either standard or scientific notation, use
%e,%f, or%g.Youcanuse
scanf()
toreadintegersineitheroctalorhexadecimalformbyusingthe
%oand%xformatcommands,respectively.The
%xmaybeineitherupper-orlowercase.
204C++:TheCompleteReference
Either way, you may enter the letters "A" through "F" in either case when entering
hexadecimalnumbers.Thefollowingprogramreadsanoctalandhexadecimalnumber:
#include <stdio.h>int main(void){int i, j;scanf("%o%x", &i, &j);printf("%o %x", i, j);return 0;}CodeMeaning%cRead a single character.
%dRead a decimal integer.
%iRead an integer in either decimal, octal, orhexadecimal format.%eRead a floating-point number.
%fRead a floating-point number.
%gRead a floating-point number.
%oRead an octal number.
%sRead a string.%xRead a hexadecimal number.
%pRead a pointer.
%nReceives an integer value equal to the number
of characters read so far.
%uRead an unsigned decimal integer.
%[ ]Scan for a set of characters.%%Read a percent sign.
Table8-3.
scanf( )Format Specifiers
Chapter8:C-StyleConsoleI/O
205THEFOUNDATIONOFC++:
THECSUBSET
Thescanf( )function stops reading a number when the first nonnumeric character is
encountered.
Inputting Unsigned IntegersTo input an unsigned integer, use the
%uformat specifier. For example,
unsigned num;scanf("%u", &num);reads an unsigned number and puts its value into
num.Reading Individual Characters Using scanf( )Asexplainedearlierinthischapter,youcanreadindividualcharactersusing
getchar( )oraderivativefunction.Youcanalsouse
scanf( )forthispurposeif
youusethe
%cformatspecifier.However,likemostimplementationsof
getchar( ),scanf( )willgenerallyline-bufferinputwhenthe
%cspecifierisused.Thismakes
itsomewhattroublesomeinaninteractiveenvironment.
Although spaces, tabs, and newlines are used as field separators when reading
other types of data, when reading a single character, white-space characters are read

like any other character. For example, with an input stream of "
x y," this code fragmentscanf("%c%c%c", &a, &b, &c);returns with the character
xina, a space inb, and the characteryinc.Reading StringsThescanf( )function can be used to read a string from the input stream using the
%sformat specifier. Using
%scausesscanf( )to read characters until it encounters a
white-space character. The characters that are read are put into the character array

pointed to by the corresponding argument and the result is null terminated. As it

applies toscanf( ), a white-space character is either a space, a newline, a tab, a verticaltab, or a form feed. Unlikegets( ), which reads a string until a carriage return is typed,
scanf( )reads a string until the first white space is entered. This means that you cannot
usescanf( )to read a string like "this is a test" because the first space terminates the
reading process. To see the effect of the
%sspecifier, try this program using the string
"hello there".
#include <stdio.h>int main(void){char str[80];printf("Enter a string: ");scanf("%s", str);
printf("Here's your string: %s", str);return 0;}The program responds with only the "hello" portion of the string.
Inputting an Address
To input a memory address, use the
%pformat specifier. This specifier causes
scanf( )to read an address in the format defined by the architecture of the CPU. For example,
this program inputs an address and then displays what is at that memory address:
#include <stdio.h>int main(void){char *p;printf("Enter an address: ");scanf("%p", &p);
printf("Value at location %p is %c\n", p, *p);return 0;}The %n SpecifierThe%nspecifier instructs
scanf( )to assign the number of characters read from the
input stream at the point at which the
%nwas encountered to the variable pointed
to by the corresponding argument.
Using a ScansetThescanf( )function supports a general-purpose format specifier called a scanset. Ascansetdefinesasetofcharacters.When
scanf()
processesascanset,itwillinputcharacters
aslongasthosecharactersarepartofthesetdefinedbythescanset.Thecharactersread
will be assigned to the character array that is pointed to by the scanset's corresponding
206C++:TheCompleteReference
argument. You define a scanset by putting the characters to scan for inside square
brackets.Thebeginningsquarebracketmustbeprefixedbyapercentsign.For

example, the following scanset tellsscanf( )to read only the characters X, Y, and Z.
%[XYZ]When you use a scanset,scanf( )continues to read characters, putting them into the
corresponding character array until it encounters a character that is not in the scanset.

Upon return from
scanf( ), this array will contain a null-terminated string that consistsof the characters that have been read. To see how this works, try this program:
#include <stdio.h>int main(void){int i;
char str[80], str2[80];scanf("%d%[abcdefg]%s", &i, str, str2);printf("%d %s %s", i, str, str2);return 0;}Enter123abcdtyefollowed byENTER. The program will then display
123abcdtye
.Because the "t" is not part of the scanset,scanf( )stops reading characters into
strwhen it encounters the "t." The remaining characters are put into
str2.You can specify an inverted set if the first character in the set is a
^. The^instructs
scanf( )to accept any character that isnotdefined by the scanset.In most implementations you can specify a range using a hyphen. For example, thistellsscanf( )to accept the characters Athrough Z:
%[A-Z]One important point to remember is that the scanset is case sensitive. If you want
to scan for both upper- and lowercase letters, you must specify them individually.
Discarding Unwanted White Space
Awhite-space character in the control string causes
scanf( )to skip over one or more
leading white-space characters in the input stream. Awhite-space character is either a
Chapter8:C-StyleConsoleI/O
207THEFOUNDATIONOFC++:
THECSUBSET
208C++:TheCompleteReference
space, a tab, vertical tab, form feed, or a newline. In essence, one white-space characterin the control string causes
scanf( )to read, but not store, any number (including zero)
of white-space characters up to the first non-white-space character.
Non-White-Space Characters in the Control String
Anon-white-space character in the control string causes
scanf( )to read and discard
matching characters in the input stream. For example,
"%d,%d"causesscanf( )to read
an integer, read and discard a comma, and then read another integer. If the specified

character is not found,scanf( )terminates. If you wish to read and discard a percent
sign, use%%in the control string.
You Must Pass scanf( ) Addresses
Allthevariablesusedtoreceivevaluesthrough
scanf( )mustbepassedbytheir
addresses.Thismeansthatallargumentsmustbepointerstothevariablesusedas

arguments.Recallthatthisisonewayofcreatingacallbyreference,anditallows

afunctiontoalterthecontentsofanargument.Forexample,toreadanintegerinto

thevariable
count,youwouldusethefollowing
scanf( )call:scanf("%d", &count);Strings will be read into character arrays, and the array name, without any index, is
the address of the first element of the array. So, to read a string into the character array

str, you would usescanf("%s", str);In this case,stris already a pointer and need not be preceded by the
&operator.
Format Modifiers
As withprintf( ),scanf( )allows a number of its format specifiers to be modified.The format specifiers can include a maximum field length modifier. This is an
integer, placed between the % and the format specifier, that limits the number of

characters read for that field. For example, to read no more than 20 characters into

str, writescanf("%20s", str);If the input stream is greater than 20 characters, a subsequent call to input begins

where this call leaves off. For example, if you enter
ABCDEFGHIJKLMNOPQRSTUVWXYZas the response to the
scanf( )call in this example, only the first 20 characters, or upto the "T," are placed into
strbecause of the maximum field width specifier. This means
that the remaining characters, UVWXYZ, have not yet been used. If another
scanf( )call is made, such asscanf("%s", str);the letters UVWXYZ are placed into
str. Input for a field may terminate before the
maximum field length is reached if a white space is encountered. In this case,
scanf( )moves on to the next field.To read a long integer, put an
l(ell) in front of the format specifier. To read a short
integer, put an
hin front of the format specifier. These modifiers can be used with the
d,i,o,u,x, andnformat codes.By default, thef,e, andgspecifiers instruct
scanf( )to assign data to afloat. If youput anl(ell) in front of one of these specifiers,
scanf( )assigns the data to adouble.Using anLtellsscanf( )that the variable receiving the data is a
longdouble
.Suppressing Input
You can tell
scanf( )to read a field but not assign it to any variable by preceding that
field's format code with an*. For example, givenscanf("%d%*c%d", &x, &y);you could enter the coordinate pair
10,10. The comma would be correctly read, but not
assigned to anything. Assignment suppression is especially useful when you need to
process only a part of what is being entered.
Chapter8:C-StyleConsoleI/O
209THEFOUNDATIONOFC++:
THECSUBSET
This page intentionally left blank Chapter9
File I/O211Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This chapter describes the C file system. As explained in Chapter 8, C++ supportstwo complete I/O systems: the one inherited from C and the object-oriented
systemdefinedbyC++.ThischaptercoverstheCfilesystem.(TheC++file
system is discussed in Part Two.) While most new code will use the C++ file system,
knowledge of the C file system is still important for the reasons given in the preceding
chapter.C Versus C++ File I/O
There is sometimes confusion over how C's file system relates to C++. First, C++

supports the entire Standard C file system. Thus, if you will be porting C code to

C++, you will not have to change all of your I/O routines right away. Second, C++

defines its own, object-oriented I/O system, which includes both I/O functions and
I/O operators. The C++ I/O system completely duplicates the functionality of the C
I/O system and renders the C file system redundant. While you will usually want to

use the C++ I/O system, you are free to use the C file system if you like. Of course,

most C++ programmers elect to use the C++ I/O system for reasons that are made

clear in Part Two of this book.
Streams and Files
BeforebeginningourdiscussionoftheCfilesystem,itisnecessarytoknowthedifference

between the termsstreams
andfiles. The C I/O system supplies a consistent interfaceto the programmer independent of the actual device being accessed. That is, the C I/O

system provides a level of abstraction between the programmer and the device. This

abstraction is called astream
and the actual device is called afile. It is important tounderstand how streams and files interact.
The concept of streams and files is also important to the C++ I/O system discussed in

Part Two.
Streams
TheCfilesystemisdesignedtoworkwithawidevarietyofdevices,includingterminals,

disk drives, and tape drives. Even though each device is very different, the file system

transformseachintoalogicaldevicecalledastream.Allstreamsbehavesimilarly.Because

streams are largely device independent, the same function that can write to a disk file

can also be used to write to another type of device, such as the console. There are two

types of streams: text and binary.
212C++:TheCompleteReference
Text Streams
Atextstream
isasequenceofcharacters.StandardCallows(butdoesnotrequire)a
textstreamtobeorganizedintolinesterminatedbyanewlinecharacter.However,
the newline character is optional on the last line. (Actually, most C/C++ compilers do

not terminate text streams with newline characters.) In a text stream, certain character

translations may occur as required by the host environment. For example, a newline

maybeconvertedtoacarriagereturn/linefeedpair.Therefore,theremaynotbea

one-to-onerelationshipbetweenthecharactersthatarewritten(orread)andthose

on the external device. Also, because of possible translations, the number of characters
written (or read) may not be the same as those on the external device.
Binary Streams
Abinarystream
is a sequence of bytes that have a one-to-one correspondence to those
in the external devicethat is, no character translations occur. Also, the number of
bytes written (or read) is the same as the number on the external device. However,

an implementation-defined number of null bytes may be appended to a binary stream.

These null bytes might be used to pad the information so that it fills a sector on a disk,
for example.FilesIn C/C++, afilemay be anything from a disk file to a terminal or printer. You associate
a stream with a specific file by performing an open operation. Once a file is open,

information may be exchanged between it and your program.
Not all files have the same capabilities. For example, a disk file can support randomaccess while some printers cannot. This brings up an important point about the C I/O
system: All streams are the same but all files are not.
If the file can supportpositionrequests
, opening that file also initializes thefilepositionindicator
to the start of the file. As each character is read from or written to
the file, the position indicator is incremented, ensuring progression through the file.
You disassociate a file from a specific stream with a close operation. If you close
a file opened for output, the contents, if any, of its associated stream are written to the

externaldevice.Thisprocessisgenerallyreferredtoas
flushingthestream,andguarantees
thatnoinformationisaccidentallyleftinthediskbuffer.Allfilesareclosedautomatically

when your program terminates normally, either by
main( )returning to the operating
systemorbyacallto
exit()
.Filesarenotclosedwhenaprogramterminatesabnormally,
such as when it crashes or when it callsabort( ).Each stream that is associated with a file has a file control structure of type
FILE.Never modify this file control block.
If you are new to programming, the separation of streams and files may seem
unnecessaryorcontrived.Justrememberthatitsmainpurposeistoprovide
Chapter9:FileI/O
213THEFOUNDATIONOFC++:
THECSUBSET
a consistent interface. You need only think in terms of streams and use only one file
system to accomplish all I/O operations. The I/O system automatically converts the
raw input or output from each device into an easily managed stream.
File System BasicsThe C file system is composed of several interrelated functions. The most common of

these are shown in Table 9-1. They require the header
stdio.h. C++ programs may also
use the C++-style header<cstdio>.214C++:TheCompleteReference
NameFunctionfopen( )Opens a file.fclose( )Closes a file.putc( )Writes a character to a file.
fputc( )Same asputc( ).getc( )Reads a character from a file.
fgetc( )Same asgetc( ).fgets( )Reads a string from a file.
fputs( )Writes a string to a file.
fseek( )Seeks to a specified byte in a file.ftell( )Returns the current file position.
fprintf( )Is to a file whatprintf( )is to the console.fscanf( )Is to a file whatscanf( )is to the console.feof( )Returns true if end-of-file is reached.
ferror( )
Returns true if an error has occurred.
rewind( )
Resets the file position indicator to the
beginning of the file.remove( )
Erases a file.fflush( )
Flushes a file.Table9-1.
Commonly Used C File-System FunctionsTheheaderfile
stdio.hand<cstdio>headerprovidetheprototypesfortheI/O
functionsanddefinethesethreetypes:
size_t,fpos_t,and
FILE.The
size_ttypeissome
varietyofunsignedinteger,asis
fpos_t.The
FILEtypeisdiscussedinthenextsection.
Alsodefinedin
stdio.hand<cstdio>areseveralmacros.Theonesrelevanttothis
chapterare
NULL,EOF,FOPEN_MAX,SEEK_SET,SEEK_CUR,and
SEEK_END.TheNULLmacrodefinesanullpointer.The
EOFmacroisgenerallydefinedas
−1andisthevaluereturnedwhenaninputfunctiontriestoreadpasttheendofthefile.
FOPEN_MAXdefinesanintegervaluethatdeterminesthenumberoffilesthatmay
beopenatanyonetime.Theothermacrosareusedwith
fseek( ),whichisthefunction
thatperformsrandomaccessonafile.
The File PointerThefilepointeristhecommonthreadthatunitestheCI/Osystem.A
filepointer
isa
pointertoastructureoftype
FILE.Itpointstoinformationthatdefinesvariousthings
aboutthefile,includingitsname,status,andthecurrentpositionofthefile.Inessence,

thefilepointeridentifiesaspecificfileandisusedbytheassociatedstreamtodirectthe

operationoftheI/Ofunctions.Inordertoreadorwritefiles,yourprogramneedstouse

filepointers.Toobtainafilepointervariable,useastatementlikethis:
FILE *fp;Opening a FileThefopen( )functionopensastreamforuseandlinksafilewiththatstream.Then
itreturnsthefilepointerassociatedwiththatfile.Mostoften(andfortherestofthis

discussion),thefileisadiskfile.The
fopen( )functionhasthisprototype:
FILE *fopen(const char *filename, const char *mode);where
filenameisapointertoastringofcharactersthatmakeupavalidfilenameand
mayincludeapathspecification.Thestringpointedtoby
modedetermineshowthefile
willbeopened.Table9-2showsthelegalvaluesfor
mode.Stringslike"r+b"mayalsobe
representedas"rb+."
Chapter9:FileI/O
215THEFOUNDATIONOFC++:
THECSUBSET
ModeMeaningrOpen a text file for reading.
wCreate a text file for writing.
aAppend to a text file.Table9-2.
The Legal Values for Mode
As stated, thefopen( )function returns a file pointer. Your program should
never alter the value of this pointer. If an error occurs when it is trying to open
the file,fopen( )returns a null pointer.
The following code usesfopen( )to open a file named TEST for output.FILE *fp;fp = fopen("test", "w");While technically correct, you will usually see the preceding code written like this:
FILE *fp;if ((fp = fopen("test","w"))==NULL) {printf("Cannot open file.\n");exit(1);}Thismethodwilldetectanyerrorinopeningafile,suchasawrite-protectedorafull
disk,beforeyourprogramattemptstowritetoit.Ingeneral,youwillalwayswantto

confirmthat
fopen( )succeededbeforeattemptinganyotheroperationsonthefile.
216C++:TheCompleteReference
ModeMeaningrbOpen a binary file for reading.
wbCreate a binary file for writing.
abAppend to a binary file.r+Open a text file for read/write.
w+Create a text file for read/write.
a+Append or create a text file for

read/write.
r+bOpen a binary file for read/write.
w+bCreate a binary file for read/write.
a+bAppend or create a binary file for

read/write.
Table9-2.
The Legal Values for Mode
(continued)Althoughmostofthefilemodesareself-explanatory,afewcommentsareinorder.
If,whenopeningafileforread-onlyoperations,thefiledoesnotexist,
fopen()
willfail.
Whenopeningafileusingappendmode,ifthefiledoesnotexist,itwillbecreated.
Further,whenafileisopenedforappend,allnewdatawrittentothefilewillbewritten

totheendofthefile.Theoriginalcontentswillremainunchanged.If,whenafileis

openedforwriting,thefiledoesnotexist,itwillbecreated.Ifitdoesexist,thecontents

oftheoriginalfilewillbedestroyedandanewfilecreated.Thedifferencebetween

modesr+andw+isthat
r+willnotcreateafileifitdoesnotexist;however,
w+will.Further,ifthefilealreadyexists,openingitwith
w+destroysitscontents;openingit
withr+doesnot.
AsTable9-2shows,afilemaybeopenedineithertextorbinarymode.Inmost
implementations,intextmode,carriagereturn/linefeedsequencesaretranslatedto

newlinecharactersoninput.Onoutput,thereverseoccurs:newlinesaretranslated

tocarriagereturn/linefeeds.Nosuchtranslationsoccuronbinaryfiles.
The number of files that may be open at any one time is specified byFOPEN_MAX.Thisvaluewillusuallybeatleast8,butyoumustcheckyourcompiler’sdocumentation

for its exact value.Closing a FileThefclose( )function closes a stream that was opened by a call to
fopen( ). It writesanydatastillremaininginthediskbuffertothefileanddoesaformaloperating-

system-levelcloseonthefile.Failuretocloseastreaminvitesallkindsoftrouble,

including lost data, destroyed files, and possible intermittent errors in your program.

fclose( )also frees the file control block associated with the stream, making it available
for reuse. There is an operating-system limit to the number of open files you may have

at any one time, so you may have to close one file before opening another.
Thefclose( )function has this prototype:
int fclose(FILE *fp);where
fpisthefilepointerreturnedbythecallto
fopen( ).Areturnvalueofzerosignifies
asuccessfulcloseoperation.Thefunctionreturns
EOFifanerroroccurs.Youcanusethe
standardfunction
ferror()
(discussedshortly)todetermineandreportanyproblems.
Generally,
fclose( )willfailonlywhenadiskhasbeenprematurelyremovedfromthe
driveorthereisnomorespaceonthedisk.
Writing a Character
The C I/O system defines two equivalent functions that output a character:putc( )andfputc( ). (Actually,
putc( )is usually implemented as a macro.) There are two identical
functions simply to preserve compatibility with older versions of C. This book uses

putc( ), but you can usefputc( )if you like.Chapter9:FileI/O
217THEFOUNDATIONOFC++:
THECSUBSET
Theputc( )function writes characters to a file that was previously opened for
writing using thefopen( )function. The prototype of this function is
int putc(intch, FILE *fp);where
fpis the file pointer returned by
fopen( )andchis the character to be output.The file pointer tellsputc( )which file to write to. Althoughchis defined as anint,only the low-order byte is written.
If aputc( )operation is successful, it returns the character written. Otherwise, it
returns
EOF.Reading a CharacterThere are also two equivalent functions that input a character:
getc( )andfgetc( ).Both are defined to preserve compatibility with older versions of C. This book uses
getc( )(which is usually implemented as a macro), but you can use
fgetc( )if you like.Thegetc( )function reads characters from a file opened in read mode by
fopen( ).The prototype of
getc( )isint getc(FILE *fp);where
fpis a file pointer of typeFILEreturned by
fopen( ).getc( )returns an integer,
but the character is contained in the low-order byte. Unless an error occurs, the high-

order byte is zero.
Thegetc( )function returns an
EOFwhen the end of the file has been reached.
Therefore, to read to the end of a text file, you could use the following code:
do {ch = getc(fp);} while(ch!=EOF);However,
getc( )also returns
EOFif an error occurs. You can use
ferror( )to determineprecisely what has occurred.
Using fopen( ), getc( ), putc( ), and fclose( )The functionsfopen( ),getc( ),putc( ), andfclose( )constitute the minimal set of fileroutines. The following program, KTOD, is a simple example of using
putc( ),fopen( ),andfclose( ). It reads characters from the keyboard and writes them to a disk file until
theusertypesadollarsign.Thefilenameisspecifiedfromthecommandline.Forexample,

if you call this program KTOD, typing
KTOD TESTallows you to enter lines of textinto the file called TEST.
218C++:TheCompleteReference
/* KTOD: A key to disk program. */#include <stdio.h>
#include <stdlib.h>int main(int argc, char *argv[]){FILE *fp;char ch;if(argc!=2) {printf("You forgot to enter the filename.\n");exit(1);}if((fp=fopen(argv[1], "w"))==NULL) {printf("Cannot open file.\n");exit(1);}do {ch = getchar();putc(ch, fp);} while (ch != '$');fclose(fp);
return 0;}The complementary program DTOS reads any text file and displays the contents on
the screen. It demonstrates
getc( )./* DTOS: A program that reads files and displays themon the screen. */#include <stdio.h>#include <stdlib.h>int main(int argc, char *argv[]){FILE *fp;
char ch;Chapter9:FileI/O
219THEFOUNDATIONOFC++:
THECSUBSET
if(argc!=2) {printf("You forgot to enter the filename.\n");exit(1);}if((fp=fopen(argv[1], "r"))==NULL) {printf("Cannot open file.\n");exit(1);}ch = getc(fp);   /* read one character */
while (ch!=EOF) {putchar(ch);  /* print on screen */ch = getc(fp);}fclose(fp);
return 0;}To try these two programs, first use KTOD to create a text file. Then read its
contents using DTOS.
Using feof( )As just described,getc( )returns
EOFwhen the end of the file has been encountered.
However, testing the value returned by
getc( )may not be the best way to determinewhen you have arrived at the end of a file. First, the file system can operate on bothtext and binary files. When a file is opened for binary input, an integer value that will
testequalto
EOFmayberead.Thiswouldcausetheinputroutinetoindicateanend-of-file
condition even though the physical end of the file had not been reached. Second,
getc( )returns
EOFwhen it fails and when it reaches the end of the file. Using only the return
value ofgetc( ), it is impossible to know which occurred. To solve these problems, the
C file system includes the functionfeof( ), which determines when the end of the filehas been encountered. The
feof( )function has this prototype:
int feof(FILE *fp);feof()
returnstrueiftheendofthefilehasbeenreached;otherwise,itreturns0.Therefore,
the following routine reads a binary file until the end of the file is encountered:
220C++:TheCompleteReference
while(!feof(fp)) ch = getc(fp);Of course, you can apply this method to text files as well as binary files.The following program, which copies text or binary files, contains an example of
feof( ). The files are opened in binary mode and
feof( )checks for the end of the file./* Copy a file. */#include <stdio.h>
#include <stdlib.h>int main(int argc, char *argv[]){FILE *in, *out;
char ch;if(argc!=3) {printf("You forgot to enter a filename.\n");exit(1);}if((in=fopen(argv[1], "rb"))==NULL) {printf("Cannot open source file.\n");exit(1);}
if((out=fopen(argv[2], "wb")) == NULL) {printf("Cannot open destination file.\n");
exit(1);}/* This code actually copies the file. */while(!feof(in)) {ch = getc(in);
if(!feof(in)) putc(ch, out);}fclose(in);fclose(out);return 0;}Chapter9:FileI/O
221THEFOUNDATIONOFC++:
THECSUBSET
222C++:TheCompleteReference
Working with Strings: fputs( ) and fgets( )
In addition togetc( )andputc( ), the C file system supports the related functions
fgets( )andfputs( ), which read and write character strings from and to a disk file.
These functions work just likeputc( )andgetc( ), but instead of reading or writing
a single character, they read or write strings. They have the following prototypes:
int fputs(const char *str, FILE *fp);char *fgets(char *str, intlength, FILE *fp);Thefputs( )function writes the string pointed to bystrto the specified stream.
It returns
EOFif an error occurs.
Thefgets( )functionreadsastringfromthespecifiedstreamuntileitheranewline
characterisreador
length−1charactershavebeenread.Ifanewlineisread,itwillbepart
ofthestring(unlikethe
gets( )function).Theresultantstringwillbenullterminated.The
functionreturns
strifsuccessfulandanullpointerifanerroroccurs.
The following program demonstrates
fputs( ).It reads strings from the keyboard
and writes them to the file called TEST. To terminate the program, enter a blank line.

Sincegets( )does not store the newline character, one is added before each string is
written to the file so that the file can be read more easily.
#include <stdio.h>#include <stdlib.h>
#include <string.h>int main(void){char str[80];
FILE *fp;if((fp = fopen("TEST", "w"))==NULL) {printf("Cannot open file.\n");exit(1);}do {printf("Enter a string (CR to quit):\n");gets(str);
strcat(str, "\n");  /* add a newline */
fputs(str, fp);} while(*str!='\n');return 0;}Chapter9:FileI/O
223THEFOUNDATIONOFC++:
THECSUBSET
rewind( )
Therewind( )function resets the file position indicator to the beginning of the file
specified as its argument. That is, it "rewinds" the file. Its prototype is
void rewind(FILE *fp);where
fpis a valid file pointer.
To see an example of
rewind( ), you can modify the program from the previous
section so that it displays the contents of the file just created. To accomplish this, the
program rewinds the file after input is complete and then uses
fgets( )to read back
thefile.Noticethatthefilemustnowbeopenedinread/writemodeusing"
w+"for the mode parameter.
#include <stdio.h>#include <stdlib.h>
#include <string.h>int main(void){char str[80];
FILE *fp;if((fp = fopen("TEST", "w+"))==NULL) {printf("Cannot open file.\n");exit(1);}do {printf("Enter a string (CR to quit):\n");gets(str);
strcat(str, "\n");  /* add a newline */
fputs(str, fp);} while(*str!='\n');/* now, read and display the file */rewind(fp);  /* reset file position indicator tostart of the file. */while(!feof(fp)) {fgets(str, 79, fp);
printf(str);}224C++:TheCompleteReference
return 0;}ferror( )
Theferror( )function determines whether a file operation has produced an error. The
ferror( )function has this prototype:
int ferror(FILE *fp);where
fpis a valid file pointer. It returns true if an error has occurred during the last
file operation; otherwise, it returns false. Because each file operation sets the error
condition,ferror( )should be called immediately after each file operation; otherwise,an error may be lost.
The following program illustrates
ferror( )by removing tabs from a file and
substituting the appropriate number of spaces. The tab size is defined by
TAB_SIZE
.Notice howferror( )is called after each file operation. To use the program, specify the
names of the input and output files on the command line./* The program substitutes spaces for tabsin a text file and supplies error checking. */#include <stdio.h>#include <stdlib.h>#define TAB_SIZE 8#define IN 0
#define OUT 1void err(int e);
int main(int argc, char *argv[]){FILE *in, *out;
int tab, i;
char ch;if(argc!=3) {printf("usage: detab <in> <out>\n");exit(1);}if((in = fopen(argv[1], "rb"))==NULL) {printf("Cannot open %s.\n", argv[1]);exit(1);}if((out = fopen(argv[2], "wb"))==NULL) {printf("Cannot open %s.\n", argv[1]);exit(1);}tab = 0;do {ch = getc(in);
if(ferror(in)) err(IN);/* if tab found, output appropriate number of spaces */if(ch=='\t') {for(i=tab; i<8; i++) {putc(' ', out);
if(ferror(out)) err(OUT);}
tab = 0;}
else {putc(ch, out);
if(ferror(out)) err(OUT);
tab++;
if(tab==TAB_SIZE) tab = 0;
if(ch=='\n' || ch=='\r') tab = 0;}} while(!feof(in));
fclose(in);
fclose(out);return 0;}
void err(int e){if(e==IN) printf("Error on input.\n");
else printf("Error on output.\n");
exit(1);}Chapter9:FileI/O
225THEFOUNDATIONOFC++:
THECSUBSET
Erasing FilesTheremove( )function erases the specified file. Its prototype is
int remove(const char *filename);It returns zero if successful; otherwise, it returns a nonzero value.
The following program erases the file specified on the command line. However, it
first gives you a chance to change your mind. Autility like this might be useful to new
computer users./* Double check before erasing. */#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>int main(int argc, char *argv[]){char str[80];if(argc!=2) {printf("usage: xerase <filename>\n");exit(1);}printf("Erase %s? (Y/N): ", argv[1]);gets(str);if(toupper(*str)=='Y')if(remove(argv[1])) {printf("Cannot erase file.\n");exit(1);}return 0;}Flushing a Stream
If you wish to flush the contents of an output stream, use the
fflush( )
function, whoseprototype is shown here:
int fflush(FILE *fp);226C++:TheCompleteReference
Chapter9:FileI/O
227THEFOUNDATIONOFC++:
THECSUBSET
This function writes the contents of any buffered data to the file associated with
fp.If you callfflush( )
withfpbeing null, all files opened for output are flushed.
Thefflush( )
function returns 0 if successful; otherwise, it returns
EOF.fread( ) and fwrite( )
Toreadandwritedatatypesthatarelongerthanonebyte,theCfilesystemprovides
twofunctions:
fread( )andfwrite( ).Thesefunctionsallowthereadingandwriting
ofblocksofanytypeofdata.Theirprototypesare
size_t fread(void *buffer, size_tnum_bytes, size_tcount, FILE *fp);size_t fwrite(const void *buffer, size_tnum_bytes, size_tcount, FILE *fp);Forfread( ),bufferisapointertoaregionofmemorythatwillreceivethedatafrom
thefile.For
fwrite( ),bufferisapointertotheinformationthatwillbewrittentothe
file.Thevalueof
countdetermineshowmanyitemsarereadorwritten,witheach
itembeing
num_bytesbytesinlength.(Remember,thetype
size_tisdefinedassome
typeofunsignedinteger.)Finally,
fpisafilepointertoapreviouslyopenedstream.
Thefread( )function returns the number of items read. This value may be less than
countif the end of the file is reached or an error occurs. The
fwrite( )function returns
the number of items written. This value will equalcountunless an error occurs.
Using fread( ) and fwrite( )
Aslongasthefilehasbeenopenedforbinarydata,
fread( )andfwrite( )canread
andwriteanytypeofinformation.Forexample,thefollowingprogramwritesand

thenreadsbacka
double,an
int,anda
longtoandfromadiskfile.Noticehowit
usessizeoftodeterminethelengthofeachdatatype.
/* Write some non-character data to a disk fileand read it back.  */#include <stdio.h>#include <stdlib.h>int main(void){FILE *fp;
double d = 12.23;
int i = 101;
long l = 123023L;if((fp=fopen("test", "wb+"))==NULL) {printf("Cannot open file.\n");exit(1);}fwrite(&d, sizeof(double), 1, fp);fwrite(&i, sizeof(int), 1, fp);
fwrite(&l, sizeof(long), 1, fp);rewind(fp);
fread(&d, sizeof(double), 1, fp);fread(&i, sizeof(int), 1, fp);
fread(&l, sizeof(long), 1, fp);printf("%f %d %ld", d, i, l);
fclose(fp);
return 0;}As this program illustrates, the buffer can be (and often is) merely the memory used to
hold a variable. In this simple program, the return values of
fread( )andfwrite( )are
ignored. In the real world, however, you should check their return values for errors.
One of the most useful applications offread( )andfwrite( )involves reading
and writing user-defined data types, especially structures. For example, given this

structure:
struct struct_type {float balance;char name[80];} cust;the following statement writes the contents ofcustto the file pointed to byfp.fwrite(&cust, sizeof(struct struct_type), 1, fp);228C++:TheCompleteReference
Chapter9:FileI/O
229THEFOUNDATIONOFC++:
THECSUBSET
fseek( ) and Random-Access I/OYoucanperformrandom-accessreadandwriteoperationsusingtheCI/Osystemwith
thehelpof
fseek()
,whichsetsthefilepositionindicator.Itsprototypeisshownhere:
int fseek(FILE *fp, long intnumbytes, intorigin);Here,
fpis a file pointer returned by a call to
fopen( ).numbytesis the number of bytesfrom
originthat will become the new current position, and
originis one of the followingmacros:
OriginMacro Name
Beginning of fileSEEK_SETCurrent position
SEEK_CUREnd of fileSEEK_ENDTherefore, to seek
numbytesfrom the start of the file,
originshould beSEEK_SET. To
seek from the current position, use
SEEK_CUR;and to seek from the end of the file,
useSEEK_END. Thefseek( )function returns 0 when successful and a nonzero value
if an error occurs.
The following program illustrates
fseek( ). It seeks to and displays the specifiedbyte in the specified file. Specify the filename and then the byte to seek to on the
command line.#include <stdio.h>#include <stdlib.h>int main(int argc, char *argv[]){FILE *fp;if(argc!=3) {printf("Usage: SEEK filename byte\n");exit(1);}if((fp = fopen(argv[1], "rb"))==NULL) {printf("Cannot open file.\n");exit(1);}if(fseek(fp, atol(argv[2]), SEEK_SET)) {printf("Seek error.\n");exit(1);}printf("Byte at %ld is %c.\n", atol(argv[2]), getc(fp));fclose(fp);return 0;}You can use
fseek( )to seek in multiples of any type of data by simply multiplyingthe size of the data by the number of the item you want to reach. For example, assume
that you have a mailing list that consists of structures of type
list_type.To seek to the
tenth address in the file that holds the addresses, use this statement:
fseek(fp, 9*sizeof(struct list_type), SEEK_SET);You can determine the current location of a file using
ftell( ). Its prototype is
long int ftell(FILE *fp);It returns the location of the current position of the file associated with
fp. If a failure
occurs, it returns
−1.In general, you will want to use random access only on binary files. The reason
for this is simple. Because text files may have character translations performed on
them, there may not be a direct correspondence between what is in the file and the

byte to which it would appear that you want to seek. The only time you should use
fseek( )with a text file is when seeking to a position previously determined by
ftell( ),usingSEEK_SETas the origin.Rememberoneimportantpoint:Evenafilethatcontainsonlytextcanbeopened
asabinaryfile,ifyoulike.Thereisnoinherentrestrictionaboutrandomaccessonfiles

containingtext.Therestrictionappliesonlytofilesopenedastextfiles.
fprintf( ) and fscanf( )In addition to the basic I/O functions already discussed, the C I/O system includes

fprintf( )andfscanf( ). These functions behave exactly likeprintf( )andscanf( )except that they operate with files. The prototypes of
fprintf( )andfscanf( )are
230C++:TheCompleteReference
int fprintf(FILE *fp, const char *control_string,. . .);int fscanf(FILE *fp, const char *control_string,. . .);where
fpis a file pointer returned by a call to
fopen( ).fprintf( )andfscanf( )direct
their I/O operations to the file pointed to byfp.Asanexample,thefollowingprogramreadsastringandanintegerfromthekeyboard
and writes them to a disk file called TEST. The program then reads the file and displays

the information on the screen. After running this program, examine the TEST file. As

you will see, it contains human-readable text.
/* fscanf() - fprintf() example */#include <stdio.h>
#include <io.h>
#include <stdlib.h>int main(void){FILE *fp;
char s[80];
int t;if((fp=fopen("test", "w")) == NULL) {printf("Cannot open file.\n");exit(1);}printf("Enter a string and a number: ");fscanf(stdin, "%s%d", s, &t); /* read from keyboard */fprintf(fp, "%s %d", s, t); /* write to file */fclose(fp);if((fp=fopen("test","r")) == NULL) {printf("Cannot open file.\n");exit(1);}fscanf(fp, "%s%d", s, &t); /* read from file */fprintf(stdout, "%s %d", s, t); /* print on screen */return 0;}Chapter9:FileI/O
231THEFOUNDATIONOFC++:
THECSUBSET
Aword of warning: Although
fprintf( )andfscanf( )often are the easiest way to
writeandreadassorteddatatodiskfiles,theyarenotalwaysthemostefficient.
BecauseformattedASCIIdataisbeingwrittenasitwouldappearonthescreen

(instead of in binary), extra overhead is incurred with each call. So, if speed or file size

is a concern, you should probably use
fread( )andfwrite( ).The Standard Streams
As it relates to the C file system, when a program starts execution, three streams are

opened automatically. They are
stdin(standard input),
stdout (standard output), and
stderr(standard error). Normally, these streams refer to the console, but they may be
redirected by the operating system to some other device in environments that support

redirectable I/O. (Redirectable I/O is supported by Windows, DOS, Unix, and OS/2,

for example.)Because the standard streams are file pointers, they may be used by the C I/O
system to perform I/O operations on the console. For example,putchar( )could bedefined like this:int putchar(char c){return putc(c, stdout);}In general,stdinis used to read from the console, and
stdoutandstderrare used to
write to the console.You may use
stdin,stdout, andstderras file pointers in any function that uses avariable of typeFILE *. For example, you could usefgets( )to input a string from the
console using a call like this:char str[255];
fgets(str, 80, stdin);In fact, usingfgets( )in this manner can be quite useful. As mentioned earlier in thisbook, when usinggets( )it is possible to overrun the array that is being used to receive
the characters entered by the user because
gets( )provides no bounds checking. When
used withstdin, thefgets( )function offers a useful alternative because it can limit the
number of characters read and thus prevent array overruns. The only trouble is that
fgets( )does not remove the newline character and
gets( )does, so you will have tomanually remove it, as shown in the following program.
232C++:TheCompleteReference
Chapter9:FileI/O
233THEFOUNDATIONOFC++:
THECSUBSET
#include <stdio.h>#include <string.h>int main(void){char str[80];int i;printf("Enter a string: ");fgets(str, 10, stdin);/* remove newline, if present */i = strlen(str)-1;
if(str[i]=='\n') str[i] = '\0';printf("This is your string: %s", str);
return 0;}Keep in mind thatstdin,stdout, andstderrare not variables in the normal sense
and may not be assigned a value usingfopen( ). Also, just as these file pointers are
created automatically at the start of your program, they are closed automatically at
the end; you should not try to close them.The Console I/O ConnectionThereisactuallylittledistinctionbetweenconsoleI/OandfileI/O.TheconsoleI/O

functionsdescribedinChapter8actuallydirecttheirI/Ooperationstoeither
stdinorstdout.Inessence,theconsoleI/Ofunctionsaresimplyspecialversionsoftheirparallel

filefunctions.Thereasontheyexistisasaconveniencetoyou,theprogrammer.
As described in the previous section, you can perform console I/O using any of the
file system functions. However, what might surprise you is that you can perform disk

file I/O using console I/O functions, such asprintf( )! This is because all of the consoleI/Ofunctionsoperateon
stdinandstdout.Inenvironmentsthatallowredirection
of I/O, this means thatstdinandstdoutcould refer to a device other than the keyboard
and screen. For example, consider this program:
#include <stdio.h>234C++:TheCompleteReference
int main(void){char str[80];printf("Enter a string: ");gets(str);
printf(str);return 0;}AssumethatthisprogramiscalledTEST.IfyouexecuteTESTnormally,itdisplaysits
promptonthescreen,readsastringfromthekeyboard,anddisplaysthatstringonthe
display.However,inanenvironmentthatsupportsI/Oredirection,either
stdin,stdout,orbothcouldberedirectedtoafile.Forexample,inaDOSorWindowsenvironment,

executingTESTlikethis:
TEST > OUTPUTcauses the output of TEST to be written to a file called OUTPUT. Executing TEST

like this:TEST < INPUT > OUTPUTdirects
stdinto the file called INPUT and sends output to the file called OUTPUT.
When a program terminates, any redirected streams are reset to their default status.
Using freopen( ) to Redirect the Standard Streams
You can redirect the standard streams by using the
freopen( )function. This functionassociatesanexistingstreamwithanewfile.Thus,youcanuseittoassociateastandard

stream with a new file. Its prototype is
FILE *freopen(const char *filename, const char *mode, FILE *stream);where
filenameisapointertothefilenameyouwishassociatedwiththestream
pointedtoby
stream
.Thefileisopenedusingthevalueof
mode,whichmayhave
thesamevaluesasthoseusedwith
fopen( ).freopen( )returns
stream
ifsuccessful
orNULLonfailure.
The following program uses
freopen( )to redirect
stdoutto a file called OUTPUT:
#include <stdio.h>int main(void){char str[80];freopen("OUTPUT", "w", stdout);
printf("Enter a string: ");gets(str);
printf(str);return 0;}In general, redirecting the standard streams by using
freopen( )is useful in specialsituations, such as debugging. However, performing disk I/O using redirected
stdinandstdoutis not as efficient as using functions like
fread( )orfwrite( ).Chapter9:FileI/O
235THEFOUNDATIONOFC++:
THECSUBSET
This page intentionally left blank Chapter10
The Preprocessorand Comments237Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
You can include various instructions to the compiler in the source code of aC/C++ program. These are calledpreprocessordirectives
, and although notactually part of the C or C++ language per se, they expand the scope of theprogramming environment. This chapter also examines comments.The Preprocessor
Before beginning, it is important to put the preprocessor in historical perspective.

As it relates to C++, the preprocessor is largely a holdover from C. Moreover, the

C++ preprocessor is virtually identical to the one defined by C. The main difference

betweenCandC++inthisregardisthedegreetowhicheachreliesuponthe

preprocessor. In C, each preprocessor directive is necessary. In C++, some features

have been rendered redundant by newer and better C++ language elements. In fact,

oneofthelong-termdesigngoalsofC++istheeliminationofthepreprocessor

altogether. But for now and well into the foreseeable future, the preprocessor will

still be widely used.The preprocessor contains the following directives:
#define#elif#else
#endif#error#if#ifdef#ifndef
#include#line#pragma#undef
As you can see, all preprocessor directives begin with a # sign. In addition, each
preprocessing directive must be on its own line. For example,
#include <stdio.h>  #include <stdlib.h>will not work.#defineThe#definedirective defines an identifier and a character sequence (i.e., a set of
characters) that will be substituted for the identifier each time it is encountered in the
source file. The identifier is referred to as a
macro name
and the replacement process as
macro replacement
. The general form of the directive is
#definemacro-name char-sequenceNotice that there is no semicolon in this statement. There may be any number of spaces

between the identifier and the character sequence, but once the character sequence
begins, it is terminated only by a newline.238C++:TheCompleteReference
Chapter10:ThePreprocessorandComments
239THEFOUNDATIONOFC++:
THECSUBSET
Forexample,ifyouwishtousetheword
LEFTforthevalue1andtheword
RIGHTfor the value 0, you could declare these two #
definedirectives:
#define LEFT 1#define RIGHT 0Thiscausesthecompilertosubstitut
ea1ora0
eachtime
LEFTorRIGHTisencountered
in your source file. For example, the following prints
0 1 2on the screen:
printf("%d %d %d", RIGHT, LEFT, LEFT+1);Onceamacronamehasbeendefined,itmaybeusedaspartofthedefinitionofother
macronames.Forexample,thiscodedefinesthevaluesof
ONE,TWO,and
THREE:#define ONE    1
#define TWO    ONE+ONE
#define THREE  ONE+TWOMacro substitution is simply the replacement of an identifier by the character
sequence associated with it. Therefore, if you wish to define a standard error message,
you might write something like this:#define E_MS "standard error on input\n"/* ... */
printf(E_MS);The compiler will actually substitute the string "standard error on input\n" when the
identifierE_MSis encountered. To the compiler, the
printf( )statement will actuallyappear to beprintf("standard error on input\n");No text substitutions occur if the identifier is within a quoted string. For example,#define XYZ this is a testprintf("XYZ");does not printthis is a test, but ratherXYZ.240C++:TheCompleteReference
If the character sequence is longer than one line, you may continue it on the next byplacing a backslash at the end of the line, as shown here:
#define LONG_STRING "this is a very long \string that is used as an example"C/C++programmerscommonlyuseuppercaselettersfordefinedidentifiers.
Thisconventionhelpsanyonereadingtheprogramknowataglancethatamacro
replacement will take place. Also, it is usually best to put all
#definesat the start of thefile or in a separate header file rather than sprinkling them throughout the program.
Macros are most frequently used to define names for "magic numbers" that occur
inaprogram.Forexample,youmayhaveaprogramthatdefinesanarrayandhas

severalroutinesthataccessthatarray.Insteadof"hard-coding"thearray'ssizewitha

constant,youcandefinethesizeusinga
#definestatementandthenusethatmacro
namewheneverthearraysizeisneeded.Inthisway,ifyouneedtochangethesize

ofthearray,youwillonlyneedtochangethe
#definestatementandthenrecompile
your program. For example,
#define MAX_SIZE 100/* ... */
float balance[MAX_SIZE];
/* ... */
for(i=0; i<MAX_SIZE; i++) printf("%f", balance[i]);
/* ... */
for(i=0; i<MAX_SIZE; i++) x =+ balance[i];SinceMAX_SIZEdefines the size of the arraybalance,if the size ofbalanceneedsto be changed in the future, you need only change the definition of
MAX_SIZE.Allsubsequent references to it will be automatically updated when you recompile
your program.
C++ provides a better way of defining constants, which uses the
constkeyword.This is described in Part Two.
Defining Function-like Macros
The#definedirectivehasanotherpowerfulfeature:themacronamecanhavearguments.
Eachtimethemacronameisencountered,theargumentsusedinitsdefinitionare

replaced by the actual arguments found in the program. This form of a macro is called

afunction-like macro.
For example,#include <stdio.h>#define ABS(a)  (a)<0 ? -(a) : (a)
int main(void){printf("abs of -1 and 1: %d %d", ABS(-1), ABS(1));return 0;}When this program is compiled,
ain the macro definition will be substituted with
the values –1 and 1. The parentheses that enclose
aensure proper substitution in all
cases. For example, if the parentheses around
awere removed, this expression
ABS(10-20)would be converted to10-20<0 ? -10-20 : 10-20after macro replacement and would yield the wrong result.
The use of a function-like macro in place of real functions has one major benefit: It
increases the execution speed of the code because there is no function call overhead.
However, if the size of the function-like macro is very large, this increased speed may

be paid for with an increase in the size of the program because of duplicated code.
Although parameterized macros are a valuable feature, C++ has a better way of creating

inline code, which uses theinlinekeyword.#error
The#errordirective forces the compiler to stop compilation. It is used primarily for
debugging. The general form of the#errordirective is
#errorerror-messageTheerror-message
isnotbetweendoublequotes.Whenthe
#errordirectiveisencountered,
the error message is displayed, possibly along with other information defined by the

compiler.
THEFOUNDATIONOFC++:
THECSUBSET
Chapter10:ThePreprocessorandComments
241#includeThe#includedirective instructs the compiler to read another source file in addition
to the one that contains the#includedirective. The name of the additional source file
must be enclosed between double quotes or angle brackets. For example,#include "stdio.h"#include <stdio.h>both instruct the compiler to read and compile the header for the C I/O system library
functions.Includefilescanhave
#includedirectivesinthem.Thisisreferredtoas
nestedincludes.The number of levels of nesting allowed varies between compilers. However,

Standard C stipulates that at least eight nested inclusions will be available. Standard

C++ recommends that at least 256 levels of nesting be supported.
Whether the filename is enclosed by quotes or by angle brackets determineshow the search for the specified file is conducted. If the filename is enclosed in angle

brackets, the file is searched for in a manner defined by the creator of the compiler.

Often, this means searching some special directory set aside for include files. If the

filename is enclosed in quotes, the file is looked for in another implementation-defined
manner. For many compilers, this means searching the current working directory. If

the file is not found, the search is repeated as if the filename had been enclosed in

angle brackets.Typically, most programmers use angle brackets to include the standard header
files. The use of quotes is generally reserved for including files specifically related to

the program at hand. However, there is no hard and fast rule that demands this usage.
In addition tofiles, a C++ program can use the
#includedirective to include a C++
header. C++ defines a set of standard headers that provide the information necessary
to the various C++ libraries. Aheader is a standard identifier that might, but need

not, map to a filename. Thus, a header is simply an abstraction that guarantees that
the appropriate information required by your program is included. Various issues

associated with headers are described in Part Two.
Conditional Compilation Directives
There are several directives that allow you to selectively compile portions of your

program's source code. This process is called
conditional compilationand is used widelyby commercial software houses that provide and maintain many customized versions

of one program.
242C++:TheCompleteReference
Chapter10:ThePreprocessorandComments
243THEFOUNDATIONOFC++:
THECSUBSET
#if, #else, #elif, and #endifPerhaps the most commonly used conditional compilation directives are the
#if,#else,#elif, and#endif. These directives allow you to conditionally include portions of code
based upon the outcome of a constant expression.
The general form of#ifis#ifconstant-expressionstatement sequence#endifIf the constant expression following
#ifis true, the code that is between it and
#endifiscompiled. Otherwise, the intervening code is skipped. The#endifdirective marks the
end of an#ifblock. For example,/* Simple #if example. */#include <stdio.h>#define MAX 100
int main(void){
#if MAX>99printf("Compiled for array greater than 99.\n");#endifreturn 0;}This program displays the message on the screen because
MAXis greater than 99.
Thisexampleillustratesanimportantpoint.Theexpressionthatfollowsthe
#ifisevaluatedatcompiletime.Therefore,itmustcontainonlypreviouslydefinedidentifiers
and constants—no variables may be used.The#elsedirective works much like the
elsethat is part of the C++ language: itestablishes an alternative if#iffails. The previous example can be expanded as
shown here:
/* Simple #if/#else example. */#include <stdio.h>244C++:TheCompleteReference
#define MAX 10int main(void){
#if MAX>99printf("Compiled for array greater than 99.\n");#elseprintf("Compiled for small array.\n");#endifreturn 0;}In this case,MAXis defined to be less than 99, so the#ifportion of the code is notcompiled. The#elsealternative is compiled, however, and the message
Compiled forsmall arrayis displayed.Notice that#elseis used to mark both the end of the#ifblock and the beginning ofthe#elseblock. This is necessary because there can only be one
#endifassociated withany#if.The#elifdirective means "else if" and establishes an if-else-if chain for multiple
compilation options.#elifis followed by a constant expression. If the expression is true,
that block of code is compiled and no other#elifexpressions are tested. Otherwise, the
next block in the series is checked. The general form for#elifis#ifexpressionstatement sequence#elifexpression 1statement sequence#elifexpression 2statement sequence#elifexpression 3statement sequence#elifexpression 4..
.
#elifexpression Nstatement sequence#endifChapter10:ThePreprocessorandComments
245THEFOUNDATIONOFC++:
THECSUBSET
For example, the following fragment uses the value ofACTIVE_COUNTRY
todefine the currency sign:
#define US 0#define ENGLAND 1
#define JAPAN 2#define ACTIVE_COUNTRY US
#if ACTIVE_COUNTRY == USchar currency[] = "dollar";#elif ACTIVE_COUNTRY == ENGLANDchar currency[] = "pound";#elsechar currency[] = "yen";#endifStandard C states that
#ifs and#elifs may be nested at least eight levels. Standard
C++ suggests that at least 256 levels of nesting be allowed. When nested, each#endif,#else, or#elifassociates with the nearest
#ifor#elif. For example, the following isperfectly valid:#if MAX>100#if SERIAL_VERSIONint port=198;#elifint port=200;#endif#elsechar out_buffer[100];#endif#ifdef and #ifndefAnothermethodofconditionalcompilationusesthedirectives
#ifdefand#ifndef,which
mean "if defined" and "if not defined," respectively. The general form of
#ifdefis#ifdefmacro-namestatement sequence#endifIfmacro-name
has been previously defined in a
#definestatement, the block of code willbe compiled.The general form of#ifndefis#ifndefmacro-namestatement sequence#endifIfmacro-name
is currently undefined by a
#definestatement, the block of code iscompiled.Both#ifdefand#ifndefmay use an#elseor#elifstatement. For example,#include <stdio.h>#define TED 10
int main(void){
#ifdef TEDprintf("Hi Ted\n");#elseprintf("Hi anyone\n");#endif
#ifndef RALPHprintf("RALPH not defined\n");#endifreturn 0;}will printHi Ted
andRALPH not defined. However, if
TEDwere not defined,
Hianyonewould be displayed, followed byRALPH not defined.You may nest
#ifdefs and#ifndefsto at least eight levels in Standard C.Standard
C++ suggests that at least 256 levels of nesting be supported.#undefThe#undefdirective removes a previously defined definition of the macro name that
follows it. That is, it "undefines" a macro. The general form for
#undefis#undefmacro-name246C++:TheCompleteReference
For example,#define LEN 100#define WIDTH 100char array[LEN][WIDTH];
#undef LEN#undef WIDTH
/* at this point both LEN and WIDTH are undefined */BothLENandWIDTHare defined until the
#undefstatements are encountered.
#undefis used principally to allow macro names to be localized to only those
sections of code that need them.Using definedIn addition to#ifdef, there is a second way to determine if a macro name is defined.
You can use the
#ifdirective in conjunction with the
definedcompile-time operator.
Thedefinedoperator has this general form:definedmacro-nameIfmacro-name
is currently defined, then the expression is true. Otherwise, it is false. For
example, to determine if the macro
MYFILEis defined, you can use either of these twopreprocessing commands:
#if defined MYFILEor#ifdef MYFILEYou may also precede
definedwith the!to reverse the condition. For example, the
following fragment is compiled only ifDEBUGis not defined.#if !defined DEBUGprintf("Final version!\n");#endifChapter10:ThePreprocessorandComments
247THEFOUNDATIONOFC++:
THECSUBSET
One reason for using
definedis that it allows the existence of a macro name to be
determined by a#elifstatement.#lineThe#linedirective changes the contents of _ _
LINE_ _and_ _FILE_ _ ,which are
predefined identifiers in the compiler. The
_ _LINE_ _identifier contains the linenumber of the currently compiled line of code. The
_ _FILE_ _identifier is a stringthatcontainsthenameofthesourcefilebeingcompiled.Thegeneralformfor
#lineis#linenumber"filename"where
numberis any positive integer and becomes the new value of_ _LINE_ _ ,and the optionalfilenameis any valid file identifier, which becomes the new value
of_ _FILE_ _. #lineis primarily used for debugging and special applications.For example, the following code specifies that the line count will begin with 100.Theprintf( )statement displays the number 102 because it is the third line in the
program after the
#line 100statement.#include <stdio.h>#line 100                  /* reset the line counter */int main(void)             /* line 100 */
{                          /* line 101 */printf("%d\n",__LINE__); /* line 102 */return 0;}#pragma#pragmais an implementation-defined directive that allows various instructions to
be given to the compiler. For example, a compiler may have an option that supports
program execution tracing. Atrace option would then be specified by a
#pragmastatement. You must check the compiler's documentation for details and options.
The # and ## Preprocessor Operators
There are two preprocessor operators:
#and##.These operators are used with the
#definestatement.248C++:TheCompleteReference
The#operator, which is generally called the
stringizeoperator, turns the argument
it precedes into a quoted string. For example, consider this program.
#include <stdio.h>#define mkstr(s)  # s
int main(void){printf(mkstr(I like C++));return 0;}The preprocessor turns the line
printf(mkstr(I like C++));intoprintf("I like C++");The ## operator, called the
pastingoperator, concatenates two tokens. For example,
#include <stdio.h>
#define concat(a, b)  a ## b
int main(void){int xy = 10;printf("%d", concat(x, y));
return 0;}The preprocessor transforms
printf("%d", concat(x, y));Chapter10:ThePreprocessorandComments
249THEFOUNDATIONOFC++:
THECSUBSET
250C++:TheCompleteReference
intoprintf("%d", xy);If these operators seem strange to you, keep in mind that they are not needed or
used in most programs. They exist primarily to allow the preprocessor to handle some
special cases.Predefined Macro Names
C++ specifies six built-in predefined macro names. They are
_ _LINE_ _
_ _FILE_ _
_ _DATE_ _
_ _TIME_ _
_ _STDC_ _
_ _cplusplusThe C language defines the first five of these. Each will be described here, in turn.
The_ _LINE_ _and_ _FILE_ _macros were described in the discussion of
#line.Briefly, they contain the current line number and filename of the program when it is

being compiled.The_ _DATE_ _
macro contains a string of the form
month/day/yearthat is the dateof the translation of the source file into object code.
The_ _TIME_ _macro contains the time at which the program was compiled. The
time is represented in a string having the form
hour:minute:second.The meaning of_ _STDC_ _is implementation-defined. Generally, if
_ _STDC_ _isdefined, the compiler will accept only standard C/C++ code that does not contain any

nonstandard extensions.
Acompiler conforming to Standard C++ will define
_ _cplusplusas a valuecontaining at least six digits. Nonconforming compilers will use a value with five or
less digits.CommentsC89 defines only one style of comment, which begins with the character pair/*andends with*/.There must be no spaces between the asterisk and the slash. The compiler
Chapter10:ThePreprocessorandComments
251THEFOUNDATIONOFC++:
THECSUBSET
ignores any text between the beginning and ending comment symbols. For example,
this program prints only
helloon the screen:
#include <stdio.h>int main(void){printf("hello");
/* printf("there"); */return 0;}This style of comment is commonly called amultilinecomment
because the text ofthe comment may extend over two or more lines. For example,
/* this is amulti-line
comment */Comments may be placed anywhere in a program, as long as they do not appear in
the middle of a keyword or identifier. For example, this comment is valid:
x = 10+ /* add the numbers */5;whileswi/*this will not work*/tch(c) { ...is incorrect because a keyword cannot contain a comment. However, you should not
generally place comments in the middle of expressions because it obscures their

meaning.Multiline comments may not be nested. That is, one comment may not containanother comment. For example, this code fragment causes a compile-time error:
/* this is an outer commentx = y/a;/* this is an inner comment - and causes an error */*/Single-Line CommentsC++ (and C99) supports two types of comments. The first is the multiline comment.The second is thesingle-line comment. Single-line comments begin with a//and endat the end of the line. For example,// this is a single-line commentSingle line comments are especially useful when short, line-by-line descriptions are

needed. Although they are not technically supported by C89, many C compilers will

accept them anyway, and single-line comments were added to C by C99. One last

point: a single-line comment can be nested within a multiline comment.You should include comments whenever they are needed to explain the operation
of the code. All but the most obvious functions should have a comment at the top that
states what the function does, how it is called, and what it returns.
252C++:TheCompleteReference
Part II
CPartOneexaminedtheCsubsetofC++.PartTwodescribesthose
featuresofthelanguagespecifictoC++.Thatis,itdiscussesthose

featuresofC++thatitdoesnothaveincommonwithC.Becausemany

oftheC++featuresaredesignedtosupportobject-oriented

programming(OOP),PartTwoalsoprovidesadiscussionofitstheory

and merits. We will begin with an overview of C++.Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This page intentionally left blank Chapter11
An Overview of C++255Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
ThischapterprovidesanoverviewofthekeyconceptsembodiedinC++.C++is
anobject-orientedprogramminglanguage,anditsobject-orientedfeaturesare

highlyinterrelated.Inseveralinstances,thisinterrelatednessmakesitdifficult
todescribeonefeatureofC++withoutimplicitlyinvolvingseveralothers.Moreover,

the object-oriented features of C++ are, in many places, so intertwined that discussion
of one featureimpliesprior knowledge of another. To address this problem, this chapterpresents a quick overview of the most important aspects of C++, including its history,
itskeyfeatures,andthedifferencebetweentraditionalandStandardC++.The

remainingchaptersexamineC++indetail.
The Origins of C++C++beganasanexpandedversionofC.TheC++extensionswerefirstinvented

byBjarneStroustrupin1979atBellLaboratoriesinMurrayHill,NewJersey.He

initiallycalledthenewlanguage"CwithClasses."However,in1983thenamewas

changedtoC++.
AlthoughCwasoneofthemostlikedandwidelyusedprofessionalprogramming
languagesintheworld,theinventionofC++wasnecessitatedbyonemajorprogram-

mingfactor:increasingcomplexity.Overtheyears,computerprogramshavebecome

largerandmorecomplex.EventhoughCisanexcellentprogramminglanguage,ithas

itslimits.InC,onceaprogramexceedsfrom25,000to100,000linesofcode,itbecomes

socomplexthatitisdifficulttograspasatotality.ThepurposeofC++istoallowthis

barriertobebroken.TheessenceofC++istoallowtheprogrammertocomprehend

andmanagelarger,morecomplexprograms.
Most additions made by Stroustrup to C support object-oriented programming,
sometimes referred to as OOP. (See the next section for a brief explanation of object-

oriented programming.) Stroustrup states that some of C++'s object-oriented features

were inspired by another object-oriented language called Simula67. Therefore, C++

represents the blending of two powerful programming methods.
SinceC++wasfirstinvented,ithasundergonethreemajorrevisions,witheach
addingtoandalteringthelanguage.Thefirstrevisionwasin1985andthesecondin

1990.ThethirdoccurredduringthestandardizationofC++.Severalyearsago,work

beganonastandardforC++.Towardthatend,ajointANSI(AmericanNational

StandardsInstitute)andISO(InternationalStandardsOrganization)standardization

committeewasformed.Thefirstdraftoftheproposedstandardwascreatedon

January25,1994.Inthatdraft,theANSI/ISOC++committee(ofwhichIwasamember)

keptthefeaturesfirstdefinedbyStroustrupandaddedsomenewonesaswell.Butin

general,thisinitialdraftreflectedthestateofC++atthetime.
SoonafterthecompletionofthefirstdraftoftheC++standard,aneventoccurred
thatcausedthelanguagetobegreatlyexpanded:thecreationoftheStandardTemplate

Library(STL)byAlexanderStepanov.TheSTLisasetofgenericroutinesthatyoucan

usetomanipulatedata.Itisbothpowerfulandelegant,butalsoquitelarge.Subsequent
256C++:TheCompleteReference
tothefirstdraft,thecommitteevotedtoincludetheSTLinthespecificationforC++.The
additionoftheSTLexpandedthescopeofC++wellbeyonditsoriginaldefinition.While

important,theinclusionoftheSTL,amongotherthings,slowedthestandardization

ofC++.
It is fair to say that the standardization of C++ took far longer than anyone had
expected when it began. In the process, many new features were added to the language

and many small changes were made. In fact, the version of C++ defined by the C++

committeeismuchlargerandmorecomplexthanStroustrup'soriginaldesign.The

finaldraftwaspassedoutofcommitteeonNovember14,1997andanANSI/ISO

standardforC++becamearealityin1998.ThisspecificationforC++iscommonly

referred to as
Standard C++.The material in this book describes Standard C++, including all of its newest
features. This is the version of C++ created by the ANSI/ISO standardization

committee, and it is the one that is currently accepted by all major compilers.
What Is Object-Oriented Programming?
Since object-oriented programming (OOP) drove the creation of C++, it is necessary

to understand its foundational principles. OOPis a powerful way to approach the job

of programming. Programming methodologies have changed dramatically since the

inventionofthecomputer,primarilytoaccommodatetheincreasingcomplexityof

programs. For example, when computers were first invented, programming was done

by toggling in the binary machine instructions using the computer's front panel. As

long as programs were just a few hundred instructions long, this approach worked.

As programs grew, assembly language was invented so that a programmer could deal

withlarger,increasinglycomplexprograms,usingsymbolicrepresentationsofthe

machineinstructions.Asprogramscontinuedtogrow,high-levellanguageswere

introduced that gave the programmer more tools with which to handle complexity.

The first widespread language was, of course, FORTRAN. Although FORTRAN was

a very impressive first step, it is hardly a language that encourages clear, easy-to-

understand programs.
The1960sgavebirthtostructuredprogramming.Thisisthemethodencouragedby
languagessuchasCandPascal.Theuseofstructuredlanguagesmadeitpossibleto

writemoderatelycomplexprogramsfairlyeasily.Structuredlanguagesarecharacterized

bytheirsupportforstand-alonesubroutines,localvariables,richcontrolconstructs,and

theirlackofrelianceupontheGOTO.Althoughstructuredlanguagesareapowerfultool,

theyreachtheirlimitwhenaprojectbecomestoolarge.
Consider this: At each milestone in the development of programming, techniques
and tools were created to allow the programmer to deal with increasingly greater

complexity. Each step of the way, the new approach took the best elements of the

previous methods and moved forward. Prior to the invention of OOP, many projects

were nearing (or exceeding) the point where the structured approach no longer
C++Chapter11:AnOverviewofC++
257258C++:TheCompleteReference
worked. Object-oriented methods were created to help programmers break through
these barriers.Object-oriented programming took the best ideas of structured programming
and combined them with several new concepts. The result was a different way of

organizing a program. In the most general sense, a program can be organized in

oneoftwoways:arounditscode(whatishappening)orarounditsdata(whoisbeing

affected). Using only structured programming techniques, programs are typically

organized around code. This approach can be thought of as "code acting on data."

For example, a program written in a structured language such as C is defined by

its functions, any of which may operate on any type of data used by the program.
Object-oriented programs work the other way around. They are organized
around data, with the key principle being "data controlling access to code." In an

object-oriented language, you define the data and the routines that are permitted

to act on that data. Thus, a data type defines precisely what sort of operations can

be applied to that data.To support the principles of object-oriented programming, all OOPlanguages
have three traits in common: encapsulation, polymorphism, and inheritance. Let's

examine each.EncapsulationEncapsulationisthemechanismthatbindstogethercodeandthedataitmanipulates,
andkeepsbothsafefromoutsideinterferenceandmisuse.Inanobject-oriented

language,codeanddatamaybecombinedinsuchawaythataself-contained"black

box"iscreated.Whencodeanddataarelinkedtogetherinthisfashion,an
objectiscreated.Inotherwords,anobjectisthedevicethatsupportsencapsulation.
Within an object, code, data, or both may be
privateto that object orpublic. Privatecode or data is known to and accessible only by another part of the object. That is,
private code or data may not be accessed by a piece of the program that exists outside

the object. When code or data is public, other parts of your program may access it even

though it is defined within an object. Typically, the public parts of an object are used to

provide a controlled interface to the private elements of the object.
For all intents and purposes, an object is a variable of a user-defined type. It may
seemstrangethatanobjectthatlinksbothcodeanddatacanbethoughtofasa

variable. However, in object-oriented programming, this is precisely the case. Each

time you define a new type of object, you are creating a new data type. Each specific

instance of this data type is a compound variable.PolymorphismObject-oriented programming languages support
polymorphism, which is characterizedby the phrase "one interface, multiple methods." In simple terms, polymorphism is the
attribute that allows one interface to control access to a general class of actions. The
Chapter11:AnOverviewofC++
259C++specific action selected is determined by the exact nature of the situation. Areal-world
example of polymorphism is a thermostat. No matter what type of furnace your house
has(gas,oil,electric,etc.),thethermostatworksthesameway.Inthiscase,thethermostat

(which is the interface) is the same no matter what type of furnace (method) you have.
Forexample,ifyouwanta70-degreetemperature,yousetthethermostatto70degrees.

It doesn't matter what type of furnace actually provides the heat.
This same principle can also apply to programming. For example, you might
haveaprogramthatdefinesthreedifferenttypesofstacks.Onestackisusedfor

integer values, one for character values, and one for floating-point values. Because
of polymorphism, you can define one set of names,push( )andpop()
, that can be usedfor all three stacks. In your program you will create three specific versions of these

functions, one for each type of stack, but names of the functions will be the same. The
compiler will automatically select the right function based upon the data being stored.

Thus,theinterfacetoastack—thefunctions
push()
andpop()
—arethesameno
matter which type of stack is being used. The individual versions of these functions
define the specific implementations (methods) for each type of data.Polymorphismhelpsreducecomplexitybyallowingthesameinterfacetobeused
toaccessageneralclassofactions.Itisthecompiler'sjobtoselectthe
specificaction
(i.e.,method)asitappliestoeachsituation.You,theprogrammer,don'tneedtodo

thisselectionmanually.Youneedonlyrememberandutilizethe
generalinterface
.Thefirstobject-orientedprogramminglanguageswereinterpreters,sopoly-
morphismwas,ofcourse,supportedatruntime.However,C++isacompiled

language.Therefore,inC++,bothrun-timeandcompile-timepolymorphism

aresupported.
InheritanceInheritanceis the process by which one object can acquire the properties of another
object. This is important because it supports the concept ofclassification. If you thinkabout it, most knowledge is made manageable by hierarchical classifications. For

example, a Red Delicious apple is part of the classificationapple, which in turn is partof thefruitclass, which is under the larger class
food. Without the use of classifications,
each object would have to define explicitly all of its characteristics. However, through

the use of classifications, an object need only define those qualities that make it unique
within its class. It is the inheritance mechanism that makes it possible for one object to
beaspecificinstanceofamoregeneralcase.Asyouwillsee,inheritanceisanimportant

aspect of object-oriented programming.
Some C++ FundamentalsIn Part One, the C subset of C++ was described and C programs were used to

demonstrate those features. From this point forward, all examples will be "C++
programs." That is, they will be making use of features unique to C++. For ease of
discussion, we will refer to these C++-specific features simply as "C++ features"from

now on.If you come from a C background, or if you have been studying the C subset
programs in Part One, be aware that C++ programs differ from C programs in some

important respects. Most of the differences have to do with taking advantage of C++'s

object-oriented capabilities. But C++ programs differ from C programs in other ways,

including how I/O is performed and what headers are included. Also, most C++

programs share a set of common traits that clearly identify them
asC++ programs.
Before moving on to C++'s object-oriented constructs, an understanding of the

fundamental elements of a C++ program is required.
This section describes several issues relating to nearly all C++ programs. Along the
way, some important differences with C and earlier versions of C++ are pointed out.
A Sample C++ Program
Let's start with the short sample C++ program shown here.
#include <iostream>using namespace std;int main(){int i;cout << "This is output.\n";  // this is a single line comment/* you can still use C style comments */// input a number using >>cout << "Enter a number: ";
cin >> i;// now, output a number using <<cout << i << " squared is " << i*i << "\n";return 0;}As you can see, this program looks much different from the C subset programs
found in Part One. Aline-by-line commentary will be useful. To begin, the header
<iostream>is included. This header supports C++-style I/O operations. (<iostream>is to C++ whatstdio.his to C.) Notice one other thing: there is no
.hextension to the260C++:TheCompleteReference
nameiostream. The reason is that
<iostream>is one of the modern-style headersdefined by Standard C++. Modern C++ headers do not use the
.hextension.The next line in the program is
using namespace std;Thistellsthecompilertousethe
stdnamespace.Namespacesarearecentaddition
toC++.Anamespacecreatesadeclarativeregioninwhichvariousprogramelementscan
beplaced.Namespaceshelpintheorganizationoflargeprograms.The
usingstatementinformsthecompilerthatyouwanttousethe
stdnamespace.Thisisthenamespacein
whichtheentireStandardC++libraryisdeclared.Byusingthe
stdnamespaceyou
simplifyaccesstothestandardlibrary.TheprogramsinPartOne,whichuseonlytheC

subset,don'tneedanamespacestatementbecausetheClibraryfunctionsarealso

availableinthedefault,globalnamespace.
Since both new-style headers and namespaces are recent additions to C++, you may

encounter older code that does not use them. Also, if you are using an older compiler,

it may not support them. Instructions for using an older compiler are found later in

this chapter.
Now examine the following line.int main()Notice that the parameter list inmain( )is empty. In C++, this indicates that
main( )has no parameters. This differs from C. In C, a function that has no parameters must

usevoidin its parameter list, as shown here:
int main(void)This was the waymain( )was declared in the programs in Part One. However, in
C++, the use ofvoidis redundant and unnecessary. As a general rule, in C++ when
a function takes no parameters, its parameter list is simply empty; the use ofvoidisnot required.
The next line contains two C++ features.
cout << "This is output.\n";  // this is a single line commentFirst, the statementcout << "This is output.\n";Chapter11:AnOverviewofC++
261C++262C++:TheCompleteReference
causesThis is output. to be displayed on the screen, followed by a carriage return-
linefeed combination. In C++, the << has an expanded role. It is still the left shift
operator, but when it is used as shown in this example, it is also an
outputoperator
. Theword
coutis an identifier that is linked to the screen. (Actually, like C, C++ supports
I/O redirection, but for the sake of discussion, assume that
coutrefers to the screen.)
You can use
coutand the<<to output any of the built-in data types, as well as stringsof characters.Note that you can still useprintf( )or any other of C's I/O functions in a C++program. However, most programmers feel that using
<<is more in the spirit of C++.
Further, while using
printf( )to output a string is virtually equivalent to using<<inthis case, the C++ I/O system can be expanded to perform operations on objects that
you define (something that you cannot do usingprintf( )).WhatfollowstheoutputexpressionisaC++
single-linecomment
.Asmentioned
inChapter10,C++definestwotypesofcomments.First,youmayuseamultiline

comment,whichworksthesameinC++asinC.Youcanalsodefineasingle-linecomment

byusing
//;whateverfollowssuchacommentisignoredbythecompileruntiltheendof
thelineisreached.Ingeneral,C++programmersusemultilinecommentswhenalonger

commentisbeingcreatedandusesingle-linecommentswhenonlyashortremarkis

needed.Next, the program prompts the user for a number. The number is read from the
keyboard with this statement:
cin >> i;In C++, the>>operator still retains its right shift meaning. However, when used
as shown, it also is C++'sinputoperator
. This statement causesito be given a valueread from the keyboard. The identifier
cinrefers to the standard input device, which
is usually the keyboard. In general, you can use
cin >>to input a variable of any ofthe basic data types plus strings.Thelineofcodejustdescribedisnotmisprinted.Specifically,thereisnotsupposedtobe

an&infrontofthe
i.WheninputtinginformationusingaC-basedfunctionlike
scanf()
,youhavetoexplicitlypassapointertothevariablethatwillreceivetheinformation.This

meansprecedingthevariablenamewiththe"addressof"operator,
&.However,becauseof
thewaythe>>operatorisimplementedinC++,youdonotneed(infact,mustnotuse)

the&.ThereasonforthisisexplainedinChapter13.
Although it is not illustrated by the example, you are free to use any of the
C-based input functions, such asscanf( ), instead of using>>. However, as with
cout, most programmers feel that
cin>>
is more in the spirit of C++.
Another interesting line in the program is shown here:
cout << i << "squared is " << i*i << "\n";Assuming thatihas the value 10, this statement causes the phrase10 squared is 100to be displayed, followed by a carriage return-linefeed. As this line illustrates, you can
run together several
<<output operations.The program ends with this statement:
return 0;This causes zero to be returned to the calling process (which is usually the operating

system). This works the same in C++ as it does in C. Returning zero indicates that the

program terminated normally. Abnormal program termination should be signaled by

returning a nonzero value. You may also use the values
EXIT_SUCCESSandEXIT_FAILURE
if you like.A Closer Look at the I/O OperatorsAs stated, when used for I/O, the<<and>>operators are capable of handling any
of C++'s built-in data types. For example, this program inputs a
float, adouble, anda string and then outputs them:#include <iostream>using namespace std;int main(){float f;
char str[80];
double d;cout << "Enter two floating point numbers: ";cin >> f >> d;cout << "Enter a string: ";cin >> str;cout << f << " " << d << " " << str;
return 0;}When you run this program, try entering
This is a test.when prompted for the
string. When the program redisplays the information you entered, only the word "This"
will be displayed. The rest of the string is not shown because the
>>operator stopsreading input when the first white-space character is encountered. Thus, "is a test" is
Chapter11:AnOverviewofC++
263C++never read by the program. This program also illustrates that you can string together
several input operations in a single statement.The C++ I/O operators recognize the entire set of backslash character constants
described in Chapter 2. For example, it is perfectly acceptable to writecout << "A\tB\tC";This statement outputs the letters A, B, and C, separated by tabs.Declaring Local Variables
If you come from a C background, you need to be aware of an important difference

between C and C++ regarding when local variables can be declared. In C89, you must

declarealllocalvariablesusedwithinablockatthestartofthatblock.Youcannotdeclare

a variable in a block after an "action" statement has occurred. For example, in C89, this

fragment is incorrect:
/* Incorrect in C89. OK in C++. */int f()
{int i;
i = 10;int j;  /* won't compile as a C program */j = i*2;return j;}In a C89 program, this function is in error because the assignment intervenes between
the declaration ofiand that ofj. However, when compiling it as a C++ program, this
fragment is perfectly acceptable. In C++ (and C99) you may declare local variables at

any point within a block—not just at the beginning.Here is another example. This version of the program from the preceding section
declares
strjust before it is needed.
#include <iostream>using namespace std;int main(){float f;264C++:TheCompleteReference
Chapter11:AnOverviewofC++
265C++double d;cout << "Enter two floating point numbers: ";
cin >> f >> d;cout << "Enter a string: ";char str[80];  // str declared here, just before 1st use
cin >> str;cout << f << " " << d << " " << str;
return 0;}Whetheryoudeclareallvariablesatthestartofablockoratthepointoffirstuseis
completelyuptoyou.SincemuchofthephilosophybehindC++istheencapsulationof
codeanddata,itmakessensethatyoucandeclarevariablesclosetowheretheyareused

insteadofjustatthebeginningoftheblock.Intheprecedingexample,thedeclarations

areseparatedsimplyforillustration,butitiseasytoimaginemorecomplexexamplesin

whichthisfeatureofC++ismorevaluable.
Declaringvariablesclosetowheretheyareusedcanhelpyouavoidaccidentalside
effects.However,thegreatestbenefitofdeclaringvariablesatthepointoffirstuseis

gainedinlargefunctions.Frankly,inshortfunctions(likemanyoftheexamplesinthis

book),thereislittlereasonnottosimplydeclarevariablesatthestartofafunction.For

thisreason,thisbookwilldeclarevariablesatthepointoffirstuseonlywhenitseems

warrantedbythesizeorcomplexityofafunction.
There is some debate as to the general wisdom of localizing the declaration of
variables. Opponents suggest that sprinkling declarations throughout a block makes

it harder, not easier, for someone reading the code to find quickly the declarations

of all variables used in that block, making the program harder to maintain. For this

reason, some C++ programmers do not make significant use of this feature. This book

will not take a stand either way on this issue. However, when applied properly,

especially in large functions, declaring variables at the point of their first use can

help you create bug-free programs more easily.
No Default to intAfew years ago, there was a change to C++ that may affect older C++ code as well as C

code being ported to C++. Both C89 and the original specification for C++ state that
when no explicit type is specified in a declaration, typeintis assumed. However, the
"default-to-int" rule was dropped from C++ during standardization. C99 also drops this

rule. However, there is still a large body of C and older C++ code that uses this rule.
The most common use of the "default-to-int" rule is with function return types. It
was common practice to not specifyintexplicitly when a function returned an integer
result. For example, in C89 and older C++ code the following function is valid.
func(int i){return i*i;}InStandardC++,thisfunctionmusthavethereturntypeof
intspecified,asshownhere.
int func(int i)
{return i*i;}As a practical matter, nearly all C++ compilers still support the "default-to-int" rule for
compatibility with older code. However, you should not use this feature for new code

because it is no longer allowed.The bool Data Type
C++definesabuilt-inBooleantypecalled
bool.Objectsoftype
boolcanstoreonlythe
valuestrueorfalse,whicharekeywordsdefinedbyC++.AsexplainedinPartOne,
automaticconversionstakeplacewhichallow
boolvaluestobeconvertedtointegers,
andviceversa.Specifically,anynon-zerovalueisconvertedto
trueandzeroisconverted
tofalse.Thereversealsooccurs;
trueisconvertedto1and
falseisconvertedtozero.
Thus,thefundamentalconceptofzerobeingfalseandnon-zerobeingtrueisstillfully

entrenchedintheC++language.
Although C89 (the C subset of C++) does not define a Boolean type, C99 adds to
the C language a type called_Bool, which is capable of storing the values 1 and 0(i.e., true/false). Unlike C++, C99 does not definetrueandfalseas keywords.Thus,_Boolas defined by C99 is incompatible withboolas defined by C++.The reason that C99 specifies
_Boolrather thanboolas a keyword is that manypreexisting C programs have aleady defined their own custom versions of
bool. Bydefining the Boolean type as_Bool, C99 avoids breaking this preexisting code. However,
it is possible to achieve compatibility between C++ and C99 on this point because C99
adds the header<stdbool.h>which defines the macros
bool,true, andfalse. Byincluding this header, you can create code that is compatible with both C99 and C++.
266C++:TheCompleteReference
C++Chapter11:AnOverviewofC++
267Old-Style vs. Modern C++
As explained, C++ underwent a rather extensive evolutionary process during its
development and standardization. As a result, there are really two versions of C++.

ThefirstisthetraditionalversionthatisbaseduponBjarneStroustrup'soriginal

designs.ThesecondisStandardC++,whichwascreatedbyStroustrupandthe

ANSI/ISOstandardizationcommittee.WhilethesetwoversionsofC++arevery

similarattheircore,StandardC++containsseveralenhancementsnotfoundin

traditional C++. Thus, Standard C++ is essentially a superset of traditional C++.
This book describes Standard C++. This is the version of C++ defined by the
ANSI/ISO standardization committee and the one implemented by all modern C++

compilers. The code in this book reflects the contemporary coding style and practices

as encouraged by Standard C++. However, if you are using an older compiler, it

may not accept all of the programs in this book. Here's why. During the process of

standardization, the ANSI/ISO committee added many new features to the language.

As these features were defined, they were implemented by compiler developers. Of

course, there is always a lag time between when a new feature is added to the language

and when it is available in commercial compilers. Since features were added to C++

over a period of years, an older compiler might not support one or more of them. This

is important because two recent additions to the C++ language affect every program

that you will write—even the simplest. If you are using an older compiler that does

not accept these new features, don't worry. There is an easy work-around, which is

described here.
The key differences between old-style and modern code involve two features:
new-style headers and thenamespacestatement. To understand the differences, we
will begin by looking at two versions of a minimal, do-nothing C++ program. The

first version shown here reflects the way C++ programs were written using old-style

coding./*An old-style C++ program.*/#include <iostream.h>
int main(){return 0;}Pay special attention to the#includestatement. It includes the fileiostream.h, not theheader<iostream>. Also notice that nonamespacestatement is present.
Here is the second version of the skeleton, which uses the modern style.
/*A modern-style C++ program that usesthe new-style headers and a namespace.*/
#include <iostream>
using namespace std;int main(){return 0;}This version uses the C++-style header and specifies a namespace. Both of thesefeatures were mentioned in passing earlier. Let's look closely at them now.
The New C++ HeadersAs you know, when you use a library function in a program, you must include its

header. This is done using the
#includestatement. For example, in C, to include theheader for the I/O functions, you includestdio.hwith a statement like this:#include <stdio.h>Here,
stdio.his the name of the file used by the I/O functions, and the preceding
statement causes that file to be included in your program. The key point is that this

#includestatement normallyincludesafile
.WhenC++wasfirstinventedandforseveralyearsafterthat,itusedthesamestyle
of headers as did C. That is, it usedheaderfiles
. In fact, Standard C++ still supports
C-styleheadersforheaderfilesthatyoucreateandforbackwardcompatibility.

However, Standard C++ created a new kind of header that is used by the Standard

C++ library. The new-style headers
donot
specify filenames. Instead, they simplyspecify standard identifiers that may be mapped to files by the compiler, although

they need not be. The new-style C++ headers are an abstraction that simply guarantee

that the appropriate prototypes and definitions required by the C++ library have

been declared.
Since the new-style headers are not filenames, they do not have a
.hextension. Theyconsist solely of the header name contained between angle brackets. For example, here

are some of the new-style headers supported by Standard C++.
<iostream>      <fstream>      <vector>      <string>268C++:TheCompleteReference
Chapter11:AnOverviewofC++
269C++The new-style headers are included using the
#includestatement. The only difference
is that the new-style headers do not necessarily represent filenames.
BecauseC++includestheentireCfunctionlibrary,itstillsupportsthestandard
C-styleheaderfilesassociatedwiththatlibrary.Thatis,headerfilessuchas
stdio.horctype.harestillavailable.However,StandardC++alsodefinesnew-styleheaders
thatyoucanuseinplaceoftheseheaderfiles.TheC++versionsoftheCstandard
headerssimplyadda"c"prefixtothefilenameanddropthe
.h.Forexample,theC++
new-styleheaderfor
math.his<cmath>.Theonefor
string.his<cstring>.Althoughit
iscurrentlypermissibletoincludeaC-styleheaderfilewhenusingClibraryfunctions,

thisapproachisdeprecatedbyStandardC++(thatis,itisnotrecommended).For

thisreason,fromthispointforward,thisbookwillusenew-styleC++headersinall

#includestatements.Ifyourcompilerdoesnotsupportnew-styleheadersfortheC
functionlibrary,thensimplysubstitutetheold-style,C-likeheaders.
Since the new-style header is a relatively recent addition to C++, you will still find
many, many older programs that don't use it. These programs employ C-style headers,

inwhichafilenameisspecified.Astheold-styleskeletalprogramshows,thetraditional

way to include the I/O header is as shown here.
#include <iostream.h>This causes the fileiostream.hto be included in your program. In general, an old-style
header file will use the same name as its corresponding new-style header with a

.happended.As of this writing, all C++ compilers support the old-style headers. However, the
old-style headers have been declared obsolete and their use in new programs is not

recommended. This is why they are not used in this book.
While still common in existing C++ code, old-style headers are obsolete.
NamespacesWhen you include a new-style header in your program, the contents of that header

are contained in the
stdnamespace. Anamespaceis simply a declarative region. The
purpose of a namespace is to localize the names of identifiers to avoid name collisions.
Elements declared in one namespace are separate from elements declared in another.

Originally, the names of the C++ library functions, etc., were simply put into the global

namespace (as they are in C). However, with the advent of the new-style headers, the

contents of these headers were placed in the
stdnamespace. We will look closely at
namespaces later in this book. For now, you won't need to worry about them because

the statementusing namespace std;270C++:TheCompleteReference
brings thestdnamespace into visibility (i.e., it putsstdinto the global namespace).After this statement has been compiled, there is no difference between working with
an old-style header and a new-style one.One other point: for the sake of compatibility, when a C++ program includes a C
header, such as
stdio.h, its contents are put into the global namespace. This allows a
C++ compiler to compile C-subset programs.
Working with an Old Compiler
As explained, both namespaces and the new-style headers are fairly recent additions

to the C++ language, added during standardization. While all new C++ compilers

support these features, older compilers may not. When this is the case, your compiler

will report one or more errors when it tries to compile the first two lines of the sample

programs in this book. If this is the case, there is an easy work-around: simply use an

old-style header and delete thenamespacestatement. That is, just replace
#include <iostream>using namespace std;with#include <iostream.h>This change transforms a modern program into an old-style one. Since the old-style
header reads all of its contents into the global namespace, there is no need for a

namespacestatement.One other point: for now and for the next few years, you will see many C++programs that use the old-style headers and do not include a
usingstatement. Your
C++ compiler will be able to compile them just fine. However, for new programs,

you should use the modern style because it is the only style of program that complies

with the C++ Standard. While old-style programs will continue to be supported for

many years, they are technically noncompliant.
Introducing C++ Classes
This section introduces C++'s most important feature: the class. In C++, to create an

object, you first must define its general form by using the keyword
class. Aclassissimilar syntactically to a structure. Here is an example. The following class defines

a type calledstack, which will be used to create a stack:
#define SIZE 100// This creates the class stack.class stack {int stck[SIZE];int tos;public:void init();void push(int i);
int pop();};Aclassmay contain private as well as public parts. By default, all items defined inaclassare private. For example, the variables
stckandtosare private. This means that
they cannot be accessed by any function that is not a member of theclass. This is oneway that encapsulation is achieved—access to certain items of data may be tightlycontrolled by keeping them private. Although it is not shown in this example, you

can also define private functions, which then may be called only by other members
of theclass.To make parts of a
classpublic (that is, accessible to other parts of your program),
you must declare them after the
publickeyword. All variables or functions defined
afterpubliccan be accessed by all other functions in the program. Essentially, the rest
of your program accesses an object through its public functions. Although you can

have public variables, good practice dictates that you should try to limit their use.
Instead, you should make all data private and control access to it through public

functions. One other point: Notice that thepublickeyword is followed by a colon.
The functionsinit( ),push( ), andpop( )are called
member functionsbecause theyare part of the class
stack. The variablesstckandtosare called
membervariables
(ordatamembers). Remember, an object forms a bond between code and data. Only member

functions have access to the private members of their class. Thus, onlyinit( ),push( ),andpop( )may accessstckandtos.Once you have defined aclass, you can create an object of that type by using the
class name. In essence, the class name becomes a new data type specifier. For example,

this creates an object called
mystackof typestack:stack mystack;When you declare an object of a class, you are creating an
instanceof that class. In thiscase,mystackis an instance ofstack. You may also create objects when the
classisdefined by putting their names after the closing curly brace, in exactly the same way
as you would with a structure.
To review: In C++,
classcreates a new data type that may be used to create objects
of that type. Therefore, an object is an instance of a class in just the same way that some

other variable is an instance of theintdata type, for example. Put differently, a class is a
Chapter11:AnOverviewofC++
271C++272C++:TheCompleteReference
logical abstraction, while an object is real. (That is, an object exists inside the memory of
the computer.)
The general form of a simpleclassdeclaration isclassclass-name{private data and functionspublic:public data and functions}object name list;Of course, theobject name listmay be empty.
Inside the declaration ofstack, member functions were identified using their
prototypes. In C++, all functions must be prototyped. Prototypes are not optional.

The prototype for a member function within a class definition serves as that function's

prototype in general.
When it comes time to actually code a function that is the member of a class, youmust tell the compiler which class the function belongs to by qualifying its name with
the name of the class of which it is a member. For example, here is one way to code the

push( )function:void stack::push(int i){if(tos==SIZE) {cout << "Stack is full.\n";
return;}
stck[tos] = i;
tos++;}The::is called thescope resolution operator
. Essentially, it tells the compiler that this
version ofpush( )belongs to thestackclass or, put differently, that this
push( )is instack's scope. In C++, several different classes can use the same function name. The
compiler knows which function belongs to which class because of the scope resolution

operator.
When you refer to a member of a class from a piece of code that is not part of the
class, you must always do so in conjunction with an object of that class. To do so, use

the object's name, followed by the dot operator, followed by the name of the member.

This rule applies whether you are accessing a data member or a function member. For

example, this callsinit( )for objectstack1.stack stack1, stack2;stack1.init();Chapter11:AnOverviewofC++
273C++This fragment creates two objects,
stack1andstack2, and initializesstack1.Understand thatstack1andstack2are two separate objects. This means, for example,
that initializingstack1doesnotcausestack2to be initialized as well. The onlyrelationship
stack1has withstack2is that they are objects of the same type.
Within a class, one member function can call another member function or refer to
a data member directly, without using the dot operator. It is only when a member is
referred to by code that does not belong to the class that the object name and the dot

operator must be used.The program shown here puts together all the pieces and missing details and
illustrates thestackclass:#include <iostream>using namespace std;#define SIZE 100
// This creates the class stack.class stack {int stck[SIZE];
int tos;public:void init();
void push(int i);
int pop();};void stack::init(){tos = 0;}void stack::push(int i){if(tos==SIZE) {cout << "Stack is full.\n";
return;}
stck[tos] = i;
tos++;}int stack::pop(){if(tos==0) {274C++:TheCompleteReference
cout << "Stack underflow.\n";return 0;}tos--;
return stck[tos];}int main(){stack stack1, stack2;  // create two stack objectsstack1.init();stack2.init();stack1.push(1);stack2.push(2);stack1.push(3);stack2.push(4);cout << stack1.pop() << " ";cout << stack1.pop() << " ";
cout << stack2.pop() << " ";
cout << stack2.pop() << "\n";return 0;}The output from this program is shown here.
3 1 4 2One last point: Recall that the private members of an object are accessible only by
functions that are members of that object. For example, a statement like
stack1.tos = 0; // Error, tos is private.could not be in themain( )function of the previous program because
tosis private.Chapter11:AnOverviewofC++
275C++Function OverloadingOne way that C++ achieves polymorphism is through the use of function overloading.
In C++, two or more functions can share the same name as long as their parameter

declarations are different. In this situation, the functions that share the same name are

said to beoverloaded, and the process is referred to as
function overloading.To see why function overloading is important, first consider three functions defined
by the C subset:abs( ),labs( ), andfabs( ). Theabs( )function returns the absolute
value of an integer,
labs( )returns the absolute value of a
long, andfabs( )returns the
absolute value of adouble. Although these functions perform almost identical actions,in C three slightly different names must be used to represent these essentially similar

tasks. This makes the situation more complex, conceptually, than it actually is. Even

though the underlying concept of each function is the same, the programmer has to

remember three things, not just one. However, in C++, you can use just one name for

all three functions, as this program illustrates:
#include <iostream>using namespace std;// abs is overloaded three waysint abs(int i);
double abs(double d);
long abs(long l);int main(){cout << abs(-10) << "\n";cout << abs(-11.0) << "\n";
cout << abs(-9L) << "\n";
return 0;}
int abs(int i){cout << "Using integer abs()\n";276C++:TheCompleteReference
return i<0 ? -i : i;}double abs(double d){cout << "Using double abs()\n";return d<0.0 ? -d : d;}
long abs(long l){cout << "Using long abs()\n";return l<0 ? -l : l;}The output from this program is shown here.
Using integer abs()10
Using double abs()
11
Using long abs()
9This program creates three similar but different functions called
abs( ), each ofwhich returns the absolute value of its argument. The compiler knows which function
to call in each situation because of the type of the argument. The value of overloaded

functions is that they allow related sets of functions to be accessed with a common

name. Thus, the nameabs( )represents the
general actionthat is being performed. It isleft to the compiler to choose the rightspecificmethod
for a particular circumstance.
You need only remember the general action being performed. Due to polymorphism,

three things to remember have been reduced to one. This example is fairly trivial, but

if you expand the concept, you can see how polymorphism can help you manage very
complex programs.
In general, to overload a function, simply declare different versions of it. The
compiler takes care of the rest. You must observe one important restriction when

overloading a function: the type and/or number of the parameters of each overloaded
function must differ. It is not sufficient for two functions to differ only in their return

types. They must differ in the types or number of their parameters. (Return types do

not provide sufficient information in all cases for the compiler to decide which function

to use.) Of course, overloaded functionsmaydiffer in their return types, too.
Here is another example that uses overloaded functions:
#include <iostream>#include <cstdio>
#include <cstring>
using namespace std;void stradd(char *s1, char *s2);void stradd(char *s1, int i);int main(){char str[80];strcpy(str, "Hello ");stradd(str, "there");
cout << str << "\n";stradd(str, 100);cout << str << "\n";return 0;}
// concatenate two stringsvoid stradd(char *s1, char *s2)
{strcat(s1, s2);}// concatenate a string with a "stringized" integervoid stradd(char *s1, int i)
{char temp[80];sprintf(temp, "%d", i);strcat(s1, temp);}In this program, the function
stradd( )is overloaded. One version concatenatestwo strings (just likestrcat( )does). The other version "stringizes" an integer and thenappends that to a string. Here, overloading is used to create one interface that appends
either a string or an integer to another string.Chapter11:AnOverviewofC++
277C++You can use the same name to overload unrelated functions, but you should
not. For example, you could use the namesqr( )to create functions that return the
square
of anintand thesquare root
of adouble. However, these two operations are
fundamentally different; applying function overloading in this manner defeats its
purpose (and, in fact, is considered bad programming style). In practice, you should

overload only closely related operations.
Operator OverloadingPolymorphismisalsoachievedinC++throughoperatoroverloading.Asyouknow,in

C++,itispossibletousethe
<<and>>operatorstoperformconsoleI/Ooperations.
Theycanperformtheseextraoperationsbecauseinthe
<iostream>header,these
operatorsareoverloaded.Whenanoperatorisoverloaded,ittakesonanadditional

meaningrelativetoacertainclass.However,itstillretainsallofitsoldmeanings.
Ingeneral,youcanoverloadmostofC++'soperatorsbydefiningwhattheymean
relativetoaspecificclass.Forexample,thinkbacktothe
stackclassdevelopedearlier
inthischapter.Itispossibletooverloadthe
+operatorrelativetoobjectsoftype
stacksothatitappendsthecontentsofonestacktothecontentsofanother.However,the
+stillretainsitsoriginalmeaningrelativetoothertypesofdata.
Because operator overloading is, in practice, somewhat more complex than function
overloading, examples are deferred until Chapter 14.
InheritanceAsstatedearlierinthischapter,inheritanceisoneofthemajortraitsofanobject-

orientedprogramminglanguage.InC++,inheritanceissupportedbyallowingone

classtoincorporateanotherclassintoitsdeclaration.Inheritanceallowsahierarchy

ofclassestobebuilt,movingfrommostgeneraltomostspecific.Theprocessinvolves

firstdefininga
baseclass
,whichdefinesthosequalitiescommontoallobjectstobe
derivedfromthebase.Thebaseclassrepresentsthemostgeneraldescription.The

classesderivedfromthebaseareusuallyreferredtoas
derivedclasses
.Aderivedclass
includesallfeaturesofthegenericbaseclassandthenaddsqualitiesspecifictothe

derivedclass.Todemonstratehowthisworks,thenextexamplecreatesclassesthat

categorizedifferenttypesofbuildings.
To begin, the
buildingclass is declared, as shown here. It will serve as the base for
two derived classes.class building {int rooms;int floors;
int area;278C++:TheCompleteReference
public:void set_rooms(int num);int get_rooms();
void set_floors(int num);
int get_floors();
void set_area(int num);
int get_area();};Because (for the sake of this example) all buildings have three common features—
one or more rooms, one or more floors, and a total area—the
buildingclass embodiesthese components into its declaration. The member functions beginning withsetsetthe values of the private data. The functions starting with get return those values.
You can now use this broad definition of a building to create derived classes that
describe specific types of buildings. For example, here is a derived class called
house:// house is derived from buildingclass house : public building {int bedrooms;
int baths;public:void set_bedrooms(int num);
int get_bedrooms();
void set_baths(int num);
int get_baths();};Notice howbuildingis inherited. The general form for inheritance isclassderived-class : access base-class{//body of new class}Here,
accessis optional. However, if present, it must be
public,private, orprotected.(These options are further examined in Chapter 12.) For now, all inherited classes
will usepublic. Usingpublicmeans that all of the public members of the base classwill become public members of the derived class. Therefore, the public members of the

classbuildingbecome public members of the derived classhouseand are available to
thememberfunctionsof
housejustasiftheyhadbeendeclaredinside
house.However,
house's member functionsdonot
have access to the private elements ofbuilding. Thisis an important point. Even thoughhouseinheritsbuilding, it has access only to theChapter11:AnOverviewofC++
279C++publicmembersof
building.Inthisway,inheritancedoesnotcircumventtheprinciples
of encapsulation necessary to OOP.
Aderived class has direct access to both its own members and the public members of
the base class.Here is a program illustrating inheritance. It creates two derived classes of
buildingusing inheritance; one ishouse, the other,
school.#include <iostream>using namespace std;class building {int rooms;int floors;
int area;public:void set_rooms(int num);
int get_rooms();
void set_floors(int num);
int get_floors();
void set_area(int num);
int get_area();};// house is derived from buildingclass house : public building {int bedrooms;
int baths;public:void set_bedrooms(int num);
int get_bedrooms();
void set_baths(int num);
int get_baths();};// school is also derived from buildingclass school : public building {int classrooms;
int offices;public:void set_classrooms(int num);280C++:TheCompleteReference
int get_classrooms();void set_offices(int num);
int get_offices();};void building::set_rooms(int num){rooms = num;}void building::set_floors(int num){floors = num;}void building::set_area(int num){area = num;}int building::get_rooms(){return rooms;}int building::get_floors(){return floors;}int building::get_area(){return area;}void house::set_bedrooms(int num){bedrooms = num;}void house::set_baths(int num){Chapter11:AnOverviewofC++
281C++baths = num;}int house::get_bedrooms(){return bedrooms;}int house::get_baths(){return baths;}void school::set_classrooms(int num){classrooms = num;}void school::set_offices(int num){offices = num;}int school::get_classrooms(){return classrooms;}int school::get_offices(){return offices;}int main(){house h;
school s;h.set_rooms(12);h.set_floors(3);
h.set_area(4500);
h.set_bedrooms(5);282C++:TheCompleteReference
h.set_baths(3);cout << "house has " << h.get_bedrooms();cout << " bedrooms\n";s.set_rooms(200);s.set_classrooms(180);
s.set_offices(5);
s.set_area(25000);cout << "school has " << s.get_classrooms();cout << " classrooms\n";
cout << "Its area is " << s.get_area();return 0;}The output produced by this program is shown here.
house has 5 bedroomsschool has 180 classrooms
Its area is 25000As this program shows, the major advantage of inheritance is that you can create a
general classification that can be incorporated into more specific ones. In this way, each
object can precisely represent its own subclass.
When writing about C++, the termsbaseandderivedare generally used to describe
the inheritance relationship. However, the terms
parent
andchildare also used. You
may also see the termssuperclass
andsubclass.Aside from providing the advantages of hierarchical classification, inheritance
also provides support for run-time polymorphism through the mechanism of
virtualfunctions. (Refer to Chapter 16 for details.)Constructors and Destructors
It is very common for some part of an object to require initialization before it can be

used. For example, think back to thestackclass developed earlier in this chapter.
Before the stack could be used,
toshad to be set to zero. This was performed by using
thefunction
init().
Becausetherequirementforinitializationissocommon,C++allows
objects to initialize themselves when they are created. This automatic initialization is

performed through the use of a constructor function.
Chapter11:AnOverviewofC++
283C++284C++:TheCompleteReference
Aconstructoris a special function that is a member of a class and hasthe same name as that class. For example, here is how the
stackclass looks whenconverted to use a constructor for initialization:
// This creates the class stack.class stack {int stck[SIZE];
int tos;public:stack();  // constructor
void push(int i);
int pop();};Notice that the constructor
stack( )has no return type specified. In C++, constructors
cannot return values and, thus, have no return type.
Thestack( )constructor is coded like this:
// stack's constructor
stack::stack()
{tos = 0;
cout << "Stack Initialized\n";}Keep in mind that the messageStack Initializedis output as a way to illustratethe constructor. In actual practice, most constructors will not output or input anything.
They will simply perform various initializations.An object's constructor is automatically called when the object is created. This
means that it is called when the object's declaration is executed. If you are accustomed

to thinking of a declaration statement as being passive, this is not the case for C++. In
C++, a declaration statement is a statement that is executed. This distinction is not just
academic. The code executed to construct an object may be quite significant. An object's

constructoriscalledonceforglobalor
staticlocalobjects.Forlocalobjects,theconstructor
is called each time the object declaration is encountered.
The complement of the constructor is the
destructor. In many circumstances, an
object will need to perform some action or actions when it is destroyed. Local objects

are created when their block is entered, and destroyed when the block is left. Global

objects are destroyed when the program terminates. When an object is destroyed, its

destructor(ifithasone)isautomaticallycalled.Therearemanyreasonswhyadestructor

maybeneeded.Forexample,anobjectmayneedtodeallocatememorythatithad

previouslyallocatedoritmayneedtocloseafilethatithadopened.InC++,itisthe

destructor that handles deactivation events. The destructor has the same name as the
Chapter11:AnOverviewofC++
285C++constructor,butitisprecededbya
~.Forexample,hereisthe
stackclassanditsconstructor
and destructor. (Keep in mind that the
stackclass does not require a destructor; the one
shown here is just for illustration.)
// This creates the class stack.class stack {int stck[SIZE];
int tos;public:stack();  // constructor
~stack(); // destructor
void push(int i);
int pop();};// stack's constructorstack::stack()
{tos = 0;
cout << "Stack Initialized\n";}// stack's destructorstack::~stack()
{cout << "Stack Destroyed\n";}Notice that, like constructors, destructors do not have return values.
To see how constructors and destructors work, here is a new version of the
stackprogram examined earlier in this chapter. Observe that
init( )is no longer needed.// Using a constructor and destructor.
#include <iostream>
using namespace std;#define SIZE 100
// This creates the class stack.class stack {int stck[SIZE];
int tos;public:286C++:TheCompleteReference
stack();  // constructor~stack(); // destructor
void push(int i);
int pop();};// stack's constructorstack::stack()
{tos = 0;
cout << "Stack Initialized\n";}// stack's destructorstack::~stack()
{cout << "Stack Destroyed\n";}void stack::push(int i){if(tos==SIZE) {cout << "Stack is full.\n";
return;}
stck[tos] = i;
tos++;}int stack::pop(){if(tos==0) {cout << "Stack underflow.\n";
return 0;}
tos--;
return stck[tos];}int main(){stack a, b;  // create two stack objectsa.push(1);b.push(2);a.push(3);b.push(4);cout << a.pop() << " ";cout << a.pop() << " ";
cout << b.pop() << " ";
cout << b.pop() << "\n";return 0;}This program displays the following:
Stack InitializedStack Initialized
3 1 4 2
Stack Destroyed
Stack DestroyedThe C++ Keywords
There are 63 keywords currently defined for Standard C++. These are shown in
Table 11-1. Together with the formal C++ syntax, they form the C++ programming

language. Also, early versions of C++ defined theoverloadkeyword, but it is obsolete.
Keep in mind that C++ is a case-sensitive language and it requires that all keywords

be in lowercase.
Chapter11:AnOverviewofC++
287C++asmautoboolbreak
casecatchcharclass
constconst_castcontinuedefault

deletedodoubledynamic_cast

elseenumexplicitexport
Table11-1.
The C++ keywords
The General Form of a C++ Program
Although individual styles will differ, most C++ programs will have this general form:
#includesbase-class declarations
derived class declarations
nonmember function prototypes
int main( )
{//...}
nonmember function definitionsIn most large projects, all
classdeclarations will be put into a header file and includedwith each module. But the general organization of a program remains the same.
The remaining chapters in this section examine in greater detail the features
discussed in this chapter, as well as all other aspects of C++.
288C++:TheCompleteReference
externfalsefloatforfriendgotoifinlineintlongmutablenamespacenewoperatorprivateprotected
publicregister
reinterpret_castreturn
shortsignedsizeofstaticstatic_caststruct
switchtemplatethisthrow
true
trytypedeftypeidtypenameunionunsignedusingvirtualvoidvolatilewchar_twhileTable11-1.
The C++ keywords
(continued)Chapter12
Classes and Objects289Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
In C++, the class forms the basis for object-oriented programming. The class is usedto define the nature of an object, and it is C++'s basic unit of encapsulation. This
chapter examines classes and objects in detail.ClassesClasses are created using the keyword
class. Aclass declaration defines a new type
that links code and data. This new type is then used to declare objects of that class.

Thus, a class is a logical abstraction, but an object has physical existence. In other
words, an object is an
instanceof a class.Aclass declaration is similar syntactically to a structure. In Chapter 11, a simplified
general form of a class declaration was shown. Here is the entire general form of a

classdeclaration that does not inherit any other class.classclass-name {private data and functionsaccess-specifier:data and functionsaccess-specifier:data and functions// ...
access-specifier:data and functions} object-list;Theobject-listisoptional.Ifpresent,itdeclaresobjectsoftheclass.Here,
access-specifierisoneofthesethreeC++keywords:
publicprivate
protectedBydefault,functionsanddatadeclaredwithinaclassareprivatetothatclass
andmaybeaccessedonlybyothermembersoftheclass.The
publicaccessspecifier
allowsfunctionsordatatobeaccessibletootherpartsofyourprogram.The
protectedaccessspecifierisneededonlywheninheritanceisinvolved(seeChapter15).Once
anaccessspecifierhasbeenused,itremainsineffectuntileitheranotheraccess

specifierisencounteredortheendoftheclassdeclarationisreached.
You may change access specifications as often as you like within a
classdeclaration.For example, you may switch topublicfor some declarations and then switch back toprivateagain. The class declaration in the following example illustrates this feature:
290C++:TheCompleteReference
Chapter12:ClassesandObjects
291C++#include <iostream>#include <cstring>
using namespace std;class employee {char name[80]; // private by defaultpublic:void putname(char *n); // these are publicvoid getname(char *n);private:double wage; // now, private againpublic:void putwage(double w); // back to public
double getwage();};void employee::putname(char *n){strcpy(name, n);}void employee::getname(char *n){strcpy(n, name);}void employee::putwage(double w){wage = w;}double employee::getwage(){return wage;}int main(){employee ted;
char name[80];ted.putname("Ted Jones");ted.putwage(75000);292C++:TheCompleteReference
ted.getname(name);cout << name << " makes $";
cout << ted.getwage() << " per year.";return 0;}Here,
employeeis a simple class that is used to store an employee's name and wage.
Notice that thepublicaccess specifier is used twice.Although you may use the access specifiers as often as you like within a classdeclaration, the only advantage of doing so is that by visually grouping various parts
of a class, you may make it easier for someone else reading the program to understand

it. However, to the compiler, using multiple access specifiers makes no difference.

Actually, most programmers find it easier to have only one
private,protected,and
publicsection within each class. For example, most programmers would code the
employeeclass as shown here, with all private elements grouped together and all
public elements grouped together:
class employee {char name[80];double wage;public:void putname(char *n);
void getname(char *n);
void putwage(double w);
double getwage();};Functions that are declared within a class are called
member functions. Memberfunctions may access any element of the class of which they are a part. This includes
allprivateelements. Variables that are elements of a class are called
member variablesordata members. (The terminstance variableis also used.) Collectively, any element of
a class can be referred to as a member of that class.
There are a few restrictions that apply to class members. Anon-
staticmembervariable cannot have an initializer. No member can be an object of the class that is

being declared. (Although a member can be a pointer to the class that is being

declared.) No member can be declared as
auto,extern, orregister.In general, you should make all data members of a classprivate to that class. This
is part of the way that encapsulation is achieved. However, there may be situations in

which you will need to make one or more variables public. (For example, a heavily
Chapter12:ClassesandObjects
293C++used variable may need to be accessible globally in order to achieve faster run times.)
When a variable is public, it may be accessed directly by any other part of your

program. The syntax for accessing a public data member is the same as for calling a

member function: Specify the object's name, the dot operator, and the variable name.

This simple program illustrates the use of a public variable:
#include <iostream>using namespace std;class myclass {public:int i, j, k; // accessible to entire program};int main(){myclass a, b;a.i = 100; // access to i, j, and k is OKa.j = 4;
a.k = a.i * a.j;b.k = 12; // remember, a.k and b.k are differentcout << a.k << " " << b.k;return 0;}Structures and Classes Are Related
Structures are part of the C subset and were inherited from the C language. As you
have seen, aclassis syntactically similar to astruct. But the relationship between a
classand astructis closer than you may at first think. In C++, the role of the structure
wasexpanded,makingitanalternativewaytospecifyaclass.Infact,theonlydifference

between aclassand astructis that by default all members are public in a
structandprivate in aclass. In all other respects, structures and classes are equivalent. That is,
in C++, astructuredefinesa class type
. For example, consider this short program, which
uses a structure to declare a class that controls access to a string:
// Using a structure to define a class.#include <iostream>
#include <cstring>294C++:TheCompleteReference
using namespace std;struct mystr {void buildstr(char *s); // publicvoid showstr();private: // now go privatechar str[255];} ;void mystr::buildstr(char *s){if(!*s) *str = '\0'; // initialize string
else strcat(str, s);}void mystr::showstr(){cout << str << "\n";}int main(){mystr s;s.buildstr(""); // inits.buildstr("Hello ");
s.buildstr("there!");s.showstr();
return 0;}This program displays the string
Hello there!.The classmystrcould be rewritten by using
classas shown here:
class mystr {char str[255];public:void buildstr(char *s); // publicvoid showstr();} ;Chapter12:ClassesandObjects
295C++You might wonder why C++ contains the two virtually equivalent keywords
structandclass. This seeming redundancy is justified for several reasons. First, there is no
fundamentalreasonnottoincreasethecapabilitiesofastructure.InC,structures
already provide a means of grouping data. Therefore, it is a small step to allow them to

include member functions. Second, because structures and classes are related, it may be

easiertoportexistingCprogramstoC++.Finally,although
structandclassarevirtually
equivalent today, providing two different keywords allows the definition of a
classtobe free to evolve. In order for C++ to remain compatible with C, the definition of
structmust always be tied to its C definition.Although you can use astructwhere you use a
class, most programmers don't.
Usually it is best to use aclasswhen you want a class, and astructwhen you want aC-like structure. This is the style that this book will follow. Sometimes the acronym

PODis used to describe a C-style structure—one that does not contain member
functions, constructors, or destructors. It stands for Plain Old Data.
In C++, a structure declaration defines a class type.
Unions and Classes Are Related
Like a structure, a
unionmay also be used to define a class. In C++,unions maycontain both member functions and variables. They may also include constructors

and destructors. A
unionin C++ retains all of its C-like features, the most important
being that all data elements share the same location in memory. Like the structure,

unionmembers are public by default and are fully compatible with C. In the next
example, aunionis used to swap the bytes that make up anunsignedshort
integer.
(This example assumes that short integers are 2 bytes long.)
#include <iostream>using namespace std;union swap_byte {void swap();void set_byte(unsigned short i);
void show_word();unsigned short u;unsigned char c[2];};void swap_byte::swap(){296C++:TheCompleteReference
unsigned char t;t = c[0];c[0] = c[1];
c[1] = t;}void swap_byte::show_word(){cout << u;}void swap_byte::set_byte(unsigned short i){u = i;}int main(){swap_byte b;b.set_byte(49034);b.swap();
b.show_word();return 0;}Like a structure, a
uniondeclaration in C++ defines a special type of class. Thismeans that the principle of encapsulation is preserved.
There are several restrictions that must be observed when you use C++ unions.
First, aunioncannot inherit any other classes of any type. Further, a
unioncannot beabaseclass.A
unioncannothavevirtualmemberfunctions.(Virtualfunctionsare
discussed in Chapter 17.) Nostaticvariables can be members of aunion. Areference
member cannot be used. Aunioncannot have as a member any object that overloadsthe=operator. Finally, no object can be a member of a
unionif the object has an explicitconstructor or destructor function.
Aswith
struct,thetermPODisalsocommonlyappliedtounionsthatdonotcontain
member functions, constructors, or destructors.
Anonymous UnionsThere is a special type of
unionin C++ called ananonymousunion
. An anonymousunion does not include a type name, and no objects  of the union can be declared.
Chapter12:ClassesandObjects
297C++Instead, an anonymous union tells the compiler that its member variables are to
share the same location. However, the variables themselves are referred to directly,

without the normal dot operator syntax. For example, consider this program:
#include <iostream>#include <cstring>
using namespace std;int main(){// define anonymous union
union {long l;
double d;
char s[4];} ;// now, reference union elements directlyl = 100000;
cout << l << " ";
d = 123.2342;
cout << d << " ";
strcpy(s, "hi");
cout << s;return 0;}As you can see, the elements of the union are referenced as if they had been
declared as normal local variables. In fact, relative to your program, that is exactly how
you will use them. Further, even though they are defined within a
uniondeclaration,they are at the same scope level as any other local variable within the same block. This

implies that the names of the members of an anonymous union must not conflict with
other identifiers known within the same scope.All restrictions involving
unions apply to anonymous ones, with these additions.First, the only elements contained within an anonymous union must be data. No
memberfunctionsareallowed.Anonymousunionscannotcontain
privateorprotectedelements. Finally, global anonymous unions must be specified as
static.Friend FunctionsIt is possible to grant a nonmember function access to the private members of a class
by using afriend. Afriendfunction has access to allprivateandprotectedmembersof the class for which it is afriend. To declare a
friendfunction, include its prototype
within the class, preceding it with the keyword
friend. Consider this program:
#include <iostream>using namespace std;class myclass {int a, b;public:friend int sum(myclass x);void set_ab(int i, int j);};void myclass::set_ab(int i, int j){a = i;
b = j;}// Note: sum() is not a member function of any class.int sum(myclass x)
{/* Because sum() is a friend of myclass, it candirectly access a and b. */return x.a + x.b;}int main(){myclass n;n.set_ab(3, 4);
cout << sum(n);
return 0;}In this example, thesum( )function is not a member ofmyclass. However, it still
has full access to its private members. Also, notice thatsum( )is called without the useof the dot operator. Because it is not a member function, it does not need to be (indeed,
it may not be) qualified with an object's name.298C++:TheCompleteReference
Chapter12:ClassesandObjects
299C++Althoughthereisnothinggainedbymaking
sum( )afriendratherthanamember
functionof
myclass,therearesomecircumstancesinwhich
friendfunctionsarequite
valuable.First,friendscanbeusefulwhenyouareoverloadingcertaintypesofoperators
(seeChapter14).Second,
friendfunctionsmakethecreationofsometypesofI/O
functionseasier(seeChapter18).Thethirdreasonthat
friendfunctionsmaybedesirable
isthatinsomecases,twoormoreclassesmaycontainmembersthatareinterrelated

relativetootherpartsofyourprogram.Let'sexaminethisthirdusagenow.
To begin, imagine two different classes, each of which displays a pop-up message
on the screen when error conditions occur. Other parts of your program may wish

to know if a pop-up message is currently being displayed before writing to the screen

so that no message is accidentally overwritten. Although you can create member

functions in each class that return a value indicating whether a message is active,

this means additional overhead when the condition is checked (that is, two function

calls, not just one). If the condition needs to be checked frequently, this additional

overhead may not be acceptable. However, using a function that is a
friendof eachclass, it is possible to check the status of each object by calling only this one function.
Thus, in situations like this, afriendfunction allows you to generate more efficient
code. The following program illustrates this concept:
#include <iostream>using namespace std;const int IDLE = 0;const int INUSE = 1;class C2;  // forward declaration
class C1 {int status;  // IDLE if off, INUSE if on screen// ...public:void set_status(int state);
friend int idle(C1 a, C2 b);};class C2 {int status; // IDLE if off, INUSE if on screen// ...public:void set_status(int state);
friend int idle(C1 a, C2 b);};void C1::set_status(int state){status = state;}void C2::set_status(int state){status = state;}int idle(C1 a, C2 b){if(a.status || b.status) return 0;
else return 1;}int main(){C1 x;
C2 y;x.set_status(IDLE);y.set_status(IDLE);if(idle(x, y)) cout << "Screen can be used.\n";else cout << "In use.\n";x.set_status(INUSE);
if(idle(x, y)) cout << "Screen can be used.\n";else cout << "In use.\n";return 0;}Notice that this program uses a
forwarddeclaration
(also called aforwardreference
)for the classC2. This is necessary because the declaration ofidle( )insideC1refers
toC2before it is declared. To create a forward declaration to a class, simply use the
form shown in this program.
Afriendof one class may be a member of another. For example, here is the
preceding program rewritten so that
idle( )is a member ofC1:300C++:TheCompleteReference
#include <iostream>using namespace std;const int IDLE = 0;const int INUSE = 1;class C2;  // forward declaration
class C1 {int status;  // IDLE if off, INUSE if on screen// ...public:void set_status(int state);
int idle(C2 b);  // now a member of C1};class C2 {int status;  // IDLE if off, INUSE if on screen// ...public:void set_status(int state);
friend int C1::idle(C2 b);};void C1::set_status(int state){status = state;}void C2::set_status(int state){status = state;}// idle() is member of C1, but friend of C2int C1::idle(C2 b)
{if(status || b.status) return 0;
else return 1;}int main(){Chapter12:ClassesandObjects
301C++C1 x;C2 y;x.set_status(IDLE);y.set_status(IDLE);if(x.idle(y)) cout << "Screen can be used.\n";else cout << "In use.\n";
x.set_status(INUSE);if(x.idle(y)) cout << "Screen can be used.\n";else cout << "In use.\n";return 0;}Becauseidle( )is a member ofC1, it can access thestatusvariable of objects of typeC1directly. Thus, only objects of type
C2need be passed toidle( ).There are two important restrictions that apply to
friendfunctions. First, a derivedclass does not inheritfriendfunctions. Second,friendfunctions may not have astorage-class specifier. That is, they may not be declared as
staticorextern.Friend ClassesIt is possible for one classto be a
friendof another class. When this is the case, thefriendclass and all of its member functions have access to the private membersdefined within the other class. For example,// Using a friend class.#include <iostream>
using namespace std;class TwoValues {int a;int b;public:TwoValues(int i, int j) { a = i; b = j; }
friend class Min;};class Min {302C++:TheCompleteReference
public:int min(TwoValues x);};int Min::min(TwoValues x){return x.a < x.b ? x.a : x.b;}int main(){TwoValues ob(10, 20);
Min m;cout << m.min(ob);
return 0;}In this example, classMinhas access to the private variablesaandbdeclared within
theTwoValues
class.It is critical to understand that when one class is afriendof another, it only has
access to names defined within the other class. It does not inherit the other class.Specifically, the members of the first class do not become members of the
friendclass.Friend classes are seldom used. They are supported to allow certain special case
situations to be handled.Inline FunctionsThere is an important feature in C++, called an
inline function, that is commonly usedwith classes. Since the rest of this chapter (and the rest of the book) will make heavy

use of it, inline functions are examined here.
In C++, you can create short functions that are not actually called; rather, their code
is expanded in line at the point of each invocation. This process is similar to using a

function-like macro. To cause a function to be expanded in line rather than called,

precede its definition with the
inlinekeyword. For example, in this program, the
functionmax( )is expanded in line instead of called:#include <iostream>using namespace std;Chapter12:ClassesandObjects
303C++inline int max(int a, int b){return a>b ? a : b;}int main(){cout << max(10, 20);
cout << " " << max(99, 88);return 0;}Asfarasthecompilerisconcerned,theprecedingprogramisequivalenttothisone:
#include <iostream>using namespace std;int main(){cout << (10>20 ? 10 : 20);
cout << " " << (99>88 ? 99 : 88);return 0;}The reason that
inlinefunctions are an important addition to C++ is that they allow
youtocreateveryefficientcode.Sinceclassestypicallyrequireseveralfrequently
executed interface functions (which provide access to private data), the efficiency of

these functions is of critical concern. As you probably know, each time a function is

called,asignificantamountofoverheadisgeneratedbythecallingandreturn

mechanism. Typically, arguments are pushed onto the stack and various registers are

saved when a function is called, and then restored when the function returns. The

trouble is that these instructions take time. However, when a function is expanded in

line, none of those operations occur. Although expanding function calls in line can

produce faster run times, it can also result in larger code size because of duplicated

code. For this reason, it is best to
inlineonly very small functions. Further, it is also
a good idea toinlineonly those functions that will have significant impact on theperformance of your program.
Like theregisterspecifier,
inlineis actually just arequest
, not a command, to thecompiler. The compiler can choose to ignore it. Also, some compilers may not inline
304C++:TheCompleteReference
Chapter12:ClassesandObjects
305C++all types of functions. For example, it is common for a compiler not to inline a recursive
function. You will need to check your compiler's documentation for any restrictions

toinline.Remember,ifafunctioncannotbeinlined,itwillsimplybecalledasa
normal function.Inline functions may be class member functions. For example, this is a perfectlyvalid C++ program:
#include <iostream>using namespace std;class myclass {int a, b;public:void init(int i, int j);void show();};// Create an inline function.inline void myclass::init(int i, int j)
{a = i;
b = j;}// Create another inline function.inline void myclass::show()
{cout << a << " " << b << "\n";}int main(){myclass x;x.init(10, 20);x.show();return 0;}Theinlinekeyword is not part of the C subset of C++. Thus, it is not defined by C89.However, it has been added by C99.
306C++:TheCompleteReference
Defining Inline Functions Within a Class
It is possible to define short functions completely within a class declaration. When afunction is defined inside a class declaration, it is automatically made into aninlinefunction (if possible). It is not necessary (but not an error) to precede its declaration

with theinlinekeyword. For example, the preceding program is rewritten here with
the definitions ofinit( )andshow( )contained within the declaration ofmyclass:#include <iostream>using namespace std;class myclass {int a, b;public:// automatic inlinevoid init(int i, int j) { a=i; b=j; }
void show() { cout << a << " " << b << "\n"; }};int main(){myclass x;x.init(10, 20);x.show();return 0;}Notice the format of the function code withinmyclass. Because inline functions are
often short, this style of coding within a class is fairly typical. However, you are free
to use any format you like. For example, this is a perfectly valid way to rewrite the

myclassdeclaration:#include <iostream>using namespace std;class myclass {int a, b;public:// automatic inlinevoid init(int i, int j)
{a = i;Chapter12:ClassesandObjects
307C++b = j;}void show(){cout << a << " " << b << "\n";}};Technically, the inlining of the
show( )function is of limited value because (ingeneral) the amount of time the I/O statement will take far exceeds the overhead
of a function call. However, it is extremely common to see all short member functions

defined inside their class in C++ programs. (In fact, it is rare to see short member

functions defined outside their class declarations in professionally written C++ code.)
Constructor and destructor functions may also be inlined, either by default, if
defined within their class, or explicitly.
Parameterized Constructors
It is possible to pass arguments to constructors. Typically, these arguments help

initialize an object when it is created. To create a parameterized constructor, simply

add parameters to it the way you would to any other function. When you define the
constructor's body, use the parameters to initialize the object. For example, here is a

simple class that includes a parameterized constructor:
#include <iostream>using namespace std;class myclass {int a, b;public:myclass(int i, int j) {a=i; b=j;}void show() {cout << a << " " << b;}};int main(){myclass ob(3, 5);ob.show();
return 0;}308C++:TheCompleteReference
Notice that in the definition ofmyclass( ),the parametersiandjare used to give initial
values toaandb.The program illustrates the most common way to specify arguments when you
declare an object that uses a parameterized constructor. Specifically, this statement
myclass ob(3, 4);causes an object calledobto be created and passes the arguments
3and4to theiandjparameters ofmyclass( ). You may also pass arguments using this type of declaration
statement:myclass ob = myclass(3, 4);However, the first method is the one generally used, and this is the approach taken
by most of the examples in this book. Actually, there is a small technical difference

between the two types of declarations that relates to copy constructors. (Copy

constructors are discussed in Chapter 14.)
Here is another example that uses a parameterized constructor. It creates a class
that stores information about library books.
#include <iostream>#include <cstring>
using namespace std;const int IN = 1;const int CHECKED_OUT = 0;class book {char author[40];char title[40];
int status;public:book(char *n, char *t, int s);
int get_status() {return status;}
void set_status(int s) {status = s;}
void show();};book::book(char *n, char *t, int s){strcpy(author, n);Chapter12:ClassesandObjects
309C++strcpy(title, t);status = s;}void book::show(){cout << title << " by " << author;cout << " is ";
if(status==IN) cout << "in.\n";
else cout << "out.\n";}int main(){book b1("Twain", "Tom Sawyer", IN);
book b2("Melville", "Moby Dick", CHECKED_OUT);b1.show();b2.show();return 0;}Parameterized constructors are very useful because they allow you to avoid having
to make an additional function call simply to initialize one or more variables in an
object. Each function call you can avoid makes your program more efficient. Also,

notice that the shortget_status( )andset_status( )functions are defined in line, within
thebookclass. This is a common practice when writing C++ programs.
Constructors with One Parameter: A Special Case
If a constructor only has one parameter, there is a third way to pass an initial value to

that constructor. For example, consider the following short program.
#include <iostream>using namespace std;class X {int a;public:310C++:TheCompleteReference
X(int j) { a = j; }int geta() { return a; }};int main(){X ob = 99; // passes 99 to jcout << ob.geta(); // outputs 99
return 0;}Here, the constructor for
Xtakes one parameter. Pay special attention to how
obis declared in
main( ). In this form of initialization, 99 is automatically passed to thejparameter in theX( )constructor. That is, the declaration statement is handled by the
compiler as if it were written like this:
X ob = X(99);In general, any time you have a constructor that requires only one argument, you
can use eitherob(i) orob=ito initialize an object. The reason for this is that whenever
you create a constructor that takes one argument, you are also implicitly creating a
conversion from the type of that argument to the type of the class.
Remember that the alternative shown here applies only to constructors that have
exactly one parameter.
Static Class MembersBoth function and data members of a class can be madestatic. This section explains theconsequences of each.Static Data MembersWhen you precede a member variable's declaration with
static, you are telling the
compiler that only one copy of that variable will exist and that all objects of the class
will share that variable. Unlike regular data members, individual copies of a
staticmember variable are not made for each object. No matter how many objects of a class

are created, only one copy of a
staticdata member exists. Thus, all objects of that classuse that same variable. Allstaticvariables are initialized to zero before the first object
is created.
Chapter12:ClassesandObjects
311C++When you declare a
staticdata member within a class, you are
notdefining it. (Thatis, you are not allocating storage for it.) Instead, you must provide a global definition
for it elsewhere, outside the class. This is done by redeclaring the
staticvariable usingthescoperesolutionoperatortoidentifytheclasstowhichitbelongs.Thiscausesstorage

forthevariabletobeallocated.(Remember,aclassdeclarationissimplyalogical

construct that does not have physical reality.)
To understand the usage and effect of a
staticdata member, consider this program:
#include <iostream>using namespace std;class shared {static int a;int b;public:void set(int i, int j) {a=i; b=j;}
void show();} ;int shared::a; // define a
void shared::show(){cout << "This is static a: " << a;
cout << "\nThis is non-static b: " << b;
cout << "\n";}int main(){shared x, y;x.set(1, 1); // set a to 1x.show();y.set(2, 2); // change a to 2y.show();x.show(); /* Here, a has been changed for both x and ybecause a is shared by both objects. */return 0;}This program displays the following output when run.
This is static a: 1This is non-static b: 1
This is static a: 2
This is non-static b: 2
This is static a: 2
This is non-static b: 1Notice that the integerais declared both inside
sharedand outside of it. Asmentioned earlier, this is necessary because the declaration of
ainsideshareddoesnot allocate storage.As a convenience, older versions of C++ did not require the second declaration of a
staticmember variable. However, this convenience gave rise to serious inconsistencies
and it was eliminated several years ago. However, you may still find older C++ code

that does not redeclare
staticmember variables. In these cases, you will need to add therequired definitions.
Astaticmember variable existsbefore
any object of its class is created. For example,
in the following short program,
ais bothpublicandstatic. Thus it may be directly
accessed inmain( ). Further, since
aexists before an object of
sharedis created,
acanbe given a value at any time. As this program illustrates, the value of
ais unchangedby the creation of object
x. For this reason, both output statements display the same
value: 99.#include <iostream>using namespace std;class shared {public:static int a;} ;int shared::a; // define a
int main(){// initialize a before creating any objects
shared::a = 99;cout << "This is initial value of a: " << shared::a;312C++:TheCompleteReference
cout << "\n";shared x;
cout << "This is x.a: " << x.a;
return 0;}Noticehow
aisreferredtothroughtheuseoftheclassnameandthescoperesolution
operator.Ingeneral,torefertoa
staticmemberindependentlyofanobject,youmust
qualifyitbyusingthenameoftheclassofwhichitisamember.
One use of astaticmember variable is to provide access control to some shared
resource used by all objects of a class. For example, you might create several objects,
each of which needs to write to a specific disk file. Clearly, however, only one object

can be allowed to write to the file at a time. In this case, you will want to declare a

staticvariable that indicates when the file is in use and when it is free. Each object then
interrogates this variable before writing to the file. The following program shows how

you might use astaticvariable of this type to control access to a scarce resource:
#include <iostream>using namespace std;class cl {static int resource;public:int get_resource();void free_resource() {resource = 0;}};int cl::resource; // define resource
int cl::get_resource(){if(resource) return 0; // resource already in use
else {resource = 1;
return 1;  // resource allocated to this object}}Chapter12:ClassesandObjects
313C++314C++:TheCompleteReference
int main(){cl ob1, ob2;if(ob1.get_resource()) cout << "ob1 has resource\n";
if(!ob2.get_resource()) cout << "ob2 denied resource\n";
ob1.free_resource();  // let someone else use it
if(ob2.get_resource())cout << "ob2 can now use resource\n";return 0;}Another interesting use of a
staticmember variable is to keep track of the numberof objects of a particular class type that are in existence. For example,
#include <iostream>using namespace std;class Counter {public:static int count;
Counter() { count++; }
~Counter() { count--; }};
int Counter::count;void f();
int main(void){Counter o1;
cout << "Objects in existence: ";
cout << Counter::count << "\n";Counter o2;cout << "Objects in existence: ";
cout << Counter::count << "\n";f();cout << "Objects in existence: ";
cout << Counter::count << "\n";return 0;}
void f(){Counter temp;
cout << "Objects in existence: ";
cout << Counter::count << "\n";
// temp is destroyed when f() returns}This program produces the following output.
Objects in existence: 1
Objects in existence: 2
Objects in existence: 3
Objects in existence: 2As you can see, thestaticmember variablecountis incremented whenever an object is
created and decremented when an object is destroyed. This way, it keeps track of how
many objects of typeCounterare currently in existence.
Byusing
staticmembervariables,youshouldbeabletovirtuallyeliminateany
need for global variables. The trouble with global variables relative to OOPis that they

almost always violate the principle of encapsulation.Static Member FunctionsMember functions may also be declared as
static. There are several restrictions placed
onstaticmember functions. They may only directly refer to other
staticmembers of theclass.(Ofcourse,globalfunctionsanddatamaybeaccessedby
staticmemberfunctions.)
Astaticmember function does not have athispointer. (See Chapter 13 for information
onthis.) There cannot be a
staticand a non-staticversion of the same function. Astaticmemberfunctionmaynotbevirtual.Finally,theycannotbedeclaredas
constorvolatile.Following is a slightly reworked version of the shared-resource program from the
previous section. Notice that
get_resource( )is now declared as
static. As the program
illustrates,get_resource()
maybecalledeitherbyitself,independentlyofanyobject,by
using the class name and the scope resolution operator, or in connection with an object.
Chapter12:ClassesandObjects
315C++#include <iostream>using namespace std;class cl {static int resource;public:static int get_resource();void free_resource() { resource = 0; }};int cl::resource; // define resource
int cl::get_resource(){if(resource) return 0; // resource already in use
else {resource = 1;
return 1;  // resource allocated to this object}}int main(){cl ob1, ob2;/* get_resource() is static so may be called independentof any object. */if(cl::get_resource()) cout << "ob1 has resource\n";
if(!cl::get_resource()) cout << "ob2 denied resource\n";
ob1.free_resource();
if(ob2.get_resource()) // can still call using object syntaxcout << "ob2 can now use resource\n";return 0;}Actually,
staticmember functions have limited applications, but one good usefor them is to "preinitialize" private
staticdata before any object is actually created. For
example, this is a perfectly valid C++ program:
316C++:TheCompleteReference
Chapter12:ClassesandObjects
317C++#include <iostream>using namespace std;class static_type {static int i;public:static void init(int x) {i = x;}void show() {cout << i;}};int static_type::i; // define i
int main(){// init static data before object creation
static_type::init(100);static_type x;x.show(); // displays 100return 0;}When Constructors and Destructors
Are Executed
As a general rule, an object's constructor is called when the object comes into existence,
and an object's destructor is called when the object is destroyed. Precisely when these

events occur is discussed here.
Alocal object's constructor is executed when the object's declaration statement is
encountered. The destructors for local objects are executed in the reverse order of the

constructor functions.
Globalobjectshavetheirconstructorsexecute
before
main()
beginsexecution.Global
constructors are executed in order of their declaration, within the same file. You cannot

know the order of execution of global constructors spread among several files. Global

destructors execute in reverse order
aftermain( )has terminated.This program illustrates when constructors and destructors are executed:
#include <iostream>using namespace std;318C++:TheCompleteReference
class myclass {public:int who;myclass(int id);
~myclass();} glob_ob1(1), glob_ob2(2);myclass::myclass(int id){cout << "Initializing " << id << "\n";
who = id;}myclass::~myclass(){cout << "Destructing " << who << "\n";}int main(){myclass local_ob1(3);cout << "This will not be first line displayed.\n";
myclass local_ob2(4);
return 0;}It displays this output:Initializing 1Initializing 2
Initializing 3
This will not be first line displayed.
Initializing 4
Destructing 4
Destructing 3
Destructing 2
Destructing 1One thing: Because of differences between compilers and execution environments, you
may or may not see the last two lines of output.Chapter12:ClassesandObjects
319C++The Scope Resolution OperatorAs you know, the
::operator links a class name with a member name in order to
tell the compiler what class the member belongs to. However, the scope resolution
operator has another related use: it can allow access to a name in an enclosing scope

that is "hidden" by a local declaration of the same name. For example, consider this
fragment:int i;  // global ivoid f(){int i; // local ii = 10; // uses local i.
.
.}As the comment suggests, the assignmenti = 10refers to the local
i. But what iffunctionf( )needs to access the global version ofi? It may do so by preceding the
iwith the::operator, as shown here.
int i;  // global ivoid f(){int i; // local i::i = 10; // now refers to global i.
.
.}Nested ClassesItispossibletodefineoneclasswithinanother.Doingsocreatesa
nestedclass.Since
aclassdeclarationdoes,infact,defineascope,anestedclassisvalidonlywithin
thescopeoftheenclosingclass.Frankly,nestedclassesareseldomused.Becauseof
C++'sflexibleandpowerfulinheritancemechanism,theneedfornestedclassesis

virtuallynonexistent.
320C++:TheCompleteReference
Local ClassesAclass may be defined within a function. For example, this is a valid C++ program:
#include <iostream>using namespace std;void f();
int main(){f();// myclass not known here
return 0;}void f(){class myclass {int i;public:void put_i(int n) { i=n; }
int get_i() { return i; }} ob;ob.put_i(10);cout << ob.get_i();}When a class is declared within a function, it is known only to that function and
unknown outside of it.Several restrictions apply to local classes. First, all member functions must be
defined within the classdeclaration. The local class may not use or access local
variables of the function in which it is declared (except that a local class has access

tostaticlocal variables declared within the function or those declared as
extern). Itmay access type names and enumerators defined by the enclosing function, however.

Nostaticvariables may be declared inside a local class. Because of these restrictions,
local classes are not common in C++ programming.
Passing Objects to FunctionsObjects may be passed to functions in just the same way that any other type of
variable can. Objects are passed to functions through the use of the standard call-by-

value mechanism. Although the passing of objects is straightforward, some rather
Chapter12:ClassesandObjects
321C++unexpected events occur that relate to constructors and destructors. To understand
why, consider this short program.
// Passing an object to a function.#include <iostream>
using namespace std;class myclass {int i;public:myclass(int n);~myclass();
void set_i(int n) { i=n; }
int get_i() { return i; }};myclass::myclass(int n){i = n;
cout << "Constructing " << i << "\n";}myclass::~myclass(){cout << "Destroying " << i << "\n";}void f(myclass ob);
int main(){myclass o(1);f(o);cout << "This is i in main: ";
cout << o.get_i() << "\n";return 0;}
void f(myclass ob){ob.set_i(2);cout << "This is local i: " << ob.get_i();cout << "\n";}This program produces this output:
Constructing 1This is local i: 2
Destroying 2
This is i in main: 1
Destroying 1As the output shows, there is one call to the constructor, which occurs when
oiscreated in
main( ), but there are
twocalls to the destructor. Let's see why this is the case.
When an object is passed to a function, a copy of that object is made (and this copybecomestheparameterinthefunction).Thismeansthatanewobjectcomesinto
existence. When the function terminates, the copy of the argument (i.e., the parameter)

is destroyed. This raises two fundamental questions: First, is the object's constructor

called when the copy is made? Second, is the object's destructor called when the copy

is destroyed? The answers may, at first, surprise you.
When a copy of an argument is made during a function call, the normal constructor
isnotcalled. Instead, the object'scopyconstructor
is called. Acopy constructor defines
how a copy of an object is made. As explained in Chapter 14, you can explicitly define
a copy constructor for a class that you create . However, if a class does not explicitly

define a copy constructor, as is the case here, then C++ provides one by default. The

defaultcopyconstructorcreatesabitwise(thatis,identical)copyoftheobject.The

reasonabitwisecopyismadeiseasytounderstandifyouthinkaboutit.Sinceanormal

constructor is used to initialize some aspect of an object, it must not be called to make

a copy of an already existing object. Such a call would alter the contents of the object.

When passing an object to a function, you want to use the current state of the object,

not its initial state.However, when the function terminates and the copy of the object used as an
argument is destroyed, the destructor
iscalled. This is necessary because the object hasgone out of scope. This is why the preceding program had two calls to the destructor.

Thefirstwaswhentheparameterto
f()
wentout-of-scope.Thesecondiswhen
oinsidemain( )was destroyed when the program ended.
To summarize: When a copy of an object is created to be used as an argument to
a function, the normal constructor is not called. Instead, the default copy constructor

makes a bit-by-bit identical copy. However, when the copy is destroyed (usually by

going out of scope when the function returns), the destructor is called.
Becausethedefaultcopyconstructorcreatesanexactduplicateoftheoriginal,it
can,attimes,beasourceoftrouble.Eventhoughobjectsarepassedtofunctionsby

meansofthenormalcall-by-valueparameterpassingmechanismwhich,intheory,
322C++:TheCompleteReference
Chapter12:ClassesandObjects
323C++protects and insulates the calling argument, it is still possible for a side effect to occur
that may affect, or even damage, the object used as an argument. For example, if an

objectusedasanargumentallocatesmemoryandfreesthatmemorywhenitis

destroyed, then its local copy inside the function will free the same memory when its

destructor is called. This will leave the original object damaged and effectively useless.

To prevent this type of problem you will need to define the copy operation by creating

a copy constructor for the class, as explained in Chapter 14.
Returning Objects
Afunction may return an object to the caller. For example, this is a valid C++ program:
// Returning objects from a function.#include <iostream>
using namespace std;class myclass {int i;public:void set_i(int n) { i=n; }int get_i() { return i; }};myclass f();  // return object of type myclass
int main(){myclass o;o = f();
cout << o.get_i() << "\n";
return 0;}
myclass f(){myclass x;x.set_i(1);return x;}When an object is returned by a function, a temporary object is automatically
created that holds the return value. It is this object that is actually returned by the
function. After the value has been returned, this object is destroyed. The destruction

of this temporary object may cause unexpected side effects in some situations. For

example, if the object returned by the function has a destructor that frees dynamically

allocated memory, that memory will be freed even though the object that is receiving

the return value is still using it. There are ways to overcome this problem that involve

overloading the assignment operator (see Chapter 15) and defining a copy constructor

(see Chapter 14).Object AssignmentAssuming that both objects are of the same type, you can assign one object to another.

This causes the data of the object on the right side to be copied into the data of the
object on the left. For example, this program displays
99:// Assigning objects.#include <iostream>
using namespace std;class myclass {int i;public:void set_i(int n) { i=n; }int get_i() { return i; }};int main(){myclass ob1, ob2;ob1.set_i(99);ob2 = ob1; // assign data from ob1 to ob2cout << "This is ob2's i: " << ob2.get_i();
return 0;}By default, all data from one object is assigned to the other by use of a bit-by-bit
copy. However, it is possible to overload the assignment operator and define some
other assignment procedure (see Chapter 15).
324C++:TheCompleteReference
Chapter13
Arrays, Pointers, References,and the Dynamic Allocation
Operators325Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
In Part One, pointers and arrays were examined as they relate to C++'s built-intypes. Here, they are discussed relative to objects. This chapter also looks at a
feature related to the pointer called areference. The chapter concludes with anexamination of C++'s dynamic allocation operators.Arrays of ObjectsIn C++, it is possible to have arrays of objects. The syntax for declaring and using an
object array is exactly the same as it is for any other type of array. For example, this

program uses a three-element array of objects:
#include <iostream>using namespace std;class cl {int i;public:void set_i(int j) { i=j; }int get_i() { return i; }};int main(){cl ob[3];
int i;for(i=0; i<3; i++) ob[i].set_i(i+1);
for(i=0; i<3; i++)cout << ob[i].get_i() << "\n";return 0;}This program displays the numbers
1,2, and3on the screen.
If a class defines a parameterized constructor, you may initialize each object in
an array by specifying an initialization list, just like you do for other types of arrays.However,theexactformoftheinitializationlistwillbedecidedbythenumberof

parameters required by the object's constructors. For objects whose constructors have

only one parameter, you can simply specify a list of initial values, using the normal

array-initialization syntax. As each element in the array is created, a value from the
326C++:TheCompleteReference
list is passed to the constructor's parameter. For example, here is a slightly different
version of the preceding program that uses an initialization:
#include <iostream>using namespace std;class cl {int i;public:cl(int j) { i=j; } // constructorint get_i() { return i; }};int main(){cl ob[3] = {1, 2, 3}; // initializers
int i;for(i=0; i<3; i++)cout << ob[i].get_i() << "\n";return 0;}As before, this program displays the numbers
1,2, and3on the screen.
Actually, the initialization syntax shown in the preceding program is shorthand for
this longer form:cl ob[3] = { cl(1), cl(2), cl(3) };Here, the constructor for
clis invoked explicitly. Of course, the short form used in the
program is more common. The short form works because of the automatic conversion
that applies to constructors taking only one argument (see Chapter 12). Thus, the short

form can only be used to initialize object arrays whose constructors only require one

argument.
If an object's constructor requires two or more arguments, you will have to use the
longer initialization form. For example,#include <iostream>using namespace std;Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
327C++class cl {int h;int i;public:cl(int j, int k) { h=j; i=k; } // constructor with 2 parametersint get_i() {return i;}
int get_h() {return h;}};int main(){cl ob[3] = {cl(1, 2), // initialize
cl(3, 4),
cl(5, 6)};int i;
for(i=0; i<3; i++) {cout << ob[i].get_h();cout << ", ";
cout << ob[i].get_i() << "\n";}return 0;}Here,
cl's constructor has two parameters and, therefore, requires two arguments. This
meansthattheshorthandinitializationformatcannotbeusedandthelongform,shown
in the example, must be employed.Creating Initialized vs. Uninitialized Arrays
Aspecial case situation occurs if you intend to create both initialized and uninitialized

arrays of objects. Consider the followingclass.class cl {int i;public:cl(int j) { i=j; }328C++:TheCompleteReference
Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
329C++int get_i() { return i; }};Here, the constructor defined by
clrequires one parameter. This implies that any array
declared of this type must be initialized. That is, it precludes this array declaration:
cl a[9]; // error, constructor requires initializersThe reason that this statement isn't valid (as
clis currently defined) is that it implies
thatclhas a parameterless constructor because no initializers are specified. However,
as it stands,cldoes not have a parameterless constructor. Because there is no valid
constructor that corresponds to this declaration, the compiler will report an error.
To solve this problem, you need to overload the constructor, adding one that takes

no parameters, as shown next. In this way, arrays that are initialized and those that

are not are both allowed.
class cl {int i;public:cl() { i=0; } // called for non-initialized arrayscl(int j) { i=j; } // called for initialized arrays
int get_i() { return i; }};Given thisclass, both of the following statements are permissible:
cl a1[3] = {3, 5, 6}; // initializedcl a2[34]; // uninitializedPointers to ObjectsJustasyoucanhavepointerstoothertypesofvariables,youcanhavepointersto
objects. When accessing members of a class given a pointer to an object, use the arrow

(–>) operator instead of the dot operator. The next program illustrates how to access an

object given a pointer to it:#include <iostream>using namespace std;330C++:TheCompleteReference
class cl {int i;public:cl(int j) { i=j; }int get_i() { return i; }};int main(){cl ob(88), *p;p = &ob; // get address of ob
cout << p->get_i(); // use -> to call get_i()
return 0;}Asyouknow,whenapointerisincremented,itpointstothenextelementofitstype.
Forexample,anintegerpointerwillpointtothenextinteger.Ingeneral,allpointer
arithmetic is relative to the base type of the pointer. (That is, it is relative to the type of

data that the pointer is declared as pointing to.) The same is true of pointers to objects.

For example, this program uses a pointer to access all three elements of array
obafterbeing assignedob's starting address:
#include <iostream>using namespace std;class cl {int i;public:cl() { i=0; }cl(int j) { i=j; }
int get_i() { return i; }};int main(){cl ob[3] = {1, 2, 3};C++cl *p;int i;p = ob; // get start of arrayfor(i=0; i<3; i++) {cout << p->get_i() << "\n";p++; // point to next object}return 0;}You can assign the address of a public member of an object to a pointer and then
access that member by using the pointer. For example, this is a valid C++ program
that displays the number1on the screen:
#include <iostream>using namespace std;class cl {public:int i;
cl(int j) { i=j; }};int main(){cl ob(1);int *p;p = &ob.i; // get address of ob.i
cout << *p; // access ob.i via p
return 0;}Becausepis pointing to an integer, it is declared as an integer pointer. It is irrelevant
thatiis a member ofobin this situation.Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
331Type Checking C++ Pointers
ThereisoneimportantthingtounderstandaboutpointersinC++:Youmayassignone
pointertoanotheronlyifthetwopointertypesarecompatible.Forexample,given:
int *pi;float *pf;in C++, the following assignment is illegal:pi = pf; // error -- type mismatchOf course, you can override any type incompatibilities using a cast, but doing sobypasses C++'s type-checking mechanism.The this PointerWhen a member function is called, it is automatically passed an implicit argument that

isapointertotheinvokingobject(thatis,theobjectonwhichthefunctioniscalled).

Thispointeriscalled
this.Tounderstand
this,firstconsideraprogramthatcreates
a class calledpwrthat computes the result of a number raised to some power:
#include <iostream>using namespace std;class pwr {double b;int e;
double val;public:pwr(double base, int exp);
double get_pwr() { return val; }};pwr::pwr(double base, int exp){b = base;
e = exp;
val = 1;
if(exp==0) return;
for( ; exp>0; exp--) val = val * b;332C++:TheCompleteReference
}int main(){pwr x(4.0, 2), y(2.5, 1), z(5.7, 0);cout << x.get_pwr() << " ";cout << y.get_pwr() << " ";
cout << z.get_pwr() << "\n";return 0;}Within a member function, the members of a class can be accessed directly, without
any object or class qualification. Thus, insidepwr( ), the statementb = base;means that the copy ofbassociated with the invoking object will be assigned the valuecontained inbase. However, the same statement can also be written like this:
this->b = base;Thethispointer points to the object that invokedpwr( ). Thus,this –>brefers to that
object's copy ofb. For example, ifpwr( )had been invoked byx(as inx(4.0, 2)), thenthisin the preceding statement would have been pointing to
x.Writing the statement
without usingthisis really just shorthand.
Here is the entire
pwr( )constructor written using the
thispointer:pwr::pwr(double base, int exp){this->b = base;
this->e = exp;
this->val = 1;
if(exp==0) return;
for( ; exp>0; exp--)this->val = this->val * this->b;}Actually, no C++ programmer would write
pwr( )as just shown because nothingis gained, and the standard form is easier. However, the
thispointer is very importantChapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
333C++whenoperatorsareoverloadedandwheneveramemberfunctionmustutilizeapointer
to the object that invoked it.Remember that thethispointer is automatically passed to all member functions.Therefore,
get_pwr( )could also be rewritten as shown here:
double get_pwr() { return this->val; }In this case, ifget_pwr( )is invoked like this:y.get_pwr();thenthiswill point to objecty.Two final points about
this.First,
friendfunctions are not members of a class and,
therefore, are not passed a
thispointer. Second,
staticmember functions do not haveathispointer.
Pointers to Derived Types
In general, a pointer of one type cannot point to an object of a different type. However,

there is an important exception to this rule that relates only to derived classes. To begin,

assumetwoclassescalled
BandD.Further,assumethat
Disderivedfromthebase
classB.Inthissituation,apointeroftype
B*mayalsopointtoanobjectoftype
D.More generally, a base class pointer can also be used as a pointer to an object of any

class derived from that base.
Although a base class pointer can be used to point to a derived object, the oppositeis not true. Apointer of type
D *may not point to an object of typeB. Further, although
youcanuseabasepointertopointtoaderivedobject,youcanaccessonlythemembers

ofthederivedtypethatwereinheritedfromthebase.Thatis,youwon'tbeabletoaccess

any members added by the derived class. (You can cast a base pointer into a derived

pointer and gain full access to the entire derived class, however.)
Here is a short program that illustrates the use of a base pointer to access
derived objects.#include <iostream>using namespace std;class base {int i;public:void set_i(int num) { i=num; }int get_i() { return i; }334C++:TheCompleteReference
};class derived: public base {int j;public:void set_j(int num) { j=num; }int get_j() { return j; }};int main(){base *bp;
derived d;bp = &d; // base pointer points to derived object
// access derived object using base pointerbp->set_i(10);
cout << bp->get_i() << " ";/* The following won't work. You can't access elements ofa derived class using a base class pointer.bp->set_j(88); // errorcout << bp->get_j(); // error*/return 0;}As you can see, a base pointer is used to access an object of a derived class.Although you must be careful, it is possible to cast a base pointer into a pointer of
the derived type to access a member of the derived class through the base pointer. For
example, this is valid C++ code:// access now allowed because of cast((derived *)bp)->set_j(88);
cout << ((derived *)bp)->get_j();It is important to remember that pointer arithmetic is relative to the base type
of the pointer. For this reason, when a base pointer is pointing to a derived object,
incrementing the pointer does not cause it to point to the next object of the derived

type. Instead, it will point to what it thinks is the next object of the base type. This,Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
335C++of course, usually spells trouble. For example, this program, while syntactically correct,
contains this error.
// This program contains an error.#include <iostream>
using namespace std;class base {int i;public:void set_i(int num) { i=num; }int get_i() { return i; }};class derived: public base {int j;public:void set_j(int num) {j=num;}int get_j() {return j;}};int main(){base *bp;
derived d[2];bp = d;
d[0].set_i(1);d[1].set_i(2);cout << bp->get_i() << " ";bp++; // relative to base, not derived
cout << bp->get_i(); // garbage value displayedreturn 0;}The use of base pointers to derived types is most useful when creating run-time
polymorphism through the mechanism of virtual functions (see Chapter 17).
336C++:TheCompleteReference
Pointers to Class MembersC++ allows you to generate a special type of pointer that "points" generically to amember of a class, not to a specific instance of that member in an object. This sort of
pointer is called apointer to a class memberor apointer-to-member, for short. Apointer
to a member is not the same as a normal C++ pointer. Instead, a pointer to a member

provides only an offset into an object of the member's class at which that member can

be found. Since member pointers are not true pointers, the
.and–>cannot be appliedto them. To access a member of a class given a pointer to it, you must use the special

pointer-to-member operators
.*and–>*. Their job is to allow you to access a memberof a class given a pointer to that member.
Here is an example:
#include <iostream>using namespace std;class cl {public:cl(int i) { val=i; }
int val;
int double_val() { return val+val; }};int main(){int cl::*data; // data member pointer
int (cl::*func)(); // function member pointer
cl ob1(1), ob2(2); // create objectsdata = &cl::val; // get offset of valfunc = &cl::double_val; // get offset of double_val()cout << "Here are values: ";cout << ob1.*data << " " << ob2.*data << "\n";cout << "Here they are doubled: ";cout << (ob1.*func)() << " ";
cout << (ob2.*func)() << "\n";return 0;}Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
337C++Inmain()
,thisprogramcreatestwomemberpointers:
dataandfunc.Note
carefully the syntax of each declaration. When declaring pointers to members, you
must specify the class and use the scope resolution operator. The program also creates

objects ofclcalledob1andob2. As the program illustrates, member pointers may
point to either functions or data. Next, the program obtains the addresses of
valanddouble_val( ). As stated earlier, these “addresses” are really just offsets into an object

of typecl, at which pointvalanddouble_val( )will be found. Next, to display thevalues of each object'sval, each is accessed through
data. Finally, the program uses
functo call thedouble_val( )function. The extra parentheses are necessary in order
to correctly associate the
.*operator.
When you are accessing a member of an object by using an object or a reference
(discussed later in this chapter), you must use the.*operator. However, if you are
using a pointer to the object, you need to use the–>*operator, as illustrated in this
version of the preceding program:
#include <iostream>using namespace std;class cl {public:cl(int i) { val=i; }
int val;
int double_val() { return val+val; }};int main(){int cl::*data; // data member pointer
int (cl::*func)(); // function member pointer
cl ob1(1), ob2(2); // create objects
cl *p1, *p2;p1 = &ob1; // access objects through a pointerp2 = &ob2;data = &cl::val; // get offset of valfunc = &cl::double_val; // get offset of double_val()cout << "Here are values: ";cout << p1->*data << " " << p2->*data << "\n";cout << "Here they are doubled: ";338C++:TheCompleteReference
cout << (p1->*func)() << " ";cout << (p2->*func)() << "\n";return 0;}In this version,p1andp2are pointers to objects of type
cl. Therefore, the
–>*operatoris used to accessvalanddouble_val( ).Remember, pointers to members are different from pointers to specific instances of
elements of an object. Consider this fragment (assume thatclis declared as shown in
the preceding programs):
int cl::*d;int *p;
cl o;p = &o.val // this is address of a specific val
d = &cl::val // this is offset of generic valHere,
pis a pointer to an integer inside aspecificobject. However,
dis simply an offset
that indicates where
valwill be found in any object of typecl.In general, pointer-to-member operators are applied in special-case situations. They
are not typically used in day-to-day programming.
References
C++ contains a feature that is related to the pointer called a
reference
. Areference is
essentially an implicit pointer. There are three ways that a reference can be used: as
a function parameter, as a function return value, or as a stand-alone reference. Each

is examined here.
Reference Parameters
Probablythemostimportantuseforareferenceistoallowyoutocreatefunctions

that automatically use call-by-reference parameter passing. As explained in Chapter 6,

argumentscanbepassedtofunctionsinoneoftwoways:usingcall-by-valueor

call-by-reference. When using call-by-value, a copy of the argument is passed to the

function.Call-by-referencepassestheaddressoftheargumenttothefunction.By

default, C++ uses call-by-value, but it provides two ways to achieve call-by-reference

parameter passing. First, you can explicitly pass a pointer to the argument. Second,
Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
339C++you can use a reference parameter. For most circumstances the best way is to use
a reference parameter.
To fully understand what a reference parameter is and why it is valuable, we will
begin by reviewing how a call-by-reference can be generated using a pointer parameter.

The following program manually creates a call-by-reference parameter using a pointer

in the function calledneg( ),which reverses the sign of the integer variable pointed to
by its argument.
// Manually create a call-by-reference using a pointer.#include <iostream>
using namespace std;void neg(int *i);
int main(){int x;x = 10;cout << x << " negated is ";neg(&x);cout << x << "\n";return 0;}
void neg(int *i){*i = -*i;}In this program,
neg( )takes as a parameter a pointer to the integer whose sign itwill reverse. Therefore,
neg( )must be explicitly called with the address of
x. Further,
insideneg( )the*operator must be used to access the variable pointed to byi. Thisis how you generate a "manual" call-by-reference in C++, and it is the only way to
obtain a call-by-reference using the C subset. Fortunately, in C++ you can automate
this feature by using a reference parameter.
To create a reference parameter, precede the parameter's name with an
&. Forexample, here is how to declare
neg( )withideclared as a reference parameter:
void neg(int &i);340C++:TheCompleteReference
For all practical purposes, this causesito become another name for whatever argument
neg()
iscalledwith.Anyoperationsthatareappliedto
iactuallyaffectthecalling
argument.Intechnicalterms,
iisanimplicitpointerthatautomaticallyrefersto
the argument used in the call to
neg( ). Onceihas been made into a reference, it is no
longer necessary (or even legal) to apply the*operator. Instead, each time
iis used, itisimplicitlyareferencetotheargumentandanychangesmadeto
iaffecttheargument.
Further,whencalling
neg(),
itisnolongernecessary(orlegal)toprecedetheargument's
namewiththe
&operator.Instead,thecompilerdoesthisautomatically.Hereisthe
reference version of the preceding program:
// Use a reference parameter.#include <iostream>
using namespace std;void neg(int &i); // i now a reference
int main(){int x;x = 10;cout << x << " negated is ";neg(x); // no longer need the & operatorcout << x << "\n";return 0;}
void neg(int &i){i = -i; // i is now a reference, don't need *}To review: When you create a reference parameter, it automatically refers to (implicitly
points to) the argument used to call the function. Therefore, in the preceding program,

the statementi = -i ;actually operates onx,not on a copy ofx. There is no need to apply the
&operator toan argument. Also, inside the function, the reference parameter is used directly without
C++Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
341342C++:TheCompleteReference
the need to apply the*operator. In general, when you assign a value to a reference,
you are actually assigning that value to the variable that the reference points to.
Inside the function, it is not possible to change what the reference parameter is
pointing to. That is, a statement likei++:insideneg( )increments the value of the variable used in the call. It does not cause
ito point to some new location.Here is another example. This program uses reference parameters to swap the
values of the variables it is called with. Theswap( )function is the classic exampleof call-by-reference parameter passing.
#include <iostream>using namespace std;void swap(int &i, int &j);
int main(){int a, b, c, d;a = 1;b = 2;
c = 3;
d = 4;cout << "a and b: " << a << " " << b << "\n";swap(a, b); // no & operator needed
cout << "a and b: " << a << " " << b << "\n";cout << "c and d: " << c << " " << d << "\n";swap(c, d);
cout << "c and d: " << c << " " << d << "\n";return 0;}
void swap(int &i, int &j){int t;t = i; // no * operator neededChapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
343C++i = j;j = t;}This program displays the following:
a and b: 1 2a and b: 2 1
c and d: 3 4
c and d: 4 3Passing References to Objects
InChapter12itwasexplainedthatwhenanobjectispassedasanargumenttoafunction,
a copy of that object is made. When the function terminates, the copy's destructor is

called.However,whenyoupassbyreference,nocopyoftheobjectismade.This

means that no object used as a parameter is destroyed when the function terminates,

and the parameter's destructor is not called. For example, try this program:
#include <iostream>using namespace std;class cl {int id;public:int i;cl(int i);
~cl();
void neg(cl &o) { o.i = -o.i; } // no temporary created};cl::cl(int num){cout << "Constructing " << num << "\n";
id = num;}cl::~cl(){cout << "Destructing " << id << "\n";}344C++:TheCompleteReference
int main(){cl o(1);o.i = 10;o.neg(o);cout << o.i << "\n";
return 0;}Here is the output of this program:
Constructing 1-10
Destructing 1Asyoucansee,onlyonecallismadeto
cl'sdestructor.Had
obeenpassedbyvalue,
asecondobjectwouldhavebeencreatedinside
neg(),
andthedestructorwould
havebeencalledasecondtimewhenthatobjectwasdestroyedatthetime
neg()
terminated.As the code insideneg( )illustrates, when you access a member of a class through
a reference, you use the dot operator. The arrow operator is reserved for use with
pointers only.
When passing parameters by reference, remember that changes to the object inside
the function affect the calling object.
One other point: Passing all but the smallest objects by reference is faster than
passing them by value. Arguments are usually passed on the stack. Thus, large objects

take a considerable number of CPU cycles to push onto and pop from the stack.
Returning References
Afunction may return a reference. This has the rather startling effect of allowing a

function to be used on the left side of an assignment statement! For example, consider
this simple program:
#include <iostream>using namespace std;char &replace(int i); // return a referenceChapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
345C++char s[80] = "Hello There";int main(){replace(5) = 'X'; // assign X to space after Hellocout << s;
return 0;}
char &replace(int i){return s[i];}Thisprogramreplacesthespacebetween
HelloandTherewithan
X.Thatis,the
programdisplays
HelloXthere.Takealookathowthisisaccomplished.First,
replace()
isdeclaredasreturningareferencetoacharacter.As
replace()
iscoded,itreturnsa
referencetotheelementof
sthatisspecifiedbyitsargument
i.Thereferencereturned
byreplace()
isthenusedin
main()
toassigntothatelementthecharacter
X.One thing you must be careful about when returning references is that the object
being referred to does not go out of scope after the function terminates.
Independent References
By far the most common uses for references are to pass an argument using call-by-
reference and to act as a return value from a function. However, you can declare

a reference that is simply a variable. This type of reference is called an
independentreference
.When you create an independent reference, all you are creating is another name
foranobject.Allindependentreferencesmustbeinitializedwhentheyarecreated. The

reasonforthisiseasytounderstand.Asidefrominitialization,youcannotchange

whatobjectareferencevariablepointsto.Therefore,itmustbeinitializedwhenit

isdeclared. (In C++, initialization is a wholly separate operation from assignment.)
The following program illustrates an independent reference:
#include <iostream>using namespace std;346C++:TheCompleteReference
int main(){int a;int &ref = a; // independent referencea = 10;cout << a << " " << ref << "\n";ref = 100;cout << a << " " << ref << "\n";int b = 19;ref = b; // this puts b's value into a
cout << a << " " << ref << "\n";ref--; // this decrements a// it does not affect what ref refers tocout << a << " " << ref << "\n";
return 0;}The program displays this output:
10 10100 100
19 19
18 18Actually, independent references are of little real value because each one is, literally,
just another name for another variable. Having two names to describe the same objectis likely to confuse, not organize, your program.
References to Derived Types
Similar to the situation as described for pointers earlier, a base class reference can be

usedtorefertoanobjectofaderivedclass.Themostcommonapplicationofthisis

found in function parameters. Abase class reference parameter can receive objects of

the base class as well as any other type derived from that base.
Restrictions to References
Thereareanumberofrestrictionsthatapplytoreferences.Youcannotreferenceanother
reference.Putdifferently,youcannotobtaintheaddressofareference.Youcannotcreate

arrays of references. You cannot create a pointer to a reference. You cannot reference

a bit-field.Areference variable must be initialized when it is declared unless it is a member
of a class, a function parameter, or a return value. Null references are prohibited.
A Matter of StyleWhen declaring pointer and reference variables, some C++ programmers use a unique

coding style that associates the*or the&with the type name and not the variable. Forexample, here are two functionally equivalent declarations:
int& p; // & associated with typeint &p; // & associated with variableAssociating the*or&with the type name reflects the desire of some programmers
for C++ to contain a separate pointer type. However, the trouble with associating the
&or*withthetypenameratherthanthevariableisthat,accordingtotheformalC++
syntax, neither the&nor the*is distributive over a list of variables. Thus, misleadingdeclarations are easily created. For example, the following declaration creates
one, nottwo, integer pointers.int* a, b;Here,
bis declared as an integer (not an integer pointer) because, as specified by the
C++ syntax, when used in a declaration, the*(or&) is linked to the individual variablethat it precedes, not to the type that it follows. The trouble with this declaration is that
the visual message suggests that bothaandbare pointer types, even though, in fact,
onlyais a pointer. This visual confusion not only misleads novice C++ programmers,
but occasionally old pros, too.
Itisimportanttounderstandthat,asfarastheC++compilerisconcerned,itdoesn't
matter whether you writeint *porint* p.Thus, if you prefer to associate the
*or&with the type rather than the variable, feel free to do so. However, to avoid confusion,

this book will continue to associate the*and the&with the variables that they modifyrather than their types.C++'s Dynamic Allocation OperatorsC++ provides two dynamic allocation operators:
newanddelete. These operators are
used to allocate and free memory at run time. Dynamic allocation is an important part
Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
347C++348C++:TheCompleteReference
ofalmostallreal-worldprograms.AsexplainedinPartOne,C++alsosupports
dynamic memory allocation functions, calledmalloc( )andfree( ).These are included
for the sake of compatibility with C. However, for C++ code, you should use the
newanddeleteoperators because they have several advantages.Thenewoperator allocates memory and returns a pointer to the start of it. The
deleteoperator frees memory previously allocated using
new. The general forms ofnewanddeleteare shown here:
p_var= newtype;deletep_var;Here,
p_varis a pointer variable that receives a pointer to memory that is large enough
to hold an item of typetype.Since the heap is finite, it can become exhausted. If there is insufficient available
memorytofillanallocationrequest,then
newwillfailanda
bad_allocexceptionwillbe
generated.Thisexceptionisdefinedintheheader
<new>.Yourprogramshouldhandle
this exception and take appropriate action if a failure occurs. (Exception handling is

describedinChapter19.)Ifthisexceptionisnothandledbyyourprogram,thenyour

programwillbeterminated.
The actions ofnewon failure as just described are specified by Standard C++. The
trouble is that not all compilers, especially older ones, will have implemented
newincompliance with Standard C++. When C++ was first invented,
newreturned null on
failure. Later, this was changed such that
newcaused an exception on failure. Finally,
it was decided that anewfailure will generate an exception by default, but that a null
pointercouldbereturnedinstead,asanoption.Thus,
newhasbeenimplemented
differently, at different times, by compiler manufacturers. Although all compilers will

eventually implementnewin compliance with Standard C++, currently the only way
to know the precise action of
newon failure is to check your compiler's documentation.
Since Standard C++ specifies that
newgenerates an exception on failure, this is
the way the code in this book is written. If your compiler handles an allocation failure

differently, you will need to make the appropriate changes.
Here is a program that allocates memory to hold an integer:
#include <iostream>#include <new>
using namespace std;int main(){int *p;try {p = new int; // allocate space for an int} catch (bad_alloc xa) {cout << "Allocation Failure\n";return 1;}*p = 100;
cout << "At " << p << " ";cout << "is the value " << *p << "\n";delete p;
return 0;}This program assigns to
pan address in the heap that is large enough to hold an
integer. It then assigns that memory the value 100 and displays the contents of the
memory on the screen. Finally, it frees the dynamically allocated memory. Remember,

if your compiler implementsnewsuch that it returns null on failure, you must change
the preceding program appropriately.
Thedeleteoperator must be used only with a valid pointer previously allocated by
usingnew.Usinganyothertypeofpointerwith
deleteisundefinedandwillalmost
certainly cause serious problems, such as a system crash.
Althoughnewanddeleteperform functions similar tomalloc( )andfree( ), theyhaveseveraladvantages.First,
newautomaticallyallocatesenoughmemorytoholdan
objectofthespecifiedtype.Youdonotneedtousethe
sizeofoperator.Becausethesize
iscomputedautomatically,iteliminatesanypossibilityforerrorinthisregard.Second,

newautomaticallyreturnsapointerofthespecifiedtype.Youdon'tneedtousean
explicit type cast as you do when allocating memory by usingmalloc( ). Finally, both
newanddeletecanbeoverloaded,allowingyoutocreatecustomizedallocationsystems.
Although there is no formal rule that states this, it is best not to mix
newanddeletewithmalloc( )andfree( )in the same program. There is no guarantee that they are
mutually compatible.Initializing Allocated Memory
You can initialize allocated memory to some known value by putting an initializer

after the type name in thenewstatement. Here is the general form of
newwhen aninitialization is included:p_var= newvar_type (initializer);Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
349C++350C++:TheCompleteReference
Of course, the type of the initializer must be compatible with the type of data for whichmemory is being allocated.This program gives the allocated integer an initial value of 87:
#include <iostream>#include <new>
using namespace std;int main(){int *p;try {p = new int (87); // initialize to 87} catch (bad_alloc xa) {cout << "Allocation Failure\n";return 1;}cout << "At " << p << " ";cout << "is the value " << *p << "\n";delete p;
return 0;}Allocating ArraysYou can allocate arrays using
newby using this general form:p_var= newarray_type [size];Here,
sizespecifies the number of elements in the array.
To free an array, use this form of
delete:delete [ ]p_var;Here, the
[ ]informsdeletethat an array is being released.
For example, the next program allocates a 10-element integer array.
Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
351C++#include <iostream>#include <new>
using namespace std;int main(){int *p, i;try {p = new int [10]; // allocate 10 integer array} catch (bad_alloc xa) {cout << "Allocation Failure\n";return 1;}for(i=0; i<10; i++ )p[i] = i;for(i=0; i<10; i++)cout << p[i] << " ";delete [] p; // release the array
return 0;}Notice thedeletestatement. As just mentioned, when an array allocated bynewis released,
deletemust be made aware that an array is being freed by using the
[ ].(As you will see in the next section, this is especially important when you are allocating
arrays of objects.)One restriction applies to allocating arrays: They may not be given initial values.
That is, you may not specify an initializer when allocating arrays.Allocating ObjectsYou can allocate objects dynamically by using
new. When you do this, an object iscreated and a pointer is returned to it. The dynamically created object acts just like

any other object. When it is created, its constructor (if it has one) is called. When the

object is freed, its destructor is executed.
Here is a short program that creates a class called
balancethat links a person'sname with his or her account balance. Insidemain( ), an object of typebalanceiscreated dynamically.
#include <iostream>#include <new>
#include <cstring>
using namespace std;class balance {double cur_bal;char name[80];public:void set(double n, char *s) {cur_bal = n;
strcpy(name, s);}void get_bal(double &n, char *s) {n = cur_bal;strcpy(s, name);}};int main(){balance *p;
char s[80];
double n;try {p = new balance;} catch (bad_alloc xa) {cout << "Allocation Failure\n";return 1;}p->set(12387.87, "Ralph Wilson");
p->get_bal(n, s);
cout << s << "'s balance is: " << n;352C++:TheCompleteReference
Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
353C++cout << "\n";delete p;
return 0;}Becausepcontains a pointer to an object, the arrow operator is used to access members
of the object.As stated, dynamically allocated objects may have constructors and destructors.
Also, the constructors  can be parameterized. Examine this version of the previous
program:
#include <iostream>#include <new>
#include <cstring>
using namespace std;class balance {double cur_bal;char name[80];public:balance(double n, char *s) {cur_bal = n;
strcpy(name, s);}
~balance() {cout << "Destructing ";
cout << name << "\n";}
void get_bal(double &n, char *s) {n = cur_bal;
strcpy(s, name);}};int main(){balance *p;
char s[80];
double n;// this version uses an initializertry {p = new balance (12387.87, "Ralph Wilson");} catch (bad_alloc xa) {cout << "Allocation Failure\n";return 1;}p->get_bal(n, s);
cout << s << "'s balance is: " << n;cout << "\n";delete p;
return 0;}Notice that the parameters to the object's constructor are specified after the type name,
just as in other sorts of initializations.You can allocate arrays of objects, but there is one catch. Since no array allocated by
newcan have an initializer, you must make sure that if the class contains constructors,
onewillbeparameterless.Ifyoudon't,theC++compilerwillnotfindamatching

constructor when you attempt to allocate the array and will not compile your program.
In this version of the preceding program, an array of
balanceobjects is allocated,and the parameterless constructor is called.
#include <iostream>#include <new>
#include <cstring>
using namespace std;class balance {double cur_bal;char name[80];public:balance(double n, char *s) {cur_bal = n;
strcpy(name, s);}
balance() {} // parameterless constructor354C++:TheCompleteReference
Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
355C++~balance() {cout << "Destructing ";cout << name << "\n";}void set(double n, char *s) {cur_bal = n;strcpy(name, s);}void get_bal(double &n, char *s) {n = cur_bal;
strcpy(s, name);}};int main(){balance *p;
char s[80];
double n;
int i;try {p = new balance [3]; // allocate entire array} catch (bad_alloc xa) {cout << "Allocation Failure\n";return 1;}// note use of dot, not arrow operatorsp[0].set(12387.87, "Ralph Wilson");
p[1].set(144.00, "A. C. Conners");
p[2].set(-11.23, "I. M. Overdrawn");for(i=0; i<3; i++) {p[i].get_bal(n, s);
cout << s << "'s balance is: " << n;cout << "\n";}delete [] p;return 0;}356C++:TheCompleteReference
The output from this program is shown here.
Ralph Wilson's balance is: 12387.9A. C. Conners's balance is: 144
I. M. Overdrawn's balance is: -11.23
Destructing I. M. Overdrawn
Destructing A. C. Conners
Destructing Ralph WilsonOne reason that you need to use the
delete [ ]form when deleting an array ofdynamically allocated objects is so that the destructor can be called for each object
in the array.
The nothrow Alternative
In Standard C++ it is possible to have
newreturn
nullinstead of throwing an exception
whenanallocationfailureoccurs.Thisformof
newismostusefulwhenyouarecompiling
oldercodewithamodernC++compiler.Itisalsovaluablewhenyouarereplacingcalls

tomalloc( )withnew. (This is common when updating C code to C++.) This form ofnewis shown here:
p_var= new(nothrow)type;Here,
p_varisapointervariableof
type.The
nothrowformof
newworkslikethe
originalversionof
newfromyearsago.Sinceitreturnsnullonfailure,itcanbe
"droppedinto"oldercodewithouthavingtoaddexceptionhandling.However,

for new code, exceptions provide a better alternative. To use the
nothrowoption,you must include the header<new>.The following program shows how to use the
new(nothrow)alternative.// Demonstrate nothrow version of new.#include <iostream>
#include <new>
using namespace std;int main(){int *p, i;p = new(nothrow) int[32]; // use nothrow optionif(!p) {cout << "Allocation failure.\n";Chapter13:Arrays,Pointers,References,andtheDynamicAllocationOperators
357C++return 1;}for(i=0; i<32; i++) p[i] = i;
for(i=0; i<32; i++) cout << p[i] << " ";
delete [] p; // free the memory
return 0;}As this program demonstrates, when using the
nothrowapproach, you must check the
pointer returned by
newafter each allocation request.
The Placement Form of new
There is a special form of
new, called theplacementform
, that can be used to specify analternative method of allocating memory. It is primarily useful when overloading the
newoperator for special circumstances. Here is its general form:
p_var= new (arg-list)type;Here,
arg-list
is a comma-separated list of values passed to an overloaded form ofnew.This page intentionally left blank Chapter14
Function Overloading,Copy Constructors,
and Default Arguments359Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
Thischapterexaminesfunctionoverloading,copyconstructors,anddefault
arguments.FunctionoverloadingisoneofthedefiningaspectsoftheC++

programminglanguage.Notonlydoesitprovidesupportforcompile-time
polymorphism, it also adds flexibility and convenience. Some of the most commonly
overloadedfunctionsareconstructors.Perhapsthemostimportantformofanoverloaded

constructor is the copy constructor. Closely related to function overloading are default
arguments. Default arguments can sometimes provide an alternative to function
overloading.Function OverloadingFunction overloading is the process of using the same name for two or more functions.

Thesecrettooverloadingisthateachredefinitionofthefunctionmustuseeither

different types of parameters or a different number of parameters. It is only through

these differences that the compiler knows which function to call in any given situation.

For example, this program overloads
myfunc( )by using different types of parameters.
#include <iostream>using namespace std;int myfunc(int i); // these differ in types of parametersdouble myfunc(double i);int main(){cout << myfunc(10) << " "; // calls myfunc(int i)
cout << myfunc(5.4); // calls myfunc(double i)return 0;}
double myfunc(double i){return i;}int myfunc(int i){return i;}360C++:TheCompleteReference
The next program overloads
myfunc( )using a different number of parameters:
#include <iostream>using namespace std;int myfunc(int i); // these differ in number of parametersint myfunc(int i, int j);int main(){cout << myfunc(10) << " "; // calls myfunc(int i)
cout << myfunc(4, 5); // calls myfunc(int i, int j)return 0;}
int myfunc(int i){return i;}int myfunc(int i, int j){return i*j;}As mentioned, the key point about function overloading is that the functions mustdiffer in regard to the types and/or number of parameters. Two functions differing
only in their return types cannot be overloaded. For example, this is an invalid attempt

to overloadmyfunc( ):int myfunc(int i);   // Error: differing return types arefloat myfunc(int i); // insufficient when overloading.Sometimes, two function declarations will appear to differ, when in fact they do not.
For example, consider the following declarations.void f(int *p);void f(int p[]); // error, *p is same as p[]Remember, to the compiler
*pis the same asp[ ].Therefore, although the two
prototypes appear to differ in the types of their parameter, in actuality they do not.
Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
361C++Overloading Constructors
Constructors can be overloaded; in fact, overloaded constructors are very common.
There are three main reasons why you will want to overload a constructor: to gain

flexibility, to allow both initialized and uninitialized objects to be created, and to

define copy constructors. In this section, the first two of these are examined. The

following section describes the copy constructor.
Overloading a Constructor to Gain Flexibility
Many times you will create a class for which there are two or more possible ways to

construct an object. In these cases, you will want to provide an overloaded constructor

for each way. This is a self-enforcing rule because if you attempt to create an object for

which there is no matching constructor, a compile-time error results.
By providing a constructor for each way that a user of your class may plausibly
want to construct an object, you increase the flexibility of your class. The user is free to

choose the best way to construct an object given the specific circumstance. Consider

this program that creates a class called
date, which holds a calendar date. Notice thatthe constructor is overloaded two ways:
#include <iostream>#include <cstdio>
using namespace std;class date {int day, month, year;public:date(char *d);date(int m, int d, int y);
void show_date();};// Initialize using string.date::date(char *d)
{sscanf(d, "%d%*c%d%*c%d", &month, &day, &year);}// Initialize using integers.date::date(int m, int d, int y)
{362C++:TheCompleteReference
day = d;month = m;
year = y;}void date::show_date(){cout << month << "/" << day;
cout << "/" << year << "\n";}int main(){date ob1(12, 4, 2003), ob2("10/22/2003");ob1.show_date();ob2.show_date();return 0;}In this program, you can initialize an object of type
date, either by specifying thedate using three integers to represent the month, day, and year, or by using a string
that contains the date in this general form:mm/dd/yyyySince both are common ways to represent a date, it makes sense that
dateallow bothwhen constructing an object.
Asthe
dateclassillustrates,perhapsthemostcommonreasontooverloada
constructoristoallowanobjecttobecreatedbyusingthemostappropriateand

natural means for each particular circumstance. For example, in the following
main( ),the user is prompted for the date, which is input to array
s. This string can then be useddirectly to create
d. There is no need for it to be converted to any other form. However,
ifdate( )were not overloaded to accept the string form, you would have to manually
convert it into three integers.
int main(){char s[80];Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
363C++cout << "Enter new date: ";cin >> s;date d(s);d.show_date();return 0;}In another situation, initializing an object of typedateby using three integers
may be more convenient. For example, if the date is generated by some sort of
computational method, then creating a
dateobject usingdate(int, int, int)is the mostnatural and appropriate constructor to employ. The point here is that by overloading

date's constructor, you have made it more flexible and easier to use. This increased

flexibility and ease of use are especially important if you are creating class libraries

that will be used by other programmers.
Allowing Both Initialized and Uninitialized ObjectsAnother common reason constructors are overloaded is to allow both initialized and

uninitialized objects (or, more precisely, default initialized objects) to be created. This

is especially important if you want to be able to create dynamic arrays of objects of

some class, since it is not possible to initialize a dynamically allocated array. To allow

uninitialized arrays of objects along with initialized objects, you must include a
constructor that supports initialization and one that does not.
For example, the following program declares two arrays of type
powers; one isinitialized and the other is not. It also dynamically allocates an array.
#include <iostream>#include <new>
using namespace std;class powers {int x;public:// overload constructor two wayspowers() { x = 0; } // no initializer
powers(int n) { x = n; } // initializerint getx() { return x; }void setx(int i) { x = i; }364C++:TheCompleteReference
};int main(){powers ofTwo[] = {1, 2, 4, 8, 16}; // initialized
powers ofThree[5]; // uninitialized
powers *p;
int i;// show powers of twocout << "Powers of two: ";
for(i=0; i<5; i++) {cout << ofTwo[i].getx() << " ";}
cout << "\n\n";// set powers of threeofThree[0].setx(1);
ofThree[1].setx(3);
ofThree[2].setx(9);
ofThree[3].setx(27);
ofThree[4].setx(81);// show powers of threecout << "Powers of three: ";
for(i=0; i<5; i++) {cout << ofThree[i].getx() << " ";}
cout << "\n\n";// dynamically allocate an arraytry {p = new powers[5]; // no initialization} catch (bad_alloc xa) {cout << "Allocation Failure\n";
return 1;}// initialize dynamic array with powers of twofor(i=0; i<5; i++) {p[i].setx(ofTwo[i].getx());Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
365C++}// show powers of twocout << "Powers of two: ";
for(i=0; i<5; i++) {cout << p[i].getx() << " ";}
cout << "\n\n";delete [] p;return 0;}In this example, both constructors are necessary. The default constructor is used to
construct the uninitialized
ofThreearray and the dynamically allocated array. The
parameterized constructor is called to create the objects for the
ofTwo
array.
Copy Constructors
One of the more important forms of an overloaded constructor is the
copyconstructor
.Defining a copy constructor can help you prevent problems that might occur when

one object is used to initialize another.
Let's begin by restating the problem that the copy constructor is designed to solve.
By default, when one object is used to initialize another, C++ performs a bitwise copy.

That is, an identical copy of the initializing object is created in the target object.

Although this is perfectly adequate for many cases—and generally exactly what you
want to happen—there are situations in which a bitwise copy should not be used.

One of the most common is when an object allocates memory when it is created. For

example, assume a class calledMyClassthat allocates memory for each object whenit is created, and an object
Aof that class. This means thatAhas already allocated its
memory. Further, assume that
Ais used to initializeB, as shown here:
MyClass B = A;If a bitwise copy is performed, thenBwill be an exact copy ofA. This means thatBwill be using the same piece of allocated memory thatAis using, instead of allocatingits own. Clearly, this is not the desired outcome. For example, if
MyClassincludes adestructor that frees the memory, then the same piece of memory will be freed twice

whenAandBare destroyed!
The same type of problem can occur in two additional ways: first, when a copy of
an object is made when it is passed as an argument to a function; second, when a

temporary object is created as a return value from a function. Remember, temporary
366C++:TheCompleteReference
objects are automatically created to hold the return value of a function and they may
also be created in certain other circumstances.
To solve the type of problem just described, C++ allows you to create a copy
constructor, which the compiler uses when one object initializes another. Thus, your

copy constructor bypasses the default bitwise copy. The most common general form

of a copy constructor is
classname (constclassname&o) {// body of constructor}Here,
ois a reference to the object on the right side of the initialization. It is permissible
foracopyconstructortohaveadditionalparametersaslongastheyhavedefault

argumentsdefinedforthem.However,inallcasesthefirstparametermustbeareference

to the object doing the initializing.It is important to understand that C++ defines two distinct types of situations inwhich the value of one object is given to another. The first is assignment. The second is

initialization, which can occur any of three ways:
When one object explicitly initializes another, such as in a declaration
When a copy of an object is made to be passed to a functionWhen a temporary object is generated (most commonly, as a return value)
The copy constructor applies only to initializations. For example, assuming a class

calledmyclass, and thatyis an object of typemyclass, each of the following statementsinvolves initialization.myclass x = y; // y explicitly initializing xfunc(y);       // y passed as a parameter
y = func();    // y receiving a temporary, return objectFollowingisanexamplewhereanexplicitcopyconstructorisneeded.Thisprogram
creates a very limited "safe" integer array type that prevents array boundaries from
beingoverrun.(Chapter15showsabetterwaytocreateasafearraythatuses

overloadedoperators.)Storageforeacharrayisallocatedbytheuseof
new,anda
pointer to the memory is maintained within each array object./* This program creates a "safe" array class.  Since spacefor the array is allocated using new, a copy constructoris provided to allocate memory when one array object is
used to initialize another.*/Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
367C++368C++:TheCompleteReference
#include <iostream>#include <new>
#include <cstdlib>
using namespace std;class array {int *p;int size;public:array(int sz) {try {p = new int[sz];} catch (bad_alloc xa) {cout << "Allocation Failure\n";
exit(EXIT_FAILURE);}
size = sz;}
~array() { delete [] p; }// copy constructorarray(const array &a);void put(int i, int j) {if(i>=0 && i<size) p[i] = j;}int get(int i) {return p[i];}};// Copy Constructorarray::array(const array &a) {int i;try {p = new int[a.size];} catch (bad_alloc xa) {cout << "Allocation Failure\n";exit(EXIT_FAILURE);}
for(i=0; i<a.size; i++) p[i] = a.p[i];}Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
369C++int main(){array num(10);int i;for(i=0; i<10; i++) num.put(i, i);for(i=9; i>=0; i--) cout << num.get(i);
cout << "\n";// create another array and initialize with numarray x(num); // invokes copy constructor
for(i=0; i<10; i++) cout << x.get(i);return 0;}Let'slookcloselyatwhathappenswhen
numisusedtoinitialize
xinthestatement
array x(num); // invokes copy constructorThe copy constructor is called, memory for the new array is allocated and stored in
x.p,and the contents ofnumare copied to
x's array. In this way,
xandnumhave arraysthat contain the same values, but each array is separate and distinct. (That is,num.pandx.pdo not point to the same piece of memory.) If the copy constructor had not been
created, the default bitwise initialization would have resulted in
xandnumsharing thesame memory for their arrays. (That is,num.pandx.pwould have indeed pointed tothe same location.)Remember that the copy constructor is called only for initializations. For example,
this sequence does not call the copy constructor defined in the preceding program:
array a(10);// ...
array b(10);b = a; // does not call copy constructorIn this case,b = aperforms the assignment operation. If=is not overloaded (as it is nothere), a bitwise copy will be made. Therefore, in some cases, you may need to overload
the=operator as well as create a copy constructor to avoid certain types of problems
(see Chapter 15).Finding the Address of an Overloaded Function
As explained in Chapter 5, you can obtain the address of a function. One reason to
do so is to assign the address of the function to a pointer and then call that function

through that pointer. If the function is not overloaded, this process is straightforward.

However, for overloaded functions, the process requires a little more subtlety. To

understand why, first consider this statement, which assigns the address of some

function calledmyfunc( )to a pointer calledp:p = myfunc;Ifmyfunc( )is not overloaded, there is one and only one function called
myfunc( ),and the compiler has no difficulty assigning its address to
p. However, if
myfunc( )isoverloaded, how does the compiler know which version's address to assign to
p? Theanswer is that it depends upon howpis declared. For example, consider this program:
#include <iostream>using namespace std;int myfunc(int a);int myfunc(int a, int b);int main(){int (*fp)(int a); // pointer to int f(int)fp = myfunc; // points to myfunc(int)
cout << fp(5);
return 0;}
int myfunc(int a){return a;}int myfunc(int a, int b){return a*b;}370C++:TheCompleteReference
Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
371C++Here, there are two versions of
myfunc( ). Both return
int, but one takes a singleinteger argument; the other requires two integer arguments. In the program,
fpisdeclared as a pointer to a function that returns an integer and that takes one integer
argument. When
fpis assigned the address of
myfunc( ), C++ uses this informationto select themyfunc(int a)version ofmyfunc( ). Hadfpbeen declared like this:
int (*fp)(int a, int b);thenfpwould have been assigned the address of the
myfunc(int a, int b)version ofmyfunc( ).In general, when you assign the address of an overloaded function to a function
pointer, it is the declaration of the pointer that determines which function's address

is obtained. Further, the declaration of the function pointer must exactly match one

and only one of the overloaded function's declarations.The overload Anachronism
When C++ was created, the keyword
overloadwas required to create an overloaded
function.Itisobsoleteandnolongerusedorsupported.Indeed,itisnotevena

reservedwordinStandardC++.However,becauseyoumightencounterolder

programs,andforitshistoricalinterest,itisagoodideatoknowhow
overloadwas used. Here is its general form:
overloadfunc-name;Here,
func-nameis the name of the function that you will be overloading. Thisstatement must precede the overloaded declarations. For example, this tells an

old-style compiler that you will be overloading a function calledtest( ):overload test;Default Function Arguments
C++ allows a function to assign a parameter a default value when no argument

corresponding to that parameter is specified in a call to that function. The default value

is specified in a manner syntactically similar to a variable initialization. For example,
this declares
myfunc( )as taking onedoubleargument with a default value of 0.0:
void myfunc(double d = 0.0){// ...}Now,
myfunc( )can be called one of two ways, as the following examples show:myfunc(198.234); // pass an explicit valuemyfunc();        // let function use defaultThe first call passes the value 198.234 tod. The second call automatically givesdthedefault value zero.
One reason that default arguments are included in C++ is because they provide
another method for the programmer to manage greater complexity. To handle the
widest variety of situations, quite frequently a function contains more parameters than

are required for its most common usage. Thus, when the default arguments apply, you

need specify only the arguments that are meaningful to the exact situation, not all those

needed by the most general case. For example, many of the C++ I/O functions make
use of default arguments for just this reason.
Asimple illustration of how useful a default function argument can be is shown by
theclrscr( )function in the following program. The
clrscr( )function clears the screen
by outputting a series of linefeeds (not the most efficient way, but sufficient for this

example). Because a very common video mode displays 25 lines of text, the default
argument of 25 is provided. However, because some video modes display more or less

than 25 lines, you can override the default argument by specifying one explicitly.
#include <iostream>using namespace std;void clrscr(int size=25);
int main(){register int i;for(i=0; i<30; i++ ) cout << i << endl;cin.get();
clrscr(); // clears 25 linesfor(i=0; i<30; i++ ) cout << i << endl;cin.get();
clrscr(10); // clears 10 linesreturn 0;}
void clrscr(int size)372C++:TheCompleteReference
Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
373C++{for(; size; size--) cout << endl;}As this program illustrates, when the default value is appropriate to the situation,
no argument need be specified when
clrscr( )is called. However, it is still possible to
override the default and givesizea different value when needed.
Adefault argument can also be used as a flag telling the function to reuse a
previous argument. To illustrate this usage, a function called
iputs( )is developed here
that automatically indents a string by a specified amount. To begin, here is a version of
this function that does not use a default argument:
void iputs(char *str, int indent){if(indent < 0) indent = 0;for( ; indent; indent--) cout << " ";
cout << str << "\n";}Thisversionof
iputs()
iscalledwiththestringtooutputasthefirstargumentand
theamounttoindentasthesecond.Althoughthereisnothingwrongwithwriting
iputs()
thisway,youcanimproveitsusabilitybyprovidingadefaultargumentforthe
indentparameterthattells
iputs()
toindenttothepreviouslyspecifiedlevel.Itisquitecommon
todisplayablockoftextwitheachlineindentedthesameamount.Inthissituation,
insteadofhavingtosupplythesame
indentargumentoverandover,youcangive
indentadefaultvaluethattells
iputs()
toindenttothelevelofthepreviouscall.This
approachisillustratedinthefollowingprogram:
#include <iostream>using namespace std;/* Default indent to -1.  This value tells the functionto reuse the previous value. */void iputs(char *str, int indent = -1);
int main(){iputs("Hello there", 10);
iputs("This will be indented 10 spaces by default");iputs("This will be indented 5 spaces", 5);iputs("This is not indented", 0);return 0;}
void iputs(char *str, int indent){static i = 0; // holds previous indent valueif(indent >= 0)i = indent;else  // reuse old indent valueindent = i;for( ; indent; indent--) cout << " ";
cout << str << "\n";}This program displays this output:
Hello thereThis will be indented 10 spaces by defaultThis will be indented 5 spacesThis is not indentedWhen you are creating functions that have default arguments, it is important to
remember that the default values must be specified only once, and this must be the
first time the function is declared within the file. In the preceding example, the default

argument was specified in
iputs( )'s prototype. If you try to specify new (or even the
same) default values iniputs( )'s definition, the compiler will display an error and not
compile your program. Even though default arguments for the same function cannot

be redefined, you can specify different default arguments for each version of an

overloaded function.All parameters that take default values must appear to the right of those that donot. For example, it is incorrect to define
iputs( )like this:// wrong!void iputs(int indent = -1, char *str);374C++:TheCompleteReference
Once you begin to define parameters that take default values, you cannot specifyanondefaultingparameter.Thatis,adeclarationlikethisisalsowrongandwill
not compile:int myfunc(float f, char *str, int i=10, int j);Becauseihas been given a default value,jmust be given one too.You can also use default parameters in an object's constructor. For example, the
cubeclass shown here maintains the integer dimensions of a cube. Its constructor
defaults all dimensions to zero if no other arguments are supplied, as shown here:
#include <iostream>using namespace std;class cube {int x, y, z;public:cube(int i=0, int j=0, int k=0) {x=i;y=j;
z=k;}int volume() {return x*y*z;}};
int main(){cube a(2,3,4), b;cout << a.volume() << endl;cout << b.volume();return 0;}There are two advantages to including default arguments, when appropriate, in a
constructor. First, they prevent you from having to provide an overloaded constructor
that takes no parameters. For example, if the parameters tocube( )were not given
Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
375C++376C++:TheCompleteReference
defaults, the second constructor shown here would be needed to handle the declaration
ofb(which specified no arguments).
cube() {x=0; y=0; z=0}Second, defaulting common initial values is more convenient than specifying them

each time an object is declared.
Default Arguments vs. Overloading
In some situations, default arguments can be used as a shorthand form of function

overloading. Thecubeclass's constructor just shown is one example. Let's look at
another. Imagine that you want to create two customized versions of the standard

strcat( )function. The first version will operate likestrcat( )and concatenate the entire
contents of one string to the end of another. The second version takes a third argument

that specifies the number of characters to concatenate. That is, the second version
will only concatenate a specified number of characters from one string to the end of

another. Thus, assuming that you call your customized functions
mystrcat( ), theywill have the following prototypes:
void mystrcat(char *s1, char *s2, int len);void mystrcat(char *s1, char *s2);The first version will copylencharacters from
s2to the end ofs1. The second versionwill copy the entire string pointed to by
s2onto the end of the string pointed to bys1and operates likestrcat( ).While it would not be wrong to implement two versions of
mystrcat( )to create the
two versions that you desire, there is an easier way. Using a default argument, you can
create only one version of
mystrcat( )that performs both functions. The followingprogram demonstrates this.
// A customized version of strcat().#include <iostream>
#include <cstring>
using namespace std;void mystrcat(char *s1, char *s2, int len = -1);
int main(){char str1[80] = "This is a test";
char str2[80] = "0123456789";mystrcat(str1, str2, 5); // concatenate 5 charscout << str1 << '\n';strcpy(str1, "This is a test"); // reset str1
mystrcat(str1, str2); // concatenate entire stringcout << str1 << '\n';return 0;}
// A custom version of strcat().void mystrcat(char *s1, char *s2, int len)
{// find end of s1
while(*s1) s1++;if(len == -1) len = strlen(s2);
while(*s2 && len) {*s1 = *s2; // copy charss1++;
s2++;
len--;}*s1 = '\0'; // null terminate s1}Here,
mystrcat( )concatenates up tolencharacters from the string pointed to by
s2onto the end of the string pointed to bys1. However, if
lenis –1, as it will be when it isallowed to default,mystrcat( )concatenates the entire string pointed to by
s2ontos1.(Thus, whenlenis –1, the function operates like the standard
strcat( )function.) Byusing a default argument for
len, it is possible to combine both operations into onefunction. In this way, default arguments sometimes provide an alternative to function
overloading.Using Default Arguments Correctly
Although default arguments can be a very powerful tool when used correctly, they can

also be misused. The point of default arguments is to allow a function to perform its job

in an efficient, easy-to-use manner while still allowing considerable flexibility. Toward
Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
377C++378C++:TheCompleteReference
this end, all default arguments should reflect the way a function is generally used, or
a reasonable alternate usage. When there is no single value that can be meaningfully

associated with a parameter, there is no reason to declare a default argument. In fact,

declaring default arguments when there is insufficient basis for doing so destructures

yourcode,becausetheyareliabletomisleadandconfuseanyonereadingyourprogram.
One other important guideline you should follow when using default arguments is
this: No default argument should cause a harmful or destructive action. That is, the

accidental use of a default argument should not cause a catastrophe.
Function Overloading and AmbiguityYou can create a situation in which the compiler is unable to choose between two (or

more) overloaded functions. When this happens, the situation is said to be
ambiguous.Ambiguousstatementsareerrors,andprogramscontainingambiguitywillnotcompile.
By far the main cause of ambiguity involves C++'s automatic type conversions.As you know, C++ automatically attempts to convert the arguments used to call a

function into the type of arguments expected by the function. For example, consider

this fragment:int myfunc(double d);// ...
cout << myfunc('c'); // not an error, conversion appliedAs the comment indicates, this is not an error because C++ automatically converts the
charactercinto itsdoubleequivalent. In C++, very few type conversions of this sortare actually disallowed. Although automatic type conversions are convenient, they

are also a prime cause of ambiguity. For example, consider the following program:
#include <iostream>using namespace std;float myfunc(float i);double myfunc(double i);int main(){cout << myfunc(10.1) << " "; // unambiguous, calls myfunc(double)
cout << myfunc(10); // ambiguousreturn 0;}float myfunc(float i){return i;}double myfunc(double i){return -i;}Here,
myfunc( )is overloaded so that it can take arguments of either type
floatortypedouble. In the unambiguous line,myfunc(double)is called because, unlessexplicitly specified asfloat, all floating-point constants in C++ are automatically of
typedouble. Hence, that call is unambiguous. However, when
myfunc( )is called byusing the integer 10, ambiguity is introduced because the compiler has no way of
knowing whether it should be converted to afloator to adouble. This causes an error
message to be displayed, and the program will not compile.
As the preceding example illustrates, it is not the overloading of
myfunc( )relative
todoubleandfloatthat causes the ambiguity. Rather, it is the specific call to
myfunc( )using an indeterminate type of argument that causes the confusion. Put differently, the

error is not caused by the overloading of
myfunc( ), but by the specific invocation.Here is another example of ambiguity caused by C++'s automatic type conversions:
#include <iostream>using namespace std;char myfunc(unsigned char ch);char myfunc(char ch);int main(){cout << myfunc('c'); // this calls myfunc(char)
cout << myfunc(88) << " "; // ambiguousreturn 0;}
char myfunc(unsigned char ch){return ch-1;Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
379C++}char myfunc(char ch){return ch+1;}In C++,unsigned charandcharare
notinherently ambiguous. However, when
myfunc( )is called by using the integer 88, the compiler does not know which functionto call. That is, should 88 be converted into acharor anunsigned char?Another way you can cause ambiguity is by using default arguments in overloaded
functions. To see how, examine this program:
#include <iostream>
using namespace std;int myfunc(int i);int myfunc(int i, int j=1);int main(){cout << myfunc(4, 5) << " "; // unambiguous
cout << myfunc(10); // ambiguousreturn 0;}
int myfunc(int i){return i;}int myfunc(int i, int j){return i*j;}Here, in the first call to
myfunc( ),two arguments are specified; therefore, no
ambiguity is introduced and
myfunc(int i, int j)is called. However, when the second
callto
myfunc()
ismade,ambiguityoccursbecausethecompilerdoesnotknowwhether
to call the version ofmyfunc( )that takes one argument or to apply the default to the
version that takes two arguments.
380C++:TheCompleteReference
Some types of overloaded functions are simply inherently ambiguous even if, at
first, they may not seem so. For example, consider this program.
// This program contains an error.#include <iostream>
using namespace std;void f(int x);void f(int &x); // errorint main(){int a=10;f(a); // error, which f()?
return 0;}
void f(int x){cout << "In f(int)\n";}void f(int &x){cout << "In f(int &)\n";}As the comments in the program describe, two functions cannot be overloaded when
the only difference is that one takes a reference parameter and the other takes a normal,

call-by-value parameter. In this situation, the compiler has no way of knowing which

version of the function is intended when it is called. Remember, there is no syntactical

difference in the way that an argument is specified when it will be received by a

reference parameter or by a value parameter.
Chapter14:FunctionOverloading,CopyConstructors,andDefaultArguments
381C++This page intentionally left blank Chapter15
Operator Overloading383Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
384C++:TheCompleteReference
Closely related to function overloading is operator overloading. In C++, youcan overload most operators so that they perform special operations relative
to classes that you create. For example, a class that maintains a stack mightoverload+to perform a push operation and– –to perform a pop. When an operatoris overloaded, none of its original meanings are lost. Instead, the type of objects it can
be applied to is expanded.The ability to overload operators is one of C++'s most powerful features. It allows
thefullintegrationofnewclasstypesintotheprogrammingenvironment.After

overloading the appropriate operators, you can use objects in expressions in just the

same way that you use C++'s built-in data types. Operator overloading also forms the
basis of C++'s approach to I/O.
Youoverloadoperatorsbycreatingoperatorfunctions.An
operatorfunction
definesthe
operations that the overloaded operator will perform relative to the class upon which it

willwork.Anoperatorfunctioniscreatedusingthekeyword
operator.Operatorfunctions
can be either members or nonmembers of a class. Nonmember operator functions are

almostalwaysfriendfunctionsoftheclass,however.Thewayoperatorfunctions

are written differs between member and nonmember functions. Therefore, each will

be examined separately, beginning with member operator functions.
Creating a Member Operator Function
Amember operator function takes this general form:
ret-type class-name::operator#(arg-list)
{// operations}Often, operator functions return an object of the class they operate on, but
ret-type
can be any valid type. The#is a placeholder. When you create an operator function,
substitute the operator for the#. For example, if you are overloading the
/operator,
useoperator/.When you are overloading a unary operator,
arg-list
will be empty.
When you are overloading binary operators,
arg-list
will contain one parameter.
(The reasons for this seemingly unusual situation will be made clear in a moment.)
Here is a simple first example of operator overloading. This program creates a
classcalled
loc,whichstoreslongitudeandlatitudevalues.Itoverloadsthe
+operatorrelative to this class. Examine this program carefully, paying special attention to the

definition ofoperator+( ):#include <iostream>using namespace std;class loc {int longitude, latitude;public:loc() {}loc(int lg, int lt) {longitude = lg;
latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}loc operator+(loc op2);};
// Overload + for loc.loc loc::operator+(loc op2)
{loc temp;temp.longitude = op2.longitude + longitude;temp.latitude = op2.latitude + latitude;return temp;}
int main(){loc ob1(10, 20), ob2( 5, 30);ob1.show(); // displays 10 20ob2.show(); // displays 5 30ob1 = ob1 + ob2;ob1.show(); // displays 15 50return 0;}Chapter15:OperatorOverloading
385C++As you can see,operator+( )has only one parameter even though it overloads thebinary+operator.(Youmightexpecttwoparameterscorrespondingtothetwooperands
of a binary operator.) The reason that
operator+( )takes only one parameter is that theoperand on the left side of the+is passed implicitly to the function through the
thispointer. The operand on the right is passed in the parameter
op2. The fact that the leftoperand is passed usingthisalso implies one important point: When binary operatorsareoverloaded,itistheobjectontheleftthatgeneratesthecalltotheoperatorfunction.
Asmentioned,itiscommonforanoverloadedoperatorfunctiontoreturnan
object of the class it operates upon. By doing so, it allows the operator to be used inlargerexpressions.Forexample,ifthe
operator+()
functionreturnedsomeother
type, this expression would not have been valid:
ob1 = ob1 + ob2;Inorderforthesumof
ob1andob2tobeassignedto
ob1,theoutcomeofthatoperation
must be an object of typeloc.Further,having
operator+()
returnanobjectoftype
locmakespossiblethe
following statement:(ob1+ob2).show(); // displays outcome of ob1+ob2In this situation,ob1+ob2generates a temporary object that ceases to exist after the calltoshow( )terminates.It is important to understand that an operator function can return any type and that
thetypereturneddependssolelyuponyourspecificapplication.Itisjustthat,often,

an operator function will return an object of the class upon which it operates.
One last point about theoperator+( )function: It does not modify either operand.Because the traditional use of the+operator does not modify either operand, it makessense for the overloaded version not to do so either. (For example, 5+7 yields 12, but

neither 5 nor 7 is changed.) Although you are free to perform any operation you want

inside an operator function, it is usually best to stay within the context of the normal
use of the operator.
The next program adds three additional overloaded operators to the
locclass: the–,the=,and the unary++.Pay special attention to how these functions are defined.
#include <iostream>using namespace std;class loc {int longitude, latitude;386C++:TheCompleteReference
public:loc() {} // needed to construct temporariesloc(int lg, int lt) {longitude = lg;latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}loc operator+(loc op2);loc operator-(loc op2);
loc operator=(loc op2);
loc operator++();};// Overload + for loc.loc loc::operator+(loc op2)
{loc temp;temp.longitude = op2.longitude + longitude;temp.latitude = op2.latitude + latitude;return temp;}
// Overload - for loc.loc loc::operator-(loc op2)
{loc temp;// notice order of operandstemp.longitude = longitude - op2.longitude;
temp.latitude = latitude - op2.latitude;return temp;}
// Overload asignment for loc.Chapter15:OperatorOverloading
387C++loc loc::operator=(loc op2){longitude = op2.longitude;latitude = op2.latitude;return *this; // i.e., return object that generated call}
// Overload prefix ++ for loc.loc loc::operator++()
{longitude++;
latitude++;return *this;}
int main(){loc ob1(10, 20), ob2( 5, 30), ob3(90, 90);ob1.show();ob2.show();++ob1;ob1.show(); // displays 11 21ob2 = ++ob1;ob1.show(); // displays 12 22
ob2.show(); // displays 12 22ob1 = ob2 = ob3; // multiple assignmentob1.show(); // displays 90 90
ob2.show(); // displays 90 90return 0;}First, examine theoperator–( )function. Notice the order of the operands in the
subtraction. In keeping with the meaning of subtraction, the operand on the right sideof the minus sign is subtracted from the operand on the left. Because it is the object on

theleftthatgeneratesthecalltothe
operator–()
function,op2'sdatamust
besubtracted
388C++:TheCompleteReference
C++Chapter15:OperatorOverloading
389from the data pointed to by
this. It is important to remember which operand generates
the call to the function.In C++, if the=is not overloaded, a default assignment operation is created auto-
maticallyforanyclassyoudefine.Thedefaultassignmentissimplyamember-by-member,
bitwise copy. By overloading the
=, you can define explicitly what the assignment doesrelativetoaclass.Inthisexample,theoverloaded
=doesexactlythesamethingas
the default, but in other situations, it could perform other operations. Notice that the
operator=()
functionreturns
*this,whichistheobjectthatgeneratedthecall.This
arrangement is necessary if you want to be able to use multiple assignment operations
such as this:ob1 = ob2 = ob3; // multiple assignmentNow, look at the definition of
operator++( ).As you can see, it takes no parameters.Since++isaunaryoperator,itsonlyoperandisimplicitlypassedbyusingthe
thispointer.
Notice that bothoperator=( )andoperator++( )alter the value of an operand.In the case of assignment, the operand on the left (the one generating the call to the
operator=( )function) is assigned a new value. In the case of the++, the operand isincremented. As stated previously, although you are free to make these operators do

anything you please, it is almost always wisest to stay consistent with their original
meanings.Creating Prefix and Postfix Forms
of the Increment and Decrement Operators
Intheprecedingprogram,onlytheprefixformoftheincrementoperatorwasoverloaded.
However,StandardC++allowsyoutoexplicitlycreateseparateprefixandpostfix

versions of the increment or decrement operators. To accomplish this, you must define

two versions of theoperator++( )function. One is defined as shown in the foregoing
program. The other is declared like this:
loc operator++(int x);If the++precedes its operand, the
operator++( )function is called. If the++follows itsoperand, theoperator++(int x)is called andxhas the value zero.
The preceding example can be generalized. Here are the general forms for the prefix
and postfix++and––operator functions.// Prefix increment
typeoperator++( ) {// body of prefix operator
}390C++:TheCompleteReference
// Postfix increment
typeoperator++(intx) {// body of postfix operator}// Prefix decrement
typeoperator– –( ) {// body of prefix operator
}// Postfix decrement
typeoperator– –(intx) {// body of postfix operator}You should be careful when working with older C++ programs where the increment
and decrement operators are concerned. In older versions of C++, it was not possible

to specify separate prefix and postfix versions of an overloaded
++or––. The prefix
form was used for both.Overloading the Shorthand Operators
You can overload any of C++'s "shorthand" operators, such as
+=, –=,and the like.For example, this function overloads+=relative to
loc:loc loc::operator+=(loc op2){longitude = op2.longitude + longitude;
latitude = op2.latitude + latitude;return *this;}When overloading one of these operators, keep in mind that you are simply
combining an assignment with another type of operation.Operator Overloading RestrictionsThere are some restrictions that apply to operator overloading. You cannot alter the
precedence of an operator. You cannot change the number of operands that an operator

takes.(Youcanchoosetoignoreanoperand,however.)Exceptforthefunctioncall
Chapter15:OperatorOverloading
391C++operator (described later), operator functions cannot have default arguments. Finally,
these operators cannot be overloaded:.  : :  .*  ?Asstated,technicallyyouarefreetoperformanyactivityinsideanoperator
function.Forexample,ifyouwanttooverloadthe
+operatorinsuchawaythat
it writesI like C++10 times to a disk file, you can do so. However, when you stray
significantly from the normal meaning of an operator, you run the risk of dangerously
destructuring your program. When someone reading your program sees a statement

likeOb1+Ob2, he or she expects something resembling addition to be taking place—
not a disk access, for example. Therefore, before decoupling an overloaded operator

from its normal meaning, be sure that you have sufficient reason to do so. One good

example where decoupling is successful is found in the way C++ overloads the
<<and>>operators for I/O. Although the I/O operations have no relationship to bit shifting,
these operators provide a visual "clue" as to their meaning relative to both I/O and bit

shifting, and this decoupling works. In general, however, it is best to stay within the

context of the expected meaning of an operator when overloading it.Exceptforthe
=operator,operatorfunctionsareinheritedbyaderivedclass.
However, a derived class is free to overload any operator (including those overloaded

by the base class) it chooses relative to itself.
Operator Overloading Using a Friend FunctionYoucanoverloadanoperatorforaclassbyusinganonmemberfunction,whichis

usuallyafriendoftheclass.Sincea
friendfunctionisnotamemberoftheclass,it
doesnothavea
thispointer.Therefore,anoverloadedfriendoperatorfunctionispassed
theoperandsexplicitly.Thismeansthatafriendfunctionthatoverloadsabinaryoperator

hastwoparameters,andafriendfunctionthatoverloadsaunaryoperatorhasone

parameter.Whenoverloadingabinaryoperatorusingafriendfunction,theleftoperand

ispassedinthefirstparameterandtherightoperandispassedinthesecondparameter.
In this program, the
operator+( )function is made into a friend:#include <iostream>using namespace std;class loc {int longitude, latitude;public:loc() {} // needed to construct temporariesloc(int lg, int lt) {longitude = lg;latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}friend loc operator+(loc op1, loc op2); // now a friendloc operator-(loc op2);
loc operator=(loc op2);
loc operator++();};// Now, + is overloaded using friend function.loc operator+(loc op1, loc op2)
{loc temp;temp.longitude = op1.longitude + op2.longitude;temp.latitude = op1.latitude + op2.latitude;return temp;}
// Overload - for loc.loc loc::operator-(loc op2)
{loc temp;// notice order of operandstemp.longitude = longitude - op2.longitude;
temp.latitude = latitude - op2.latitude;return temp;}
// Overload assignment for loc.392C++:TheCompleteReference
Chapter15:OperatorOverloading
393C++loc loc::operator=(loc op2){longitude = op2.longitude;latitude = op2.latitude;return *this; // i.e., return object that generated call}
// Overload ++ for loc.loc loc::operator++()
{longitude++;
latitude++;return *this;}
int main(){loc ob1(10, 20), ob2( 5, 30);ob1 = ob1 + ob2;ob1.show();return 0;}Therearesomerestrictionsthatapplytofriendoperatorfunctions.First,you
may not overload the=,( ),[ ], or–>operators by using a friend function. Second, asexplained in the next section, when overloading the increment or decrement operators,
you will need to use a reference parameter when using a friend function.
Using a Friend to Overload ++ or ––
If you want to use a friend function to overload the increment or decrement operators,

you must pass the operand as a reference parameter. This is because friend functions

do not havethispointers. Assuming that you stay true to the original meaning of the
++and––operators,theseoperationsimplythemodificationoftheoperandthey
operateupon.However,ifyouoverloadtheseoperatorsbyusingafriend,thenthe

operand is passed by value as a parameter. This means that a friendoperator function

has no way to modify the operand. Since the friend operator function is not passedathispointer to the operand, but rather a copy of the operand, no changes made tothat parameter affect the operand that generated the call. However, you can remedy
this situation by specifying the parameter to the friendoperator function as a reference

parameter. This causes any changes made to the parameter inside the function to affect

the operand that generated the call. For example, this program uses friend functions to

overload the prefix versions of
++and––operators relative to the
locclass:#include <iostream>using namespace std;class loc {int longitude, latitude;public:loc() {}loc(int lg, int lt) {longitude = lg;
latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}loc operator=(loc op2);friend loc operator++(loc &op);
friend loc operator--(loc &op);};// Overload assignment for loc.loc loc::operator=(loc op2)
{longitude = op2.longitude;
latitude = op2.latitude;return *this; // i.e., return object that generated call}
// Now a friend; use a reference parameter.loc operator++(loc &op)
{394C++:TheCompleteReference
op.longitude++;op.latitude++;return op;}
// Make op-- a friend; use reference.loc operator--(loc &op)
{op.longitude--;
op.latitude--;return op;}
int main(){loc ob1(10, 20), ob2;ob1.show();++ob1;
ob1.show(); // displays 11 21ob2 =  ++ob1;ob2.show(); // displays 12 22--ob2;ob2.show(); // displays 11 21return 0;}If you want to overload the postfix versions of the increment and decrement operators
using a friend, simply specify a second, dummy integer parameter. For example, this

shows the prototype for the
friend,postfix version of the increment operator relative
toloc.// friend, postfix version of ++friend loc operator++(loc &op, int x);Chapter15:OperatorOverloading
395C++396C++:TheCompleteReference
Friend Operator Functions Add FlexibilityIn many cases, whether you overload an operator by using a friend or a memberfunction makes no functional difference. In those cases, it is usually best to overload

by using member functions. However, there is one situation in which overloading by

using a friend increases the flexibility of an overloaded operator. Let's examine this

case now.
As you know, when you overload a binary operator by using a member function,
the object on the left side of the operator generates the call to the operator function.
Further,apointertothatobjectispassedinthe
thispointer.Now,assumesome
class that defines a memberoperator+( )function that adds an object of the class toan integer. Given an object of that class called
Ob, the following expression is valid:
Ob + 100 // validIn this case,Obgenerates the call to the overloaded+function, and the addition isperformed. But what happens if the expression is written like this?
100 + Ob // invalidIn this case, it is the integer that appears on the left. Since an integer is a built-in type,
no operation between an integer and an object ofOb's type is defined. Therefore, the
compiler will not compile this expression. As you can imagine, in some applications,

having to always position the object on the left could be a significant burden and cause

of frustration.
The solution to the preceding problem is to overload addition using a friend, not
a member, function. When this is done, both arguments are explicitly passed to the

operator function. Therefore, to allow both
object+integerandinteger+object, simplyoverload the function twice—one version for each situation. Thus, when you overload
an operator by using twofriendfunctions, the object may appear on either the left orright side of the operator.
This program illustrates how
friendfunctions are used to define an operation that
involves an object and built-in type:#include <iostream>using namespace std;class loc {int longitude, latitude;public:Chapter15:OperatorOverloading
397C++loc() {}loc(int lg, int lt) {longitude = lg;latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}friend loc operator+(loc op1, int op2);friend loc operator+(int op1, loc op2);};// + is overloaded for loc + int.loc operator+(loc op1, int op2)
{loc temp;temp.longitude = op1.longitude + op2;temp.latitude = op1.latitude + op2;return temp;}// + is overloaded for int + loc.
loc operator+(int op1, loc op2)
{loc temp;temp.longitude = op1 + op2.longitude;temp.latitude = op1 + op2.latitude;return temp;}
int main(){loc ob1(10, 20), ob2( 5, 30), ob3(7, 14);ob1.show();ob2.show();ob3.show();ob1 = ob2 + 10; // both of theseob3 = 10 + ob2; // are validob1.show();ob3.show();return 0;}Overloading new and deleteIt is possible to overloadnewanddelete. You might choose to do this if you want
to use some special allocation method. For example, you may want allocation routines
that automatically begin using a disk file as virtual memory when the heap has been
exhausted. Whatever the reason, it is a very simple matter to overload these operators.
The skeletons for the functions that overloadnewanddeleteare shown here:
// Allocate an object.void *operator new(size_t size)
{/* Perform allocation.  Throw bad_alloc on failure.Constructor called automatically. */return pointer_to_memory;}// Delete an object.void operator delete(void *p)
{/* Free memory pointed to by p.Destructor called automatically. */}The typesize_tis a defined type capable of containing the largest single piece
ofmemorythatcanbeallocated.(
size_tisessentiallyanunsignedinteger.)The
parametersizewillcontainthenumberofbytesneededtoholdtheobjectbeing
allocated. This is the amount of memory that your version ofnewmust allocate. Theoverloadednewfunctionmustreturnapointertothememorythatitallocates,or
throwa
bad_allocexceptionifanallocationerroroccurs.Beyondtheseconstraints,
the overloadednewfunction can do anything else you require. When you allocate an
398C++:TheCompleteReference
Chapter15:OperatorOverloading
399C++object usingnew(whether your own version or not), the object's constructor is
automatically called.Thedeletefunction receives a pointer to the region of memory to be freed. It
then releases the previously allocated memory back to the system. When an object
is deleted, its destructor is automatically called.
Thenewanddeleteoperators may be overloaded globally so that all uses of theseoperators call your custom versions. They may also be overloaded relative to one or

more classes. Lets begin with an example of overloading
newanddeleterelative to
a class. For the sake of simplicity, no new allocation scheme will be used. Instead, the

overloaded operators will simply invoke the standard library functions
malloc( )andfree().
(Inyourownapplication,youmay,ofcourse,implementanyalternativeallocation
scheme you like.)To overload the
newanddeleteoperators for a class, simply make the overloadedoperator functions class members. For example, here the
newanddeleteoperators are
overloaded for thelocclass:#include <iostream>#include <cstdlib>
#include <new>
using namespace std;class loc {int longitude, latitude;public:loc() {}loc(int lg, int lt) {longitude = lg;
latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}void *operator new(size_t size);void operator delete(void *p);};// new overloaded relative to loc.void *loc::operator new(size_t size)
{void *p;400C++:TheCompleteReference
cout << "In overloaded new.\n";p =  malloc(size);
if(!p) {bad_alloc ba;throw ba;}return p;}// delete overloaded relative to loc.void loc::operator delete(void *p)
{cout << "In overloaded delete.\n";
free(p);}int main(){loc *p1, *p2;try {p1 = new loc (10, 20);} catch (bad_alloc xa) {cout << "Allocation error for p1.\n";return 1;}try {p2 = new loc (-10, -20);} catch (bad_alloc xa) {cout << "Allocation error for p2.\n";return 1;;}p1->show();p2->show();delete p1;delete p2;return 0;}Output from this program is shown here.
In overloaded new.In overloaded new.
10 20
-10 -20
In overloaded delete.
In overloaded delete.Whennewanddeleteare for a specific class, the use of these operators on any
other type of data causes the originalnewordeleteto be employed. The overloadedoperators are only applied to the types for which they are defined. This means that if
you add this line to themain( ),the defaultnewwill be executed:int *f = new float; // uses default newYou can overload
newanddeleteglobally by overloading these operators outsideof any class declaration. Whennewanddeleteare overloaded globally, C++'s default
newanddeleteare ignored and the new operators are used for all allocation requests.
Of course, if you have defined any versions ofnewanddeleterelative to one or more
classes, then the class-specific versions are used when allocating objects of the class for

whichtheyaredefined.Inotherwords,when
newordeleteareencountered,the
compilerfirstcheckstoseewhethertheyaredefinedrelativetotheclasstheyare

operatingon.Ifso,thosespecificversionsareused.Ifnot,C++usesthegloballydefined

newanddelete. If these have been overloaded, the overloaded versions are used.
To see an example of overloading
newanddeleteglobally, examine this program:
#include <iostream>#include <cstdlib>
#include <new>
using namespace std;class loc {int longitude, latitude;
public:loc() {}
loc(int lg, int lt) {longitude = lg;
latitude = lt;}Chapter15:OperatorOverloading
401C++void show() {cout << longitude << " ";cout << latitude << "\n";}};// Global newvoid *operator new(size_t size)
{void *p;p =  malloc(size);if(!p) {bad_alloc ba;
throw ba;}
return p;}// Global deletevoid operator delete(void *p)
{free(p);}int main(){loc *p1, *p2;
float *f;try {p1 = new loc (10, 20);} catch (bad_alloc xa) {cout << "Allocation error for p1.\n";return 1;;}try {p2 = new loc (-10, -20);} catch (bad_alloc xa) {cout << "Allocation error for p2.\n";return 1;;402C++:TheCompleteReference
}try {f = new float; // uses overloaded new, too} catch (bad_alloc xa) {cout << "Allocation error for f.\n";return 1;;}*f = 10.10F;cout << *f << "\n";p1->show();p2->show();delete p1;delete p2;
delete f;return 0;}Run this program to prove to yourself that the built-in
newanddeleteoperatorshave indeed been overloaded.Overloading new and delete for ArraysIf you want to be able to allocate arrays of objects using your own allocation system,you will need to overloadnewanddeletea second time. To allocate and free arrays,
you must use these forms ofnewanddelete.// Allocate an array of objects.void *operator new[](size_t size)
{/* Perform allocation.  Throw bad_alloc on failure.Constructor for each element called automatically. */return pointer_to_memory;}// Delete an array of objects.void operator delete[](void *p)Chapter15:OperatorOverloading
403C++{/* Free memory pointed to by p.Destructor for each element called automatically.*/}Whenallocatinganarray,theconstructorforeachobjectinthearrayisautomatically
called. When freeing an array, each object's destructor is automatically called. You do
not have to provide explicit code to accomplish these actions.
The following program allocates and frees an object and an array of objects of
typeloc.#include <iostream>#include <cstdlib>
#include <new>
using namespace std;class loc {int longitude, latitude;public:loc() {longitude = latitude = 0;}loc(int lg, int lt) {longitude = lg;
latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}void *operator new(size_t size);void operator delete(void *p);void *operator new[](size_t size);void operator delete[](void *p);};// new overloaded relative to loc.void *loc::operator new(size_t size)
{404C++:TheCompleteReference
void *p;cout << "In overloaded new.\n";p =  malloc(size);
if(!p) {bad_alloc ba;throw ba;}return p;}// delete overloaded relative to loc.void loc::operator delete(void *p)
{cout << "In overloaded delete.\n";
free(p);}// new overloaded for loc arrays.void *loc::operator new[](size_t size)
{void *p;cout << "Using overload new[].\n";p =  malloc(size);
if(!p) {bad_alloc ba;
throw ba;}
return p;}// delete overloaded for loc arrays.void loc::operator delete[](void *p)
{cout << "Freeing array using overloaded delete[]\n";
free(p);}int main(){loc *p1, *p2;Chapter15:OperatorOverloading
405C++int i;try {p1 = new loc (10, 20); // allocate an object} catch (bad_alloc xa) {cout << "Allocation error for p1.\n";return 1;;}try {p2 = new loc [10]; // allocate an array} catch (bad_alloc xa) {cout << "Allocation error for p2.\n";return 1;;}p1->show();
for(i=0; i<10; i++)p2[i].show();delete p1; // free an objectdelete [] p2; // free an arrayreturn 0;}Overloading the nothrow Version of new and delete
You can also create overloaded
nothrowversions ofnewanddelete. To do so, use
these skeletons.// Nothrow version of new.void *operator new(size_t size, const nothrow_t &n)
{// Perform allocation.
if(success) return pointer_to_memory;
else return 0;}// Nothrow version of new for arrays.406C++:TheCompleteReference
void *operator new[](size_t size, const nothrow_t &n){// Perform allocation.if(success) return pointer_to_memory;
else return 0;}void operator delete(void *p, const nothrow_t &n){// free memory}void operator delete[](void *p, const nothrow_t &n){// free memory}The typenothrow_tis defined in<new>. This is the type of thenothrowobject. Thenothrow_tparameter is unused.Overloading Some Special OperatorsC++definesarraysubscripting,functioncalling,andclassmemberaccessasoperations.
Theoperatorsthatperformthesefunctionsarethe
[],(),
and–>,respectively.Theserather
exotic operators may be overloaded in C++, opening up some very interesting uses.
One important restriction applies to overloading these three operators: They must
be nonstatic member functions. They cannot befriends.Overloading [ ]In C++, the[ ]is considered a binary operator when you are overloading it. Therefore,
the general form of a memberoperator[ ]( )function is as shown here:
type class-name::operator[](inti){// . . .}Technically, the parameter does not have to be of type
int, but anoperator[ ]( )functionistypicallyusedtoprovidearraysubscripting,andassuch,anintegervalueis

generally used.Chapter15:OperatorOverloading
407C++408C++:TheCompleteReference
Given an object calledO, the expression
O[3]translates into this call to theoperator[ ]( )function:O.operator[](3)That is, the value of the expression within the subscripting operators is passed to the
operator[]()
functioninitsexplicitparameter.The
thispointerwillpointto
O,theobject
that generated the call.In the following program,
atypedeclares an array of three integers. Its constructor
initializeseachmemberofthearraytothespecifiedvalues.Theoverloaded
operator[]()
functionreturnsthevalueofthearrayasindexedbythevalueofitsparameter.
#include <iostream>using namespace std;class atype {int a[3];public:atype(int i, int j, int k) {a[0] = i;a[1] = j;
a[2] = k;}
int operator[](int i) { return a[i]; }};int main(){atype ob(1, 2, 3);cout << ob[1]; // displays 2
return 0;}You can design the
operator[ ]( )function in such a way that the[ ]can be used onboth the left and right sides of an assignment statement. To do this, simply specify the
return value of
operator[ ]( )as a reference. The following program makes this change
and shows its use:#include <iostream>using namespace std;class atype {int a[3];public:atype(int i, int j, int k) {a[0] = i;a[1] = j;
a[2] = k;}
int &operator[](int i) { return a[i]; }};int main(){atype ob(1, 2, 3);cout << ob[1]; // displays 2cout << " ";ob[1] = 25; // [] on left of =
cout << ob[1]; // now displays 25
return 0;}Becauseoperator[ ]( )now returns a reference to the array element indexed by
i,it can be used on the left side of an assignment to modify an element of the array. (Of
course, it may still be used on the right side as well.)One advantage of being able to overload the[ ]operator is that it allows a meansof implementing safe array indexing in C++. As you know, in C++, it is possible to

overrun (or underrun) an array boundary at run time without generating a run-time

error message. However, if you create a class that contains the array, and allow access

tothatarrayonlythroughtheoverloaded
[]subscriptingoperator,thenyoucan
interceptanout-of-rangeindex.Forexample,thisprogramaddsarangecheckto

the preceding program and proves that it works:
Chapter15:OperatorOverloading
409C++410C++:TheCompleteReference
// A safe array example.#include <iostream>
#include <cstdlib>
using namespace std;class atype {int a[3];public:atype(int i, int j, int k) {a[0] = i;a[1] = j;
a[2] = k;}
int &operator[](int i);};// Provide range checking for atype.int &atype::operator[](int i)
{if(i<0 || i> 2) {cout << "Boundary Error\n";
exit(1);}
return a[i];}int main(){atype ob(1, 2, 3);cout << ob[1]; // displays 2cout << " ";ob[1] = 25; // [] appears on leftcout << ob[1]; // displays 25ob[3] = 44; // generates runtime error, 3 out-of-range
return 0;}Chapter15:OperatorOverloading
411C++In this program, when the statement
ob[3] = 44;executes, the boundary error is intercepted by
operator[]( ),and the program
is terminated before any damage can be done. (In actual practice, some sort of
error-handling function would be called to deal with the out-of-range condition;

the program would not have to terminate.)
Overloading ( )When you overload the( )function call operator, you are not, per se, creating a new
way to call a function. Rather, you are creating an operator function that can be passed

an arbitrary number of parameters. Let's begin with an example. Given the overloaded
operator function declarationdouble operator()(int a, float f, char *s);and an objectOof its class, then the statementO(10, 23.34, "hi");translates into this call to theoperator( )function.O.operator()(10, 23.34, "hi");In general, when you overload the( )operator, you define the parameters that
you want to pass to that function. When you use the( )operator in your program,
the arguments you specify are copied to those parameters. As always, the object

that generates the call (Oin this example) is pointed to by thethispointer.
Here is an example of overloading
( )for thelocclass. It assigns the value of itstwo arguments to the longitude and latitude of the object to which it is applied.
#include <iostream>using namespace std;class loc {int longitude, latitude;public:loc() {}loc(int lg, int lt) {longitude = lg;latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}loc operator+(loc op2);loc operator()(int i, int j);};// Overload ( ) for loc.loc loc::operator()(int i, int j)
{longitude = i;
latitude = j;return *this;}
// Overload + for loc.loc loc::operator+(loc op2)
{loc temp;temp.longitude = op2.longitude + longitude;temp.latitude = op2.latitude + latitude;
return temp;}int main(){loc ob1(10, 20), ob2(1, 1);ob1.show();ob1(7, 8); // can be executed by itself
ob1.show();412C++:TheCompleteReference
ob1 = ob2 + ob1(10, 10); // can be used in expressionsob1.show();return 0;}The output produced by the program is shown here.
10 207 8
11 11Remember, when overloading
( ),you can use any type of parameters and return
any type of value. These types will be dictated by the demands of your programs. You
can also specify default arguments.
Overloading –>The–>pointer operator, also called the
classmemberaccess
operator, is considered
a unary operator when overloading. Its general usage is shown here:
object->element;Here,
objectis the object that activates the call. Theoperator–>( )function must return
a pointer to an object of the class thatoperator–>( )operates upon. Theelementmust besome member accessible within the object.The following program illustrates overloading the
–>by showing the equivalencebetweenob.iandob–>iwhenoperator–>( )returns the
thispointer:#include <iostream>using namespace std;class myclass {public:int i;
myclass *operator->() {return this;}};int main(){myclass ob;Chapter15:OperatorOverloading
413C++414C++:TheCompleteReference
ob->i = 10; // same as ob.icout << ob.i << " " << ob->i;
return 0;}Anoperator–>( )function must be a member of the class upon which it works.Overloading the Comma OperatorYou can overload C++'s comma operator. The comma is a binary operator, and like all
overloaded operators, you can make an overloaded comma perform any operation you
want. However, if you want the overloaded comma to perform in a fashion similar to

its normal operation, then your version must discard the values of all operands except

the rightmost. The rightmost value becomes the result of the comma operation. This

is the way the comma works by default in C++.Here is a program that illustrates the effect of overloading the comma operator.
#include <iostream>using namespace std;class loc {int longitude, latitude;public:loc() {}loc(int lg, int lt) {longitude = lg;
latitude = lt;}void show() {cout << longitude << " ";cout << latitude << "\n";}loc operator+(loc op2);loc operator,(loc op2);Chapter15:OperatorOverloading
415C++};// overload comma for locloc loc::operator,(loc op2)
{loc temp;temp.longitude = op2.longitude;temp.latitude = op2.latitude;
cout << op2.longitude << " " << op2.latitude << "\n";return temp;}
// Overload + for locloc loc::operator+(loc op2)
{loc temp;temp.longitude = op2.longitude + longitude;temp.latitude = op2.latitude + latitude;return temp;}
int main(){loc ob1(10, 20), ob2( 5, 30), ob3(1, 1);ob1.show();ob2.show();
ob3.show();
cout << "\n";ob1 = (ob1, ob2+ob2, ob3);
ob1.show(); // displays 1 1, the value of ob3
return 0;}This program displays the following output:
10 205 30
1 110 601 1
1 1Noticethatalthoughthevaluesoftheleft-handoperandsarediscarded,eachexpression
is still evaluated by the compiler so that any desired side effects will be performed.
Remember, the left-hand operand is passed via
this, and its value is discarded
by theoperator,( )
function. The value of the right-hand operation is returned by
the function. This causes the overloaded comma to behave similarly to its default
operation. If you want the overloaded comma to do something else, you will have
to change these two features.
416C++:TheCompleteReference
Chapter16
Inheritance417Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
418C++:TheCompleteReference
Inheritance is one of the cornerstones of OOP because it allows the creation ofhierarchical classifications. Using inheritance, you can create a general class that
defines traits common to a set of related items. This class may then be inheritedby other, more specific classes, each adding only those things that are unique to the
inheriting class.In keeping with standard C++ terminology, a class that is inherited is referred to
as abaseclass
. The class that does the inheriting is called thederived class. Further, a
derived class can be used as a base class for another derived class. In this way, multiple

inheritance is achieved.C++'s support of inheritance is both rich and flexible. Inheritance was introduced in
Chapter 11. It is examined in detail here.
Base-Class Access Control
When a class inherits another, the members of the base class become members of the

derived class. Class inheritance uses this general form:classderived-class-name : access base-class-name{//body of class};The access status of the base-class members inside the derived class is determined by
access. The base-class access specifier must be eitherpublic,private,or
protected. If noaccess specifier is present, the access specifier is
privateby default if the derived classis aclass. If the derived class is astruct, thenpublicis the default in the absence of anexplicit access specifier. Let's examine the ramifications of using
publicorprivateaccess. (Theprotectedspecifier is examined in the next section.)When the access specifier for a base class ispublic, all public members of the basebecome public members of the derived class, and all protected members of the base

become protected members of the derived class. In all cases, the base's private elements

remain private to the base and are not accessible by members of the derived class. For

example, as illustrated in this program, objects of type
derivedcan directly access the
public members ofbase:#include <iostream>using namespace std;class base {int i, j;public:void set(int a, int b) { i=a; j=b; }void show() { cout << i << " " << j << "\n"; }};class derived : public base {int k;public:derived(int x) { k=x; }void showk() { cout << k << "\n"; }};int main(){derived ob(3);ob.set(1, 2); // access member of baseob.show(); // access member of baseob.showk(); // uses member of derived class
return 0;}When the base class is inherited by using theprivateaccess specifier, all public and
protected members of the base class become private members of the derived class. For
example, the following program will not even compile because both
set( )andshow( )are now private elements of
derived:// This program won't compile.#include <iostream>
using namespace std;class base {int i, j;public:void set(int a, int b) { i=a; j=b; }void show() { cout << i << " " << j << "\n";}};// Public elements of base are private in derived.class derived : private base {int k;Chapter16:Inheritance
419C++420C++:TheCompleteReference
public:derived(int x) { k=x; }void showk() { cout << k << "\n"; }};int main(){derived ob(3);ob.set(1, 2); // error, can't access set()ob.show(); // error, can't access show()return 0;}When a base class' access specifier isprivate,public and protected members of the base
become private members of the derived class. This means that they are still accessible by
members of the derived class but cannot be accessed by parts of your program that are

not members of either the base or derived class.Inheritance and protected Members
TheprotectedkeywordisincludedinC++toprovidegreaterflexibilityinthe
inheritancemechanism.Whenamemberofaclassisdeclaredas
protected,that
memberisnotaccessiblebyother,nonmemberelementsoftheprogram.Withone

important exception, access to a protected member is the same as access to a private

member—it can be accessed only by other members of its class. The sole exception to
this is when a protected member is inherited. In this case, a protected member differs

substantially from a private one.
Asexplainedintheprecedingsection,aprivatememberofabaseclassisnot
accessiblebyotherpartsofyourprogram,includinganyderivedclass.However,

protectedmembersbehavedifferently.Ifthebaseclassisinheritedas
public,then
the base class' protected members become protected members of the derived class and

are, therefore, accessible by the derived class. By using
protected, you can create class
members that are private to their class but that can still be inherited and accessed by a

derived class. Here is an example:
#include <iostream>using namespace std;class base {Chapter16:Inheritance
421C++protected:int i, j; // private to base, but accessible by derivedpublic:void set(int a, int b) { i=a; j=b; }void show() { cout << i << " " << j << "\n"; }};class derived : public base {int k;public:// derived may access base's i and jvoid setk() { k=i*j; }void showk() { cout << k << "\n"; }};
int main(){derived ob;ob.set(2, 3); // OK, known to derivedob.show(); // OK, known to derivedob.setk();ob.showk();return 0;}In this example, becausebaseis inherited byderivedaspublicand becauseiandjare declared as
protected,derived's functionsetk( )may access them. Ifiandjhadbeen declared as
privatebybase, thenderivedwould not have access to them, and theprogram would not compile.
When a derived class is used as a base class for another derived class, any protected
member of the initial base class that is inherited (as public) by the first derived classmay also be inherited as protected again by a second derived class. For example, this

program is correct, and
derived2does indeed have access toiandj.#include <iostream>using namespace std;class base {protected:int i, j;public:void set(int a, int b) { i=a; j=b; }void show() { cout << i << " " << j << "\n"; }};// i and j inherited as protected.class derived1 : public base {int k;public:void setk() { k = i*j; } // legal
void showk() { cout << k << "\n"; }};// i and j inherited indirectly through derived1.class derived2 : public derived1 {int m;public:void setm() { m = i-j; } // legal
void showm() { cout << m << "\n"; }};int main(){derived1 ob1;
derived2 ob2;ob1.set(2, 3);ob1.show();
ob1.setk();
ob1.showk();ob2.set(3, 4);ob2.show();
ob2.setk();
ob2.setm();
ob2.showk();
ob2.showm();return 0;}422C++:TheCompleteReference
If, however,
basewere inherited as
private, then all members ofbasewouldbecome private members ofderived1, which means that they would not be accessiblebyderived2. (However,
iandjwould still be accessible byderived1.) This situationisillustratedbythefollowingprogram,whichisinerror(andwon'tcompile).The
commentsdescribeeacherror:
// This program won't compile.#include <iostream>
using namespace std;class base {protected:int i, j;public:void set(int a, int b) { i=a; j=b; }
void show() { cout << i << " " << j << "\n"; }};// Now, all elements of base are private in derived1.class derived1 : private base {int k;public:// this is legal because i and j are private to derived1
void setk() { k = i*j; } // OK
void showk() { cout << k << "\n"; }};// Access to i, j, set(), and show() not inherited.class derived2 : public derived1 {int m;public:// illegal because i and j are private to derived1
void setm() { m = i-j; } // Error
void showm() { cout << m << "\n"; }};int main(){derived1 ob1;
derived2 ob2;ob1.set(1, 2); // error, can't use set()C++Chapter16:Inheritance
423424C++:TheCompleteReference
ob1.show(); // error, can't use show()ob2.set(3, 4); // error, can't use set()ob2.show(); // error, can't use show()return 0;}Even thoughbaseis inherited asprivatebyderived1,derived1still has access tobase'spublicandprotected
elements. However, it cannot pass along this privilege.
Protected Base-Class Inheritance
It is possible to inherit a base class asprotected.When this is done, all public andprotected members of the base class become protected members of the derived class.
For example,#include <iostream>using namespace std;class base {protected:int i, j; // private to base, but accessible by derivedpublic:void setij(int a, int b) { i=a; j=b; }
void showij() { cout << i << " " << j << "\n"; }};// Inherit base as protected.class derived : protected base{int k;public:// derived may access base's i and j and setij().
void setk() { setij(10, 12); k = i*j; }// may access showij() herevoid showall() { cout << k << " "; showij(); }};int main(){derived ob;//  ob.setij(2, 3); // illegal, setij() is//                     protected member of derivedob.setk(); // OK, public member of derived
ob.showall(); // OK, public member of derived// ob.showij(); // illegal, showij() is protected
//                 member of derivedreturn 0;}As you can see by reading the comments, even though
setij( )andshowij( )are
publicmembersof
base,theybecomeprotectedmembersof
derivedwhenitis
inheritedusingthe
protectedaccessspecifier.Thismeansthattheywillnotbe
accessibleinside
main()
.Inheriting Multiple Base ClassesIt is possible for a derived class to inherit two or more base classes. For example, in this
short example,derivedinherits bothbase1andbase2.// An example of multiple base classes.#include <iostream>using namespace std;class base1 {protected:int x;public:void showx() { cout << x << "\n"; }};class base2 {protected:int y;public:Chapter16:Inheritance
425C++426C++:TheCompleteReference
void showy() {cout << y << "\n";}};// Inherit multiple base classes.class derived: public base1, public base2 {
public:void set(int i, int j) { x=i; y=j; }};int main(){derived ob;ob.set(10, 20); // provided by derivedob.showx(); // from base1
ob.showy(); // from base2return 0;}Astheexampleillustrates,toinheritmorethanonebaseclass,useacomma-
separatedlist.Further,besuretouseanaccess-specifierforeachbaseinherited.
Constructors, Destructors, and Inheritance
There are two major questions that arise relative to constructors and destructors when
inheritance is involved. First, when are base-class and derived-class constructors and

destructors called? Second, how can parameters be passed to base-class constructors?

This section examines these two important topics.When Constructors and Destructors
Are Executed
It is possible for a base class, a derived class, or both to contain constructors and/or
destructors.Itisimportanttounderstandtheorderinwhichthesefunctionsare

executed when an object of a derived class comes into existence and when it goes out
of existence. To begin, examine this short program:
#include <iostream>using namespace std;Chapter16:Inheritance
427C++class base {public:base() { cout << "Constructing base\n"; }~base() { cout << "Destructing base\n"; }};class derived: public base {public:derived() { cout << "Constructing derived\n"; }
~derived() { cout << "Destructing derived\n"; }};int main(){derived ob;// do nothing but construct and destruct ob
return 0;}As the comment inmain( )indicates, this program simply constructs and then
destroys an object called
obthat is of classderived. When executed, this program
displaysConstructing baseConstructing derived
Destructing derived
Destructing baseAsyoucansee,first
base'sconstructorisexecutedfollowedby
derived's.Next(because
obis immediately destroyed in this program),
derived's destructor is called, followed
bybase's.The results of the foregoing experiment can be generalized. When an object of a
derived class is created, the base class’ constructor will be called first, followed by the
derived class’ constructor. When a derived object is destroyed, its destructor is called

first, followed by the base class' destructor. Put differently, constructors are executed in

their order of derivation. Destructors are executed in reverse order of derivation.
If you think about it, it makes sense that constructors are executed in order of
derivation. Because a base class has no knowledge of any derived class, any428C++:TheCompleteReference
initialization it needs to perform is separate from and possibly prerequisite to any
initialization performed by the derived class. Therefore, it must be executed first.
Likewise, it is quite sensible that destructors be executed in reverse order of
derivation. Because the base class underlies the derived class, the destruction of

the base object implies the destruction of the derived object. Therefore, the derived

destructor must be called before the object is fully destroyed.
In cases of multiple inheritance (that is, where a derived class becomes the base
class for another derived class), the general rule applies: Constructors are called in

order of derivation, destructors in reverse order. For example, this program
#include <iostream>using namespace std;class base {public:base() { cout << "Constructing base\n"; }
~base() { cout << "Destructing base\n"; }};class derived1 : public base {public:derived1() { cout << "Constructing derived1\n"; }
~derived1() { cout << "Destructing derived1\n"; }};class derived2: public derived1 {public:derived2() { cout << "Constructing derived2\n"; }
~derived2() { cout << "Destructing derived2\n"; }};int main(){derived2 ob;// construct and destruct ob
return 0;}displays this output:Constructing baseConstructing derived1
Constructing derived2
Destructing derived2
Destructing derived1
Destructing baseThesamegeneralruleappliesinsituationsinvolvingmultiplebaseclasses.
Forexample,thisprogram
#include <iostream>
using namespace std;class base1 {public:base1() { cout << "Constructing base1\n"; }
~base1() { cout << "Destructing base1\n"; }};class base2 {public:base2() { cout << "Constructing base2\n"; }
~base2() { cout << "Destructing base2\n"; }};class derived: public base1, public base2 {public:derived() { cout << "Constructing derived\n"; }
~derived() { cout << "Destructing derived\n"; }};int main(){derived ob;// construct and destruct ob
return 0;}Chapter16:Inheritance
429C++produces this output:
Constructing base1Constructing base2
Constructing derived
Destructing derived
Destructing base2
Destructing base1Asyoucansee,constructorsarecalledinorderofderivation,lefttoright,asspecified
inderived'sinheritancelist.Destructorsarecalledinreverseorder,righttoleft.This
meansthathad
base2beenspecifiedbefore
base1inderived'slist,asshownhere:
class derived: public base2, public base1 {then the output of this program would have looked like this:
Constructing base2
Constructing base1
Constructing derived
Destructing derived
Destructing base1
Destructing base2Passing Parameters to Base-Class Constructors
So far, none of the preceding examples have included constructors that require
arguments. In cases where only the derived class' constructor requires one or more

parameters, you simply use the standard parameterized constructor syntax (see

Chapter 12). However, how do you pass arguments to a constructor in a base class?

The answer is to use an expanded form of the derived class's constructor declaration

that passes along arguments to one or more base-class constructors. The general form

of this expanded derived-class constructor declaration is shown here:
derived-constructor(arg-list) : base1(arg-list),base2(arg-list),// ...
baseN(arg-list){//body of derived constructor}430C++:TheCompleteReference
Chapter16:Inheritance
431C++Here,
base1through
baseNare the names of the base classes inherited by the derived
class. Notice that a colon separates the derived class' constructor declaration from the
base-class specifications, and that the base-class specifications are separated from each

other by commas, in the case of multiple base classes. Consider this program:
#include <iostream>using namespace std;class base {protected:int i;public:base(int x) { i=x; cout << "Constructing base\n"; }
~base() { cout << "Destructing base\n"; }};class derived: public base {int j;public:// derived uses x; y is passed along to base.derived(int x, int y): base(y){ j=x; cout << "Constructing derived\n"; }~derived() { cout << "Destructing derived\n"; }
void show() { cout << i << " " << j << "\n"; }};int main(){derived ob(3, 4);ob.show(); // displays 4 3
return 0;}Here,
derived's constructor is declared as taking two parameters,
xandy. However,
derived()
usesonly
x;y
ispassedalongto
base().
Ingeneral,thederivedclass'constructor
must declare both the parameter(s) that it requires as well as any required by the base
class. As the example illustrates, any parameters required by the base class are passed

to it in the base class' argument list specified after the colon.
Here is an example that uses multiple base classes:
#include <iostream>using namespace std;class base1 {protected:int i;public:base1(int x) { i=x; cout << "Constructing base1\n"; }
~base1() { cout << "Destructing base1\n"; }};class base2 {protected:int k;public:base2(int x) { k=x; cout << "Constructing base2\n"; }
~base2() { cout << "Destructing base1\n"; }};class derived: public base1, public base2 {int j;public:derived(int x, int y, int z): base1(y), base2(z){ j=x; cout << "Constructing derived\n"; }~derived() { cout << "Destructing derived\n"; }void show() { cout << i << " " << j << " " << k << "\n"; }};int main(){derived ob(3, 4, 5);ob.show(); // displays 4 3 5
return 0;}It is important to understand that arguments to a base-class constructor are passed
via arguments to the derived class' constructor. Therefore, even if a derived class'
constructor does not use any arguments, it will still need to declare one if the base class
432C++:TheCompleteReference
Chapter16:Inheritance
433C++requires it. In this situation, the arguments passed to the derived class are simply
passed along to the base. For example, in this program, the derived class' constructor

takes no arguments, but
base1( )andbase2( )do:#include <iostream>using namespace std;class base1 {protected:int i;public:base1(int x) { i=x; cout << "Constructing base1\n"; }
~base1() { cout << "Destructing base1\n"; }};class base2 {protected:int k;public:base2(int x) { k=x; cout << "Constructing base2\n"; }
~base2() { cout << "Destructing base2\n"; }};class derived: public base1, public base2 {public:/* Derived constructor uses no parameter,but still must be declared as taking them to
pass them along to base classes.*/derived(int x, int y): base1(x), base2(y){ cout << "Constructing derived\n"; }~derived() { cout << "Destructing derived\n"; }void show() { cout << i << " " << k << "\n"; }};int main(){derived ob(3, 4);ob.show(); // displays 3 4434C++:TheCompleteReference
return 0;}Aderived class' constructor is free to make use of any and all parameters that it is
declared as taking, even if one or more are passed along to a base class. Put differently,
passing an argument along to a base class does not preclude its use by the derived class

as well. For example, this fragment is perfectly valid:class derived: public base {int j;public:// derived uses both x and y and then passes them to base.derived(int x, int y): base(x, y){ j = x*y; cout << "Constructing derived\n"; }One final point to keep in mind when passing arguments to base-class constructors:
The argument can consist of any expression valid at the time. This includes function
calls and variables. This is in keeping with the fact that C++ allows dynamic
initialization.Granting AccessWhen a base class is inherited asprivate, all public and protected members of that
class become private members of the derived class. However, in certain circumstances,

youmaywanttorestoreoneormoreinheritedmemberstotheiroriginalaccess

specification. For example, you might want to grant certain public members of the
base class public status in the derived class even though the base class is inherited as
private. In Standard C++, you have two ways to accomplish this. First, you can use a

usingstatement, which is the preferred way. The
usingstatement is designed primarilyto support namespaces and is discussed in Chapter 23. The second way to restore an

inheritedmember'saccessspecificationistoemployan
accessdeclaration
withinthederived
class.AccessdeclarationsarecurrentlysupportedbyStandardC++,buttheyare

deprecated. This means that they should not be used for new code. Since there are still

many,manyexistingprogramsthatuseaccessdeclarations,theywillbeexaminedhere.
An access declaration takes this general form:base-class::member;Chapter16:Inheritance
435C++The access declaration is put under the appropriate access heading in the derived class'
declaration. Notice that no type declaration is required (or, indeed, allowed) in an

access declaration.To see how an access declaration works, let's begin with this short fragment:
class base {public:int j; // public in base};// Inherit base as private.class derived: private base {
public:// here is access declaration
base::j; // make j public again
.
.
.};Becausebaseis inherited asprivatebyderived, the public memberjis made a privatemember ofderived. However, by including
base::j;astheaccessdeclarationunder
derived'spublicheading,jisrestoredtoitspublicstatus.
Youcanuseanaccessdeclarationtorestoretheaccessrightsofpublicandprotected
members. However, you cannot use an access declaration to raise or lower a member's
accessstatus.Forexample,amemberdeclaredasprivateinabaseclasscannotbe

madepublicbyaderivedclass.(IfC++allowedthistooccur,itwoulddestroyits

encapsulation mechanism!)The following program illustrates the access declaration; notice how it uses access
declarations to restore
j,seti( ), andgeti( )topublicstatus.#include <iostream>using namespace std;class base {int i; // private to basepublic:int j, k;void seti(int x) { i = x; }
int geti() { return i; }};// Inherit base as private.class derived: private base {
public:/* The next three statements overridebase's inheritance as private and restore j,
seti(), and geti() to public access. */base::j; // make j public again - but not k
base::seti; // make seti() public
base::geti; // make geti() public// base::i; // illegal, you cannot elevate accessint a; // public};int main(){derived ob;//ob.i = 10; // illegal because i is private in derivedob.j = 20; // legal because j is made public in derived//ob.k = 30; // illegal because k is private in derivedob.a = 40; // legal because a is public in derived
ob.seti(10);cout << ob.geti() << " " << ob.j << " " << ob.a;
return 0;}Access declarations are supported in C++ to accommodate those situations in
which most of an inherited class is intended to be made private, but a few membersare to retain their public or protected status.
436C++:TheCompleteReference
Chapter16:Inheritance
437C++While Standard C++ still supports access declarations, they are deprecated. This means
that they are allowed for now, but they might not be supported in the future. Instead, the

standard suggests achieving the same effect by applying theusingkeyword.Virtual Base Classes
An element of ambiguity can be introduced into a C++ program when multiple base

classes are inherited. For example, consider this incorrect program:
// This program contains an error and will not compile.#include <iostream>
using namespace std;class base {public:int i;};// derived1 inherits base.class derived1 :  public base {
public:int j;};// derived2 inherits base.class derived2 : public base {
public:int k;};/* derived3 inherits both derived1 and derived2.This means that there are two copies of basein derived3! */class derived3 : public derived1, public derived2 {
public:int sum;};int main(){derived3 ob;ob.i = 10; // this is ambiguous, which i???ob.j = 20;
ob.k = 30;// i ambiguous here, tooob.sum = ob.i + ob.j + ob.k;// also ambiguous, which i?cout << ob.i << " ";cout << ob.j << " " << ob.k << " ";cout << ob.sum;return 0;}As the comments in the program indicate, both
derived1andderived2inheritbase.However,
derived3inherits bothderived1andderived2. This means that there are two
copies ofbasepresent in an object of type
derived3. Therefore, in an expression like
ob.i = 10;whichiis being referred to, the one in
derived1or the one inderived2?Because there
are two copies of
basepresent in object
ob, there are two
ob.is! As you can see, thestatement is inherently ambiguous.
There are two ways to remedy the preceding program. The first is to apply the
scope resolution operator to
iand manually select onei.For example, this version ofthe program does compile and run as expected:
// This program uses explicit scope resolution to select i.#include <iostream>
using namespace std;class base {public:int i;};// derived1 inherits base.438C++:TheCompleteReference
class derived1 :  public base {public:int j;};// derived2 inherits base.class derived2 : public base {
public:int k;};/* derived3 inherits both derived1 and derived2.This means that there are two copies of basein derived3! */class derived3 : public derived1, public derived2 {
public:int sum;};int main(){derived3 ob;ob.derived1::i = 10; // scope resolved, use derived1's iob.j = 20;
ob.k = 30;// scope resolvedob.sum = ob.derived1::i + ob.j + ob.k;// also resolved herecout << ob.derived1::i << " ";cout << ob.j << " " << ob.k << " ";cout << ob.sum;return 0;}As you can see, because the::was applied, the program has manually selected
derived1's version ofbase. However, this solution raises a deeper issue: What if only
one copy ofbaseis actually required? Is there some way to prevent two copies from
Chapter16:Inheritance
439C++being included inderived3? The answer, as you probably have guessed, is yes. This
solution is achieved usingvirtualbase classes.When two or more objects are derived from a common base class, you can prevent
multiple copies of the base class from being present in an object derived from those
objects by declaring the base class asvirtualwhen it is inherited. You accomplish this
by preceding the base class' name with the keyword
virtualwhen it is inherited. Forexample, here is another version of the example program in which
derived3containsonly one copy ofbase:// This program uses virtual base classes.#include <iostream>
using namespace std;class base {public:int i;};// derived1 inherits base as virtual.class derived1 : virtual public base {
public:int j;};// derived2 inherits base as virtual.class derived2 : virtual public base {
public:int k;};/* derived3 inherits both derived1 and derived2.This time, there is only one copy of base class. */class derived3 : public derived1, public derived2 {public:int sum;};int main(){derived3 ob;ob.i = 10; // now unambiguous440C++:TheCompleteReference
ob.j = 20;ob.k = 30;// unambiguousob.sum = ob.i + ob.j + ob.k;// unambiguouscout << ob.i << " ";cout << ob.j << " " << ob.k << " ";cout << ob.sum;return 0;}As you can see, the keyword
virtualprecedes the rest of the inherited
class'specification. Now that bothderived1andderived2have inheritedbaseasvirtual,any multiple inheritance involving them will cause only one copy ofbaseto be present.
Therefore, in
derived3, there is only one copy of
baseandob.i = 10is perfectly validand unambiguous.One further point to keep in mind: Even though bothderived1andderived2specifybaseasvirtual,baseis still present in objects of either type. For example, the
following sequence is perfectly valid:// define a class of type derived1derived1 myclass;myclass.i = 88;Theonlydifferencebetweenanormalbaseclassanda
virtualoneiswhatoccurs
when an object inherits the base more than once. If
virtualbase classes are used, then
only one base class is present in the object. Otherwise, multiple copies will be found.
Chapter16:Inheritance
441C++This page intentionally left blank Chapter17
Virtual Functions
and Polymorphism443Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
Polymorphism is supported by C++ both at compile time and at run time. Asdiscussed in earlier chapters, compile-time polymorphism is achieved by
overloading functions and operators. Run-time polymorphism is accomplishedby using inheritance and virtual functions, and these are the topics of this chapter.Virtual Functions
Avirtualfunction
isamemberfunctionthatisdeclaredwithinabaseclassandredefined
by a derived class. To create a virtual function, precede the function's declaration in the

baseclasswiththekeyword
virtual.Whenaclasscontainingavirtualfunctionisinherited,
the derived class redefines the virtual function to fit its own needs. In essence, virtual

functions implement the "one interface, multiple methods" philosophy that underlies
polymorphism.Thevirtualfunctionwithinthebaseclassdefinesthe
formofthe
interfaceto that function. Each redefinition of the virtual function by a derived class implements

itsoperationasitrelatesspecificallytothederivedclass.Thatis,theredefinition

creates a
specific method.When accessed "normally," virtual functions behave just like any other type of class
memberfunction.However,whatmakesvirtualfunctionsimportantandcapableof

supportingrun-timepolymorphismishowtheybehavewhenaccessedviaapointer.

AsdiscussedinChapter13,abase-classpointercanbeusedtopointtoanobjectof

anyclassderivedfromthatbase.Whenabasepointerpointstoaderivedobjectthat

contains a virtual function, C++ determines which version of that function to call based
uponthe type of object pointedto
by the pointer. And this determination is made
atrun
time.Thus,whendifferentobjectsarepointedto,differentversionsofthevirtualfunction

are executed. The same effect applies to base-class references.
To begin, examine this short example:
#include <iostream>using namespace std;class base {public:virtual void vfunc() {cout << "This is base's vfunc().\n";}};class derived1 : public base {public:void vfunc() {cout << "This is derived1's vfunc().\n";}444C++:TheCompleteReference
};class derived2 : public base {public:void vfunc() {cout << "This is derived2's vfunc().\n";}};int main(){base *p, b;
derived1 d1;
derived2 d2;// point to basep = &b;
p->vfunc(); // access base's vfunc()// point to derived1p = &d1;
p->vfunc(); // access derived1's vfunc()// point to derived2p = &d2;
p->vfunc(); // access derived2's vfunc()return 0;}This program displays the following:
This is base's vfunc().This is derived1's vfunc().
This is derived2's vfunc().As the program illustrates, inside
base, the virtual functionvfunc( )is declared.
Notice that the keyword
virtualprecedes the rest of the function declaration. When
vfunc( )is redefined by
derived1andderived2, the keyword
virtualis not needed.(However, it is not an error to include it when redefining a virtual function inside a
derived class; it's just not needed.)Chapter17:VirtualFunctionsandPolymorphism
445C++Inthisprogram,
baseisinheritedbyboth
derived1andderived2.Insideeach
classdefinition,
vfunc()
isredefinedrelativetothatclass.Inside
main()
,four
variablesaredeclared:
NameType
pbase class pointerbobject of base
d1object of derived1

d2object of derived2
Next,pis assigned the address of
b,andvfunc( )is called viap. Sincepis pointingtoanobjectoftype
base,thatversionof
vfunc()
isexecuted.Next,
pissettothe
address of
d1, and againvfunc( )is called by usingp. This timeppoints to an objectof typederived1. This causesderived1::vfunc( )to be executed. Finally,
pis assignedtheaddressof
d2,and
p>vfunc()
causestheversionof
vfunc()
redefinedinside
derived2to be executed. The key point here is that the kind of object to which
ppointsdetermines which version ofvfunc( )is executed. Further, this determination is made
at run time, and this process forms the basis for run-time polymorphism.
Althoughyoucancallavirtualfunctioninthe"normal"mannerbyusinganobject's
name and the dot operator, it is only when access is through a base-class pointer (or
reference)thatrun-timepolymorphismisachieved.Forexample,assumingthepreceding

example, this is syntactically valid:d2.vfunc(); // calls derived2's vfunc()Although calling a virtual function in this manner is not wrong, it simply does not take

advantage of the virtual nature of
vfunc( ).Atfirstglance,theredefinitionofavirtualfunctionbyaderivedclassappearssimilar
tofunctionoverloading.However,thisisnotthecase,andtheterm
overloadingisnot
appliedtovirtualfunctionredefinitionbecauseseveraldifferencesexist.Perhapsthe

mostimportantisthattheprototypeforaredefinedvirtualfunctionmustmatchexactly

theprototypespecifiedinthebaseclass.Thisdiffersfromoverloadinganormalfunction,

inwhichreturntypesandthenumberandtypeofparametersmaydiffer.(Infact,when

youoverloadafunction,eitherthenumberorthetypeoftheparameters
mustdiffer!It
isthroughthesedifferencesthatC++canselectthecorrectversionofanoverloaded

function.)However,whenavirtualfunctionisredefined,allaspectsofitsprototypemust

bethesame.Ifyouchangetheprototypewhenyouattempttoredefineavirtualfunction,

thefunctionwillsimplybeconsideredoverloadedbytheC++compiler,anditsvirtual

naturewillbelost.Anotherimportantrestrictionisthatvirtualfunctionsmustbe
446C++:TheCompleteReference
C++Chapter17:VirtualFunctionsandPolymorphism
447nonstaticmembersoftheclassesofwhichtheyarepart.Theycannotbe
friends.Finally,
constructorfunctionscannotbevirtual,butdestructorfunctionscan.
Because of the restrictions and differences between function overloading and
virtual function redefinition, the term
overridingis used to describe virtual functionredefinition by a derived class.
Calling a Virtual Function
Through a Base Class Reference
In the preceding example, a virtual function was called through a base-class pointer,
but the polymorphic nature of a virtual function is also available when called through

a base-class reference. As explained in Chapter 13, a reference is an implicit pointer.

Thus, a base-class reference can be used to refer to an object of the base class or any

object derived from that base. When a virtual function is called through a base-class

reference, the version of the function executed is determined by the object being

referred to at the time of the call.
The most common situation in which a virtual function is invoked through a base
class reference is when the reference is a function parameter. For example, consider the

following variation on the preceding program.
/* Here, a base class reference is used to accessa virtual function. */#include <iostream>using namespace std;class base {public:virtual void vfunc() {cout << "This is base's vfunc().\n";}};class derived1 : public base {public:void vfunc() {cout << "This is derived1's vfunc().\n";}};class derived2 : public base {public:448C++:TheCompleteReference
void vfunc() {cout << "This is derived2's vfunc().\n";}};// Use a base class reference parameter.void f(base &r) {r.vfunc();}int main(){base b;
derived1 d1;
derived2 d2;f(b); // pass a base object to f()f(d1); // pass a derived1 object to f()
f(d2); // pass a derived2 object to f()return 0;}This program produces the same output as its preceding version. In this example, the
functionf( )defines a reference parameter of type
base. Insidemain( ), the functionis called using objects of typebase,derived1, andderived2. Insidef( ), the specificversion ofvfunc( )that is called is determined by the type of object being referenced
when the function is called.For the sake of simplicity, the rest of the examples in this chapter will call virtual
functions through base-class pointers, but the effects are same for base-class references.
The Virtual Attribute Is Inherited
When a virtual function is inherited, its virtual nature is also inherited. This means that

when a derived class that has inherited a virtual function is itself used as a base class
for another derived class, the virtual function can still be overridden. Put differently, no

matter how many times a virtual function is inherited, it remains virtual. For example,

consider this program:
#include <iostream>using namespace std;class base {public:virtual void vfunc() {cout << "This is base's vfunc().\n";}};class derived1 : public base {public:void vfunc() {cout << "This is derived1's vfunc().\n";}};/* derived2 inherits virtual function vfunc()from derived1. */class derived2 : public derived1 {public:// vfunc() is still virtual
void vfunc() {cout << "This is derived2's vfunc().\n";}};int main(){base *p, b;
derived1 d1;
derived2 d2;// point to basep = &b;
p->vfunc(); // access base's vfunc()// point to derived1p = &d1;
p->vfunc(); // access derived1's vfunc()// point to derived2p = &d2;
p->vfunc(); // access derived2's vfunc()Chapter17:VirtualFunctionsandPolymorphism
449C++450C++:TheCompleteReference
return 0;}As expected, the preceding program displays this output:
This is base's vfunc().This is derived1's vfunc().
This is derived2's vfunc().In this case,derived2inheritsderived1rather thanbase, butvfunc( )is still virtual.Virtual Functions Are Hierarchical
As explained, when a function is declared as
virtualby a base class, it may beoverridden by a derived class. However, the function does not have to be overridden.
When a derived class fails to override a virtual function, then when an object of that
derived class accesses that function, the function defined by the base class is used. For
example, consider this program in which
derived2does not overridevfunc( ):#include <iostream>using namespace std;class base {public:virtual void vfunc() {cout << "This is base's vfunc().\n";}};class derived1 : public base {public:void vfunc() {cout << "This is derived1's vfunc().\n";}};class derived2 : public base {Chapter17:VirtualFunctionsandPolymorphism
451C++public:// vfunc() not overridden by derived2, base's is used
};int main(){base *p, b;derived1 d1;
derived2 d2;// point to basep = &b;
p->vfunc(); // access base's vfunc()// point to derived1p = &d1;
p->vfunc(); // access derived1's vfunc()// point to derived2p = &d2;
p->vfunc(); // use base's vfunc()return 0;}The program produces this output:
This is base's vfunc().This is derived1's vfunc().
This is base's vfunc().Becausederived2does not overridevfunc( ), the function defined bybaseis usedwhenvfunc( )is referenced relative to objects of type
derived2.The preceding program illustrates a special case of a more general rule. Because
inheritance is hierarchical in C++, it makes sense that virtual functions are also
hierarchical. This means that when a derived class fails to override a virtual function,

the first redefinition found in reverse order of derivation is used. For example, in the

following program,
derived2is derived from
derived1, which is derived from
base.However,
derived2does not overridevfunc()
. This means that, relative to
derived2,the closest version ofvfunc( )is inderived1. Therefore, it is
derived1::vfunc( )that isused when an object ofderived2attempts to callvfunc( ).#include <iostream>using namespace std;class base {public:virtual void vfunc() {cout << "This is base's vfunc().\n";}};class derived1 : public base {public:void vfunc() {cout << "This is derived1's vfunc().\n";}};class derived2 : public derived1 {public:
/* vfunc() not overridden by derived2.In this case, since derived2 is derived from
derived1, derived1's vfunc() is used.*/
};int main(){base *p, b;
derived1 d1;
derived2 d2;// point to basep = &b;
p->vfunc(); // access base's vfunc()// point to derived1p = &d1;
p->vfunc(); // access derived1's vfunc()452C++:TheCompleteReference
Chapter17:VirtualFunctionsandPolymorphism
453C++// point to derived2p = &d2;
p->vfunc(); // use derived1's vfunc()return 0;}The program displays the following:
This is base's vfunc().This is derived1's vfunc().
This is derived1's vfunc().Pure Virtual Functions
As the examples in the preceding section illustrate, when a virtual function is not
redefinedbyaderivedclass,theversiondefinedinthebaseclasswillbeused.

However,inmanysituationstherecanbenomeaningfuldefinitionofavirtual

functionwithinabaseclass.Forexample,abaseclassmaynotbeabletodefine

an object sufficiently to allow a base-class virtual function to be created. Further,

in some situations you will want to ensure that all derived classes override a virtual

function. To handle these two cases, C++ supports the pure virtual function.
Apure virtual function
is a virtual function that has no definition within the baseclass. To declare a pure virtual function, use this general form:
virtualtype func-name(parameter-list) = 0;When a virtual function is made pure, any derived class must provide its own
definition. If the derived class fails to override the pure virtual function, a compile-time

error will result.
The following program contains a simple example of a pure virtual function. The
base class,number, contains an integer calledval, the functionsetval( ), and the pure
virtual functionshow( ). The derived classeshextype,dectype, andocttypeinheritnumberandredefine
show()
sothatitoutputsthevalueof
valineachrespectivenumber
base (that is, hexadecimal, decimal, or octal).#include <iostream>using namespace std;class number {protected:int val;public:void setval(int i) { val = i; }// show() is a pure virtual functionvirtual void show() = 0;};class hextype : public number {public:void show() {cout << hex << val << "\n";}};class dectype : public number {public:void show() {cout << val << "\n";}};class octtype : public number {public:void show() {cout << oct << val << "\n";}};int main(){dectype d;
hextype h;
octtype o;d.setval(20);d.show(); // displays 20 - decimalh.setval(20);h.show(); // displays 14 - hexadecimal454C++:TheCompleteReference
o.setval(20);o.show();  // displays 24 - octalreturn 0;}Although this example is quite simple, it illustrates how a base class may not beable to meaningfully define a virtual function. In this case,numbersimply provides
the common interface for the derived types to use. There is no reason to define
show()
insidenumbersince the base of the number is undefined. Of course, you can alwayscreate a placeholder definition of a virtual function. However, making
show( )pure
also ensures that all derived classes will indeed redefine it to meet their own needs.
Keep in mind that when a virtual function is declared as pure, all derived classes
must override it. If a derived class fails to do this, a compile-time error will result.
Abstract ClassesAclass that contains at least one pure virtual function is said to be
abstract. Because anabstract class contains one or more functions for which there is no definition (that is,
apurevirtualfunction),noobjectsofanabstractclassmaybecreated.Instead,anabstract

class constitutes an incomplete type that is used as a foundation for derived classes.Although you cannot create objects of an abstract class, you can create pointers
and references to an abstract class. This allows abstract classes to support run-time

polymorphism, which relies upon base-class pointers and references to select the

proper virtual function.
Using Virtual Functions
One of the central aspects of object-oriented programming is the principle of "one

interface, multiple methods." This means that a general class of actions can be defined,
theinterfacetowhichisconstant,witheachderivationdefiningitsownspecificoperations.

In concrete C++ terms, a base class can be used to define the nature of the interface to a

general class. Each derived class then implements the specific operations as they relate

to the type of data used by the derived type.One of the most powerful and flexible ways to implement the "one interface,multiple methods" approach is to use virtual functions, abstract classes, and run-time

polymorphism. Using these features, you create a class hierarchy that moves from

generaltospecific(basetoderived).Followingthisphilosophy,youdefineall

common features and interfaces in a base class. In cases where certain actions can be

implemented only by the derived class, use a virtual function. In essence, in the baseChapter17:VirtualFunctionsandPolymorphism
455C++class you create and define everything you can that relates to the general case. The
derived class fills in the specific details.Following is a simple example that illustrates the value of the "one interface,multiple methods" philosophy. Aclass hierarchy is created that performs conversions

from one system of units to another. (For example, liters to gallons.) The base class

convertdeclares two variables,
val1andval2, which hold the initial and convertedvalues, respectively. It also defines the functions
getinit( )andgetconv( ), which return
the initial value and the converted value. These elements ofconvertare fixed and
applicable to all derived classes that will inheritconvert. However, the function that
will actually perform the conversion,compute( ), is a pure virtual function that must
bedefinedbytheclassesderivedfrom
convert.Thespecificnatureof
compute()
willbedeterminedbywhattypeofconversionistakingplace.
// Virtual function practical example.#include <iostream>
using namespace std;class convert {protected:double val1;  // initial value
double val2;  // converted valuepublic:convert(double i) {val1 = i;}
double getconv() { return val2; }
double getinit() { return val1; }virtual void compute() = 0;};
// Liters to gallons.class l_to_g : public convert {
public:l_to_g(double i) : convert(i) { }
void compute() {val2 = val1 / 3.7854;}};// Fahrenheit to Celsiusclass f_to_c : public convert {456C++:TheCompleteReference
public:f_to_c(double i) : convert(i) { }void compute() {val2 = (val1-32) / 1.8;}};int main(){convert *p;  // pointer to base classl_to_g lgob(4);f_to_c fcob(70);// use virtual function mechanism to convertp = &lgob;
cout << p->getinit() << " liters is ";
p->compute();
cout << p->getconv() << " gallons\n";  // l_to_gp = &fcob;cout << p->getinit() << " in Fahrenheit is ";
p->compute();
cout << p->getconv() << " Celsius\n";  // f_to_creturn 0;}The preceding program creates two derived classes from
convert, calledl_to_gandf_to_c. These classes perform the conversions of liters to gallons and Fahrenheit
to Celsius, respectively. Each derived class overrides
compute( )in its own way toperform the desired conversion. However, even though the actual conversion (that
is, method) differs between
l_to_gandf_to_c, the interface remains constant.
One of the benefits of derived classes and virtual functions is that handling a newcase is a very easy matter. For example, assuming the preceding program, you can add

a conversion from feet to meters by including this class:
// Feet to metersclass f_to_m : public convert {
public:f_to_m(double i) : convert(i) { }Chapter17:VirtualFunctionsandPolymorphism
457C++void compute() {val2 = val1 / 3.28;}};An important use of abstract classes and virtual functions is inclass libraries. You
can create a generic, extensible class library that will be used by other programmers.
Another programmer will inherit your general class, which defines the interface and

allelementscommontoallclassesderivedfromit,andwilladdthosefunctions

specifictothederivedclass.Bycreatingclasslibraries,youareabletocreateand

controltheinterfaceofageneralclasswhilestilllettingotherprogrammersadapt

it to their specific needs.One final point: The base classconvertis an example of an abstract class. Thevirtual functioncompute( )is not defined withinconvertbecause no meaningfuldefinition can be provided. The class
convertsimply does not contain sufficient
information forcompute( )to be defined. It is only whenconvertis inherited by aderived class that a complete type is created.
Early vs. Late BindingBefore concluding this chapter on virtual functions and run-time polymorphism, there

are two terms that need to be defined because they are used frequently in discussions

of C++ and object-oriented programming:
early bindingandlate binding.Early bindingrefers to events that occur at compile time. In essence, early binding
occurs when all information needed to call a function is known at compile time. (Put
differently, early binding means that an object and a function call are bound during

compilation.) Examples of early binding include normal function calls (including
standard library functions), overloaded function calls, and overloaded operators. The

main advantage to early binding is efficiency. Because all information necessary to call

a function is determined at compile time, these types of function calls are very fast.
The opposite of early binding islate binding. As it relates to C++, late binding refers
to function calls that are not resolved until run time. Virtual functions are used to

achieve late binding. As you know, when access is via a base pointer or reference, the

virtual function actually called is determined by the type of object pointed to by the
pointer. Because in most cases this cannot be determined at compile time, the object

and the function are not linked until run time. The main advantage to late binding is

flexibility. Unlike early binding, late binding allows you to create programs that can

respond to events occurring while the program executes without having to create a

large amount of "contingency code." Keep in mind that because a function call is not

resolved until run time, late binding can make for somewhat slower execution times.
458C++:TheCompleteReference
Chapter18
Templates
459Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
The template is one of C++'s most sophisticated and high-powered features.Although not part of the original specification for C++, it was added several
years ago and is supported by all modern C++ compilers. Using templates, itis possible to create generic functions and classes. In a generic function or class, the
type of data upon which the function or class operates is specified as a parameter.
Thus, you can use one function or class with several different types of data without
having to explicitly recode specific versions for each data type. Both generic functions
and generic classes are discussed in this chapter.Generic FunctionsAgenericfunctiondefinesageneralsetofoperationsthatwillbeappliedtovarioustypes

ofdata.Thetypeofdatathatthefunctionwilloperateuponispassedtoitasaparameter.

Throughagenericfunction,asinglegeneralprocedurecanbeappliedtoawiderangeof

data.Asyouprobablyknow,manyalgorithmsarelogicallythesamenomatterwhat

typeofdataisbeingoperatedupon.Forexample,theQuicksortsortingalgorithmisthe

samewhetheritisappliedtoanarrayofintegersoranarrayoffloats.Itisjustthatthe

typeofthedatabeingsortedisdifferent.Bycreatingagenericfunction,youcandefine

thenatureofthealgorithm,independentofanydata.Onceyouhavedonethis,the

compilerwillautomaticallygeneratethecorrectcodeforthetypeofdatathatisactually

usedwhenyouexecutethefunction.Inessence,whenyoucreateagenericfunctionyou

arecreatingafunctionthatcanautomaticallyoverloaditself.
Ageneric function is created using the keyword
template. The normal meaning ofthe word "template" accurately reflects its use in C++. It is used to create a template (or

framework) that describes what a function will do, leaving it to the compiler to fill in
the details as needed. The general form of a template function definition is shown here:
template <classTtype>ret-typefunc-name
(parameter list){//body of function}Here,
Ttypeis a placeholder name for a data type used by the function. This namemay be used within the function definition. However, it is only a placeholder that the

compiler will automatically replace with an actual data type when it creates a specific

version of the function. Although the use of the keyword
classto specify a generic typein atemplatedeclaration is traditional, you may also use the keyword
typename.The following example creates a generic function that swaps the values of the two
variables with which it is called. Because the general process of exchanging two values

is independent of the type of the variables, it is a good candidate for being made into a
generic function.460C++:TheCompleteReference
// Function template example.#include <iostream>
using namespace std;// This is a function template.template <class X> void swapargs(X &a, X &b)
{X temp;temp = a;a = b;
b = temp;}int main(){int i=10, j=20;
double x=10.1, y=23.3;
char a='x', b='z';cout << "Original i, j: " << i << ' ' << j << '\n';cout << "Original x, y: " << x << ' ' << y << '\n';
cout << "Original a, b: " << a << ' ' << b << '\n';swapargs(i, j); // swap integersswapargs(x, y); // swap floats
swapargs(a, b); // swap charscout << "Swapped i, j: " << i << ' ' << j << '\n';cout << "Swapped x, y: " << x << ' ' << y << '\n';
cout << "Swapped a, b: " << a << ' ' << b << '\n';return 0;}Let's look closely at this program. The line:
template <class X> void swapargs(X &a, X &b)tells the compiler two things: that a template is being created and that a generic
definition is beginning. Here,
Xis a generic type that is used as a placeholder. After the
templateportion, the functionswapargs( )is declared, using
Xas the data type of thevalues that will be swapped. Inmain( ), theswapargs( )function is called using three
Chapter18:Templates
461C++462C++:TheCompleteReference
different types of data:
ints,doubles, andchars. Becauseswapargs( )is a genericfunction, the compiler automatically creates three versions of
swapargs( ): one thatwill exchange integer values, one that will exchange floating-point values, and onethat will swap characters.Herearesomeimportanttermsrelatedtotemplates.First,agenericfunction(thatis,
afunctiondefinitionprecededbya
templatestatement)isalsocalleda
templatefunction
.Bothtermswillbeusedinterchangeablyinthisbook.Whenthecompilercreatesaspecific

versionofthisfunction,itissaidtohavecreateda
specialization.Thisisalsocalleda
generatedfunction
.Theactofgeneratingafunctionisreferredtoas
instantiatingit.Put
differently,ageneratedfunctionisaspecificinstanceofatemplatefunction.
Since C++ does not recognize end-of-line as a statement terminator, the
templateclause of a generic function definition does not have to be on the same line as the
function's name. The following example shows another common way to format the
swapargs( )function.template <class X>void swapargs(X &a, X &b)
{X temp;temp = a;a = b;
b = temp;}If you use this form, it is important to understand that no other statements can occurbetween thetemplatestatement and the start of the generic function definition. Forexample, the fragment shown next will not compile.// This will not compile.template <class X>
int i; // this is an error
void swapargs(X &a, X &b)
{X temp;temp = a;a = b;
b = temp;}As the comments imply, the
templatespecification must directly precede the
function definition.C++Chapter18:Templates
463A Function with Two Generic Types
You can define more than one generic data type in the
templatestatement by using acomma-separated list. For example, this program creates a template function that has
two generic types.#include <iostream>using namespace std;template <class type1, class type2>void myfunc(type1 x, type2 y)
{cout << x << ' ' << y << '\n';}int main(){myfunc(10, "I like C++");myfunc(98.6, 19L);
return 0;}Inthisexample,theplaceholdertypes
type1andtype2arereplacedbythe
compilerwiththedatatypes
intandchar*
,and
doubleandlong,respectively,
whenthecompilergeneratesthespecificinstancesof
myfunc()
withinmain()
.When you create a template function, you are, in essence, allowing the compiler to
generate as many different versions of that function as are necessary for handling

the various ways that your program calls the function.
Explicitly Overloading a Generic FunctionEven though a generic function overloads itself as needed, you can explicitly overload
one, too. This is formally calledexplicitspecialization
. If you overload a generic function,that overloaded function overrides (or "hides") the generic function relative to that

specific version. For example, consider the following revised version of the argument-

swapping example shown earlier.
// Overriding a template function.#include <iostream>
using namespace std;template <class X> void swapargs(X &a, X &b){X temp;temp = a;a = b;
b = temp;
cout << "Inside template swapargs.\n";}// This overrides the generic version of swapargs() for ints.void swapargs(int &a, int &b)
{int temp;temp = a;a = b;
b = temp;
cout << "Inside swapargs int specialization.\n";}int main(){int i=10, j=20;
double x=10.1, y=23.3;
char a='x', b='z';cout << "Original i, j: " << i << ' ' << j << '\n';cout << "Original x, y: " << x << ' ' << y << '\n';
cout << "Original a, b: " << a << ' ' << b << '\n';swapargs(i, j); // calls explicitly overloaded swapargs()swapargs(x, y); // calls generic swapargs()
swapargs(a, b); // calls generic swapargs()cout << "Swapped i, j: " << i << ' ' << j << '\n';cout << "Swapped x, y: " << x << ' ' << y << '\n';
cout << "Swapped a, b: " << a << ' ' << b << '\n';return 0;}464C++:TheCompleteReference
Chapter18:Templates
465C++This program displays the following output.
Original i, j: 10 20Original x, y: 10.1 23.3
Original a, b: x z
Inside swapargs int specialization.
Inside template swapargs.
Inside template swapargs.
Swapped i, j: 20 10
Swapped x, y: 23.3 10.1
Swapped a, b: z xAs the comments inside the program indicate, when
swapargs(i, j)is called, itinvokes the explicitly overloaded version ofswapargs( )defined in the program. Thus,
the compiler does not generate this version of the genericswapargs( )function, becausethe generic function is overridden by the explicit overloading.Recently, a new-style syntax was introduced to denote the explicit specialization
of a function. This new method uses thetemplatekeyword. For example, using the
new-style specialization syntax, the overloadedswapargs( )function from the
preceding program looks like this.
// Use new-style specialization syntax.
template<> void swapargs<int>(int &a, int &b)
{int temp;temp = a;a = b;
b = temp;
cout << "Inside swapargs int specialization.\n";}As you can see, the new-style syntax uses thetemplate<>construct to indicate
specialization. The type of data for which the specialization is being created is placed
insidetheanglebracketsfollowingthefunctionname.Thissamesyntaxisused

to specialize any type of generic function. While there is no advantage to using one

specialization syntax over the other at this time, the new-style is probably a better

approach for the long term.
Explicitspecializationofatemplateallowsyoutotailoraversionofageneric
functiontoaccommodateauniquesituation—perhapstotakeadvantageofsome

performance boost that applies to only one type of data, for example. However, as

a general rule, if you need to have different versions of a function for different data

types, you should use overloaded functions rather than templates.466C++:TheCompleteReference
Overloading a Function Template
In addition to creating explicit, overloaded versions of a generic function, you can also
overload thetemplatespecification itself. To do so, simply create another version of the
template that differs from any others in its parameter list. For example:
// Overload a function template declaration.#include <iostream>
using namespace std;// First version of f() template.template <class X> void f(X a)
{cout << "Inside f(X a)\n";}// Second version of f() template.template <class X, class Y> void f(X a, Y b)
{cout << "Inside f(X a, Y b)\n";}int main(){f(10);     // calls f(X)
f(10, 20); // calls f(X, Y)return 0;}Here, the template for
f( )is overloaded to accept either one or two parameters.Using Standard Parameters with Template Functions
You can mix standard parameters with generic type parameters in a template function.
These nongeneric parameters work just like they do with any other function. For
example:// Using standard parameters in a template function.#include <iostream>
using namespace std;const int TABWIDTH = 8;// Display data at specified tab position.template<class X> void tabOut(X data, int tab)
{for(; tab; tab--)for(int i=0; i<TABWIDTH; i++) cout << ' ';cout << data << "\n";}
int main(){tabOut("This is a test", 0);
tabOut(100, 1);
tabOut('X', 2);
tabOut(10/3, 3);return 0;}Here is the output produced by this program.
This is a test100X3In the program, the function
tabOut( )displays its first argument at the tab position
requested by its second argument. Since the first argument is a generic type,
tabOut( )can be used to display any type of data. Thetabparameter is a standard, call-by-value
parameter. The mixing of generic and nongeneric parameters causes no trouble and is,
indeed, both common and useful.Generic Function RestrictionsGeneric functions are similar to overloaded functions except that they are more

restrictive. When functions are overloaded, you may have different actions performed

within the body of each function. But a generic function must perform the same general
action for all versions—only the type of data can differ. Consider the overloaded
Chapter18:Templates
467C++functions in the following example program. These functions could
notbe replaced by
a generic function because they do not do the same thing.#include <iostream>#include <cmath>
using namespace std;void myfunc(int i){cout << "value is: " << i << "\n";}void myfunc(double d){double intpart;
double fracpart;fracpart = modf(d, &intpart);cout << "Fractional part: " << fracpart;
cout << "\n";
cout << "Integer part: " << intpart;}int main(){myfunc(1);
myfunc(12.2);return 0;}Applying Generic FunctionsGeneric functions are one of C++'s most useful features. They can be applied to all
types of situations. As mentioned earlier, whenever you have a function that defines

a generalizable algorithm, you can make it into a template function. Once you have
doneso,youmayuseitwithanytypeofdatawithouthavingtorecodeit.Before

movingontogenericclasses,twoexamplesofapplyinggenericfunctionswillbe

given. They illustrate how easy it is to take advantage of this powerful C++ feature.
468C++:TheCompleteReference
Chapter18:Templates
469C++A Generic Sort
Sorting is exactly the type of operation for which generic functions were designed.
Within wide latitude, a sorting algorithm is the same no matter what type of data is

being sorted. The following program illustrates this by creating a generic bubble sort.

Whilethebubblesortisaratherpoorsortingalgorithm,itsoperationisclearand

unclutteredanditmakesaneasy-to-understandexample.The
bubble()
functionwill sort any type of array. It is called with a pointer to the first element in the array

and the number of elements in the array.
// A Generic bubble sort.#include <iostream>
using namespace std;template <class X> void bubble(X *items,  // pointer to array to be sortedint count) // number of items in array{register int a, b;
X t;for(a=1; a<count; a++)for(b=count-1; b>=a; b--)if(items[b-1] > items[b]) {// exchange elementst = items[b-1];
items[b-1] = items[b];
items[b] = t;}}int main(){int iarray[7] = {7, 5, 4, 3, 9, 8, 6};
double darray[5] = {4.3, 2.5, -0.9, 100.2, 3.0};int i;
cout << "Here is unsorted integer array: ";for(i=0;  i<7; i++)cout << iarray[i] << ' ';cout << endl;cout << "Here is unsorted double array: ";for(i=0;  i<5; i++)cout << darray[i] << ' ';cout << endl;bubble(iarray, 7);bubble(darray, 5);cout << "Here is sorted integer array: ";for(i=0;  i<7; i++)cout << iarray[i] << ' ';cout << endl;cout << "Here is sorted double array: ";for(i=0;  i<5; i++)cout << darray[i] << ' ';cout << endl;return 0;}The output produced by the program is shown here.
Here is unsorted integer array: 7 5 4 3 9 8 6Here is unsorted double array: 4.3 2.5 -0.9 100.2 3
Here is sorted integer array: 3 4 5 6 7 8 9
Here is sorted double array: -0.9 2.5 3 4.3 100.2As you can see, the preceding program creates two arrays: one integer and one
double.Itthensortseach.Because
bubble()
isatemplatefunction,itisautomaticallyover-
loadedtoaccommodatethetwodifferenttypesofdata.Youmightwanttotryusing
bubble( )to sort other types of data, including classes that you create. In each case, the
compiler will create the right version of the function for you.
Compacting an ArrayAnother function that benefits from being made into a template is called
compact( ).This function compacts the elements in an array. It is not uncommon to want to remove

elements from the middle of an array and then move the remaining elements down so
470C++:TheCompleteReference
that all unused elements are at the end. This sort of operation is the same for all types
of arrays because it is independent of the type data actually being operated upon. The
genericcompact( )function shown in the following program is called with a pointer to
the first element in the array, the number of elements in the array, and the starting and

ending indexes of the elements to be removed. The function then removes those

elements and compacts the array. For the purposes of illustration, it also zeroes the

unused elements at the end of the array that have been freed by the compaction.
// A Generic array compaction function.#include <iostream>
using namespace std;template <class X> void compact(X *items,  // pointer to array to be compactedint count, // number of items in array
int start, // starting index of compacted region
int end)   // ending index of compacted region{register int i;for(i=end+1; i<count; i++, start++)items[start] = items[i];/* For the sake of illustration, the remainder ofthe array will be zeroed. */for( ; start<count; start++) items[start] = (X) 0;}
int main(){int nums[7] = {0, 1, 2, 3, 4, 5, 6};
char str[18] = "Generic Functions";int i;
cout << "Here is uncompacted integer array: ";for(i=0;  i<7; i++)cout << nums[i] << ' ';cout << endl;cout << "Here is uncompacted string: ";for(i=0;  i<18; i++)Chapter18:Templates
471C++cout << str[i] << ' ';cout << endl;compact(nums, 7, 2, 4);compact(str, 18, 6, 10);cout << "Here is compacted integer array: ";for(i=0;  i<7; i++)cout << nums[i] << ' ';cout << endl;cout << "Here is compacted string: ";for(i=0;  i<18; i++)cout << str[i] << ' ';cout << endl;return 0;}This program compacts two different types of arrays. One is an integer array, and the
other is a string. However, the
compact( )function will work for any type of array. The
output from this program in shown here.
Here is uncompacted integer array: 0 1 2 3 4 5 6Here is uncompacted string: G e n e r i c   F u n c t i o n s
Here is compacted integer array: 0 1 5 6 0 0 0
Here is compacted string: G e n e r i c t i o n sAs the preceding examples illustrate, once you begin to think in terms of templates,
many uses will naturally suggest themselves. As long as the underlying logic of a
function is independent of the data, it can be made into a generic function.Generic ClassesIn addition to generic functions, you can also define a generic class. When you do this,
you create a class that defines all the algorithms used by that class; however, the actual

type of the data being manipulated will be specified as a parameter when objects of
that class are created.
Generic classes are useful when a class uses logic that can be generalized. For
example, the same algorithms that maintain a queue of integers will also work for a
queue of characters, and the same mechanism that maintains a linked list of mailing472C++:TheCompleteReference
Chapter18:Templates
473C++addresses will also maintain a linked list of auto part information. When you create a
generic class, it can perform the operation you define, such as maintaining a queue or
a linked list, for any type of data. The compiler will automatically generate the correct

type of object, based upon the type you specify when the object is created.
The general form of a generic class declaration is shown here:
template <classTtype> classclass-name{..
.}Here,
Ttypeis the placeholder type name, which will be specified when a class isinstantiated. If necessary, you can define more than one generic data type using a

comma-separated list.Once you have created a generic class, you create a specific instance of that class
using the following general form:class-name<type>ob;Here,
typeis the type name of the data that the class will be operating upon. Memberfunctions of a generic class are themselves automatically generic. You need not use

templateto explicitly specify them as such.Inthefollowingprogram,the
stackclass(firstintroducedinChapter11)is
reworkedintoagenericclass.Thus,itcanbeusedtostoreobjectsofanytype.Inthis

example, a character stack and a floating-point stack are created, but any data type can

be used.// This function demonstrates a generic stack.#include <iostream>
using namespace std;const int SIZE = 10;
// Create a generic stack classtemplate <class StackType> class stack {StackType stck[SIZE]; // holds the stack
int tos; // index of top-of-stackpublic:stack() { tos = 0; } // initialize stack
void push(StackType ob); // push object on stack474C++:TheCompleteReference
StackType pop(); // pop object from stack};// Push an object.template<classStackType>voidstack<StackType>::push(StackTypeob)

{if(tos==SIZE) {cout << "Stack is full.\n";
return;}
stck[tos] = ob;
tos++;}
// Pop an object.
template <class StackType> StackType stack<StackType>::pop()
{if(tos==0) {cout << "Stack is empty.\n";
return 0; // return null on empty stack}
tos--;
return stck[tos];}int main(){// Demonstrate character stacks.
stack<char> s1, s2;  // create two character stacks
int i;s1.push('a');s2.push('x');
s1.push('b');
s2.push('y');
s1.push('c');
s2.push('z');for(i=0; i<3; i++) cout << "Pop s1: " << s1.pop() << "\n";for(i=0; i<3; i++) cout << "Pop s2: " << s2.pop() << "\n";// demonstrate double stacksstack<double> ds1, ds2;  // create two double stacksChapter18:Templates
475C++ds1.push(1.1);ds2.push(2.2);
ds1.push(3.3);
ds2.push(4.4);
ds1.push(5.5);
ds2.push(6.6);for(i=0; i<3; i++) cout << "Pop ds1: " << ds1.pop() << "\n";for(i=0; i<3; i++) cout << "Pop ds2: " << ds2.pop() << "\n";return 0;}As you can see, the declaration of a generic class is similar to that of a genericfunction. The actual type of data stored by the stack is generic in the class declaration.
It is not until an object of the stack is declared that the actual data type is determined.

When a specific instance ofstackis declared, the compiler automatically generates all
the functions and variables necessary for handling the actual data. In this example, two
different types of stacks are declared. Two are integer stacks. Two are stacks of
doubles.Pay special attention to these declarations:stack<char> s1, s2;  // create two character stacksstack<double> ds1, ds2;  // create two double stacksNotice how the desired data type is passed inside the angle brackets. By changing the
type of data specified whenstackobjects are created, you can change the type of data
stored in that stack. For example, by using the following declaration, you can create

another stack that stores character pointers.
stack<char *> chrptrQ;You can also create stacks to store data types that you create. For example, if you
want to use the following structure to store address information,
struct addr {char name[40];char street[40];
char city[30];
char state[3];char zip[12];};then to usestackto generate a stack that will store objects of type
addr, use adeclaration like this:stack<addr> obj;As thestackclass illustrates, generic functions and classes are powerful tools that
you can use to maximize your programming efforts, because they allow you to define
the general form of an object that can then be used with any type of data. You are saved

from the tedium of creating separate implementations for each data type with which

youwantthealgorithmtowork.Thecompilerautomaticallycreatesthespecificversions

ofthe class for you.
An Example with Two Generic Data Types
Atemplateclasscanhavemorethanonegenericdatatype.Simplydeclareallthedata

typesrequiredbytheclassinacomma-separatedlistwithinthe
templatespecification.Forexample,thefollowingshortexamplecreatesaclassthatusestwogenericdatatypes.
/* This example uses two generic data types in aclass definition.*/#include <iostream>
using namespace std;template <class Type1, class Type2> class myclass{Type1 i;
Type2 j;public:myclass(Type1 a, Type2 b) { i = a; j = b; }
void show() { cout << i << ' ' << j << '\n'; }};int main(){myclass<int, double> ob1(10, 0.23);
myclass<char, char *> ob2('X', "Templates add power.");476C++:TheCompleteReference
Chapter18:Templates
477C++ob1.show(); // show int, doubleob2.show(); // show char, char *return 0;}This program produces the following output:
10 0.23X Templates add power.Theprogramdeclarestwotypesofobjects.
ob1usesintanddoubledata.ob2usesacharacterandacharacterpointer.Forbothcases,thecompilerautomaticallygenerates
theappropriatedataandfunctionstoaccommodatethewaytheobjectsarecreated.
Applying Template Classes: A Generic Array Class
To illustrate the practical benefits of template classes, let's look at one way in which

they are commonly applied. As you saw in Chapter 15, you can overload the
[ ]operator. Doing so allows you to create your own array implementations, including

"safe arrays" that provide run-time boundary checking. As you know, in C++, it is

possible to overrun (or underrun) an array boundary at run time without generating

a run-time error message. However, if you create a class that contains the array, and

allow access to that array only through the overloaded
[ ]subscripting operator, then
you can intercept an out-of-range index.
By combining operator overloading with a template class, it is possible to create a
generic safe-array type that can be used for creating safe arrays of any data type. This

type of array is shown in the following program:
// A generic safe array example.#include <iostream>
#include <cstdlib>
using namespace std;const int SIZE = 10;
template <class AType> class atype {AType a[SIZE];public:atype() {register int i;for(i=0; i<SIZE; i++) a[i] = i;}AType &operator[](int i);};// Provide range checking for atype.template <class AType> AType &atype<AType>::operator[](int i)
{if(i<0 || i> SIZE-1) {cout << "\nIndex value of ";
cout << i << " is out-of-bounds.\n";
exit(1);}
return a[i];}int main(){atype<int> intob; // integer array
atype<double> doubleob; // double arrayint i;
cout << "Integer array: ";for(i=0; i<SIZE; i++) intob[i] = i;
for(i=0; i<SIZE; i++) cout << intob[i] << "  ";
cout << '\n';cout << "Double array: ";for(i=0; i<SIZE; i++) doubleob[i] = (double) i/3;
for(i=0; i<SIZE; i++) cout << doubleob[i] << "  ";
cout << '\n';intob[12] = 100; // generates runtime error
return 0;}This program implements a generic safe-array type and then demonstrates its use
by creating an array of
ints and an array ofdoubles. You should try creating other
types of arrays. As this example shows, part of the power of generic classes is that they478C++:TheCompleteReference
Chapter18:Templates
479C++allow you to write the code once, debug it, and then apply it to any type of datawithout having to re-engineer it for each specific application.
Using Non-Type Arguments with Generic Classes
Inthetemplatespecificationforagenericclass,youmayalsospecifynon-type

arguments.Thatis,inatemplatespecificationyoucanspecifywhatyouwould

normally think of as a standard argument, such as an integer or a pointer. The syntax

to accomplish this is essentially the same as for normal function parameters: simply
includethetypeandnameoftheargument.Forexample,hereisabetterwayto

implementthesafe-arrayclasspresentedintheprecedingsection.Itallowsyou

tospecifythesizeofthearray.
// Demonstrate non-type template arguments.#include <iostream>
#include <cstdlib>
using namespace std;// Here, int size is a non-type argument.template <class AType, int size> class atype {AType a[size]; // length of array is passed in sizepublic:atype() {register int i;
for(i=0; i<size; i++) a[i] = i;}
AType &operator[](int i);};// Provide range checking for atype.template <class AType, int size>
AType &atype<AType, size>::operator[](int i)
{if(i<0 || i> size-1) {cout << "\nIndex value of ";
cout << i << " is out-of-bounds.\n";
exit(1);}
return a[i];}int main(){atype<int, 10> intob;       // integer array of size 10atype<double, 15> doubleob; // double array of size 15int i;
cout << "Integer array: ";for(i=0; i<10; i++) intob[i] = i;
for(i=0; i<10; i++) cout << intob[i] << "  ";
cout << '\n';cout << "Double array: ";for(i=0; i<15; i++) doubleob[i] = (double) i/3;
for(i=0; i<15; i++) cout << doubleob[i] << "  ";
cout << '\n';intob[12] = 100; // generates runtime error
return 0;}Look carefully at the template specification for
atype. Note thatsizeis declared as
anint. This parameter is then used withinatypeto declare the size of the array
a. Eventhoughsizeis depicted as a "variable" in the source code, its value is known at compile
time. This allows it to be used to set the size of the array.
sizeis also used in the boundschecking within theoperator[ ]( )function. Within
main( ), notice how the integer andfloating-point arrays are created. The second parameter specifies the size of each array.
Non-type parameters are restricted to integers, pointers, or references. Other types,
such asfloat, are not allowed. The arguments that you pass to a non-type parameter
must consist of either an integer constant, or a pointer or reference to a global function
or object. Thus, non-type parameters should themselves be thought of as constants,
since their values cannot be changed. For example, insideoperator[ ]( ), the followingstatement is not allowed.size = 10; // ErrorSince non-type parameters are treated as constants, they can be used to set the

dimension of an array, which is a significant, practical benefit.
As the safe-array example illustrates, the use of non-type parameters greatly
expands the utility of template classes. Although the information contained in the
non-type argument must be known at compile-time, this restriction is mild compared

with the power offered by non-type parameters.
480C++:TheCompleteReference
C++Chapter18:Templates
481Using Default Arguments with Template Classes
Atemplate class can have a default argument associated with a generic type.
For example,template <class X=int> class myclass { //...Here, the type
intwill be used if no other type is specified when an object of typemyclassis instantiated.It is also permissible for non-type arguments to take default arguments. The default
value is used when no explicit value is specified when the class is instantiated. Default
arguments for non-type parameters are specified using the same syntax as default

arguments for function parameters.
Here is another version of the safe-array class that uses default arguments for both
the type of data and the size of the array.
// Demonstrate default template arguments.#include <iostream>
#include <cstdlib>
using namespace std;// Here, AType defaults to int and size defaults to 10.template <class AType=int, int size=10> class atype {AType a[size]; // size of array is passed in sizepublic:atype() {register int i;
for(i=0; i<size; i++) a[i] = i;}
AType &operator[](int i);};// Provide range checking for atype.template <class AType, int size>
AType &atype<AType, size>::operator[](int i)
{if(i<0 || i> size-1) {cout << "\nIndex value of ";
cout << i << " is out-of-bounds.\n";
exit(1);}return a[i];}int main(){atype<int, 100> intarray;  // integer array, size 100atype<double> doublearray; // double array, default size
atype<> defarray;          // default to int array of size 10int i;
cout << "int array: ";for(i=0; i<100; i++) intarray[i] = i;
for(i=0; i<100; i++) cout << intarray[i] << "  ";
cout << '\n';cout << "double array: ";for(i=0; i<10; i++) doublearray[i] = (double) i/3;
for(i=0; i<10; i++) cout << doublearray[i] << "  ";
cout << '\n';cout << "defarray array: ";for(i=0; i<10; i++) defarray[i] = i;
for(i=0; i<10; i++) cout << defarray[i] << "  ";
cout << '\n';return 0;}Pay close attention to this line:template <class AType=int, int size=10> class atype {Here,
AType
defaults to typeint, andsizedefaults to10. As the program illustrates,
atypeobjects can be created three ways:
explicitly specifying both the type and size of the arrayexplicitly specifying the type, but letting the size default to 10letting the type default tointand the size default to 10482C++:TheCompleteReference
Chapter18:Templates
483C++The use of default arguments—especially default types—adds versatility to your
template classes. You can provide a default for the type of data most commonly

used while still allowing the user of your classes to specialize them as needed.Explicit Class SpecializationsAs with template functions, you can create an explicit specialization of a generic class.

To do so, use the
template<>construct, which works the same as it does for explicit
function specializations. For example:// Demonstrate class specialization.#include <iostream>
using namespace std;template <class T> class myclass {T x;public:myclass(T a) {cout << "Inside generic myclass\n";x = a;}
T getx() { return x; }};// Explicit specialization for int.template <> class myclass<int> {int x;public:myclass(int a) {cout << "Inside myclass<int> specialization\n";
x = a * a;}
int getx() { return x; }};int main(){myclass<double> d(10.1);
cout << "double: " << d.getx() << "\n\n";myclass<int> i(5);484C++:TheCompleteReference
cout << "int: " << i.getx() << "\n";return 0;}This program displays the following output:
Inside generic myclassdouble: 10.1Inside myclass<int> specializationint: 25In the program, pay close attention to this line:
template <> class myclass<int> {It tells the compiler that an explicit integer specialization ofmyclassis being created.
This same general syntax is used for any type of class specialization.Explicit class specialization expands the utility of generic classes because it lets youeasily handle one or two special cases while allowing all others to be automaticallyprocessed by the compiler. Of course, if you find that you are creating too many

specializations, you are probably better off not using a template class in the first place.
The typename and export Keywords
Recently, two keywords were added to C++ that relate specifically to templates:

typenameandexport. Both play specialized roles in C++ programming. Each is
briefly examined.Thetypenamekeyword has two uses. First, as mentioned earlier, it can be
substituted for the keyword
classin a template declaration. For example, theswapargs( )template function could be specified like this:template <typename X> void swapargs(X &a, X &b){X temp;temp = a;a = b;b = temp;}Here,
typenamespecifies the generic typeX. There is no difference between using
classand usingtypenamein this context.Theseconduseof
typenameistoinformthecompilerthatanameusedinatemplate
declaration is a type name rather than an object name. For example,typename X::Name someObject;ensures that
X::Nameis treated as a type name.
Theexportkeyword can precede a
templatedeclaration. It allows other files to usea template declared in a different file by specifying only its declaration rather than
duplicating its entire definition.
The Power of Templates
Templates help you achieve one of the most elusive goals in programming: the creation

of reusable code. Through the use of template classes you can create frameworks that

canbeappliedoverandoveragaintoavarietyofprogrammingsituations.Forexample,

consider thestackclass. When first shown in Chapter 11, it could only be used to store
integer values. Even though the underlying algorithms could be used to store any type

ofdata,thehard-codingofthedatatypeintothe
stackclassseverelylimitedits
application. However, by making
stackinto a generic class, it can create a stack for any
type of data.Generic functions and classes provide a powerful tool that you can use to amplify
yourprogrammingefforts.Onceyouhavewrittenanddebuggedatemplateclass,

you have a solid software component that you can use with confidence in a variety of

differentsituations.Youaresavedfromthetediumofcreatingseparateimplementations

for each data type with which you want the class to work.While it is true that the template syntax can seem a bit intimidating at first, the
rewardsarewellworththetimeittakestobecomecomfortablewithit.Template

functions and classes are already becoming commonplace in programming, and this

trendisexpectedtocontinue.Forexample,theSTL(StandardTemplateLibrary)

defined by C++ is, as its name implies, built upon templates. One last point: although
templates add a layer of abstraction, they still ultimately compile down to the same,
high-performance object code that you have come to expect from C++.
Chapter18:Templates
485C++This page intentionally left blank Chapter19
Exception Handling487Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
488C++:TheCompleteReference
This chapter discusses the exception handling subsystem.Exceptionhandling
allowsyou to manage run-time errors in an orderly fashion. Using exception handling,your program can automatically invoke an error-handling routine when an erroroccurs. The principal advantage of exception handling is that it automates much of the
error-handling code that previously had to be coded "by hand" in any large program.Exception Handling FundamentalsC++ exception handling is built upon three keywords:
try,catch, andthrow. In themostgeneralterms,programstatementsthatyouwanttomonitorforexceptions

are contained in a
tryblock. If an exception (i.e., an error) occurs within the
tryblock,it is thrown (using
throw). The exception is caught, usingcatch, and processed. The
following discussion elaborates upon this general description.Codethatyouwanttomonitorforexceptionsmusthavebeenexecutedfrom
withina
tryblock.(Functionscalledfromwithina
tryblockmayalsothrowan
exception.) Exceptions that can be thrown by the monitored code are caught by a

catchstatement, which immediately follows thetrystatement in which the exceptionwas thrown. The general form of
tryandcatchare shown here.
try {//try block}
catch (type1arg
) {//catch block}
catch (type2arg
) {//catch block}
catch (type3arg
) {//catch block}
.
.
.
catch (typeNarg
) {//catch block}Thetrycan be as short as a few statements within one function or as all-encompassing as enclosing themain( )function code within atryblock (whicheffectively causes the entire program to be monitored).
When an exception is thrown, it is caught by its corresponding
catchstatement,which processes the exception. There can be more than one
catchstatement associatedwith atry. Whichcatchstatement is used is determined by the type of the exception.That is, if the data type specified by acatchmatches that of the exception, then thatcatchstatement is executed (and all others are bypassed). When an exception is caught,
arg
will receive its value. Any type of data may be caught, including classes that you
create. If no exception is thrown (that is, no error occurs within the
tryblock), then nocatchstatement is executed.The general form of thethrowstatement is shown here:
throwexception;throwgenerates the exception specified byexception. If this exception is to be caught,thenthrowmust be executed either from within a
tryblock itself, or from any function
called from within the
tryblock (directly or indirectly).
If you throw an exception for which there is no applicable
catchstatement, anabnormal program termination may occur. Throwing an unhandled exception causes
the standard library function
terminate( )to be invoked. By default,terminate( )callsabort( )to stop your program, but you can specify your own termination handler, as
described later in this chapter.
Here is a simple example that shows the way C++ exception handling operates.
// A simple exception handling example.#include <iostream>
using namespace std;int main(){cout << "Start\n";try { // start a try blockcout << "Inside try block\n";throw 100; // throw an error
cout << "This will not execute";}
catch (int i) { // catch an errorcout << "Caught an exception -- value is: ";
cout << i << "\n";}cout << "End";Chapter19:ExceptionHandling
489C++return 0;}This program displays the following output:
StartInside try block
Caught an exception -- value is: 100
EndLook carefully at this program. As you can see, there is a
tryblock containing three
statementsanda
catch(inti)
statementthatprocessesanintegerexception.Withinthe
tryblock,onlytwoofthethreestatementswillexecute:thefirst
coutstatementandthe
throw.Onceanexceptionhasbeenthrown,controlpassestothe
catchexpressionandthe
tryblockisterminated.Thatis,
catchisnotcalled.Rather,programexecutionistransferredtoit.(The
program'sstackisautomaticallyresetasneededtoaccomplishthis.)Thus,the
coutstatementfollowingthe
throwwillneverexecute.
Usually, the code within a
catchstatement attempts to remedy an error by taking
appropriate action. If the error can be fixed, execution will continue with the statements
following thecatch. However, often an error cannot be fixed and a
catchblock willterminate the program with a call to
exit( )orabort( ).As mentioned, the type of the exception must match the type specified in acatchstatement.Forexample,intheprecedingexample,ifyouchangethetypeinthe

catchstatement todouble, the exception will not be caught and abnormal terminationwill occur. This change is shown here.
// This example will not work.#include <iostream>
using namespace std;int main(){cout << "Start\n";try { // start a try blockcout << "Inside try block\n";throw 100; // throw an error
cout << "This will not execute";}
catch (double i) { // won't work for an int exceptioncout << "Caught an exception -- value is: ";490C++:TheCompleteReference
Chapter19:ExceptionHandling
491C++cout << i << "\n";}cout << "End";
return 0;}This program produces the following output because the integer exception will not be
caughtbythe
catch(doublei)
statement.(Ofcourse,theprecisemessagedescribing
abnormalterminationwillvaryfromcompilertocompiler.)
StartInside try block
Abnormal program terminationAn exception can be thrown from outside the
tryblock as long as it is thrown by
a function that is called from within
tryblock. For example, this is a valid program.
/* Throwing an exception from a function outside thetry block.*/
#include <iostream>
using namespace std;void Xtest(int test){cout << "Inside Xtest, test is: " << test << "\n";
if(test) throw test;}int main(){cout << "Start\n";try { // start a try blockcout << "Inside try block\n";Xtest(0);
Xtest(1);
Xtest(2);}
catch (int i) { // catch an errorcout << "Caught an exception -- value is: ";cout << i << "\n";}cout << "End";
return 0;}This program produces the following output:
StartInside try block
Inside Xtest, test is: 0
Inside Xtest, test is: 1
Caught an exception -- value is: 1
EndAtryblock can be localized to a function. When this is the case, each time thefunction is entered, the exception handling relative to that function is reset. For
example, examine this program.
#include <iostream>using namespace std;// Localize a try/catch to a function.void Xhandler(int test)
{try{if(test) throw test;}
catch(int i) {cout << "Caught Exception #: " << i << '\n';}}int main(){cout << "Start\n";Xhandler(1);492C++:TheCompleteReference
Xhandler(2);Xhandler(0);
Xhandler(3);cout << "End";
return 0;}This program displays this output:
StartCaught Exception #: 1
Caught Exception #: 2
Caught Exception #: 3
EndAs you can see, three exceptions are thrown. After each exception, the function returns.
When the function is called again, the exception handling is reset.
It is important to understand that the code associated with acatchstatement willbe executed only if it catches an exception. Otherwise, execution simply bypasses the
catchaltogether. (That is, execution never flows into a
catchstatement.) For example,inthefollowingprogram,noexceptionisthrown,sothe
catchstatementdoesnotexecute.
#include <iostream>using namespace std;int main(){cout << "Start\n";try { // start a try blockcout << "Inside try block\n";cout << "Still inside try block\n";}
catch (int i) { // catch an errorcout << "Caught an exception -- value is: ";
cout << i << "\n";}Chapter19:ExceptionHandling
493C++cout << "End";return 0;}The preceding program produces the following output.
StartInside try block
Still inside try block
EndAs you see, thecatchstatement is bypassed by the flow of execution.Catching Class Types
An exception can be of any type, including class types that you create. Actually, in
real-world programs, most exceptions will be class types rather than built-in types.

Perhaps the most common reason that you will want to define a class type for an

exception is to create an object that describes the error that occurred. This information

can be used by the exception handler to help it process the error. The following

example demonstrates this.// Catching class type exceptions.#include <iostream>
#include <cstring>
using namespace std;class MyException {public:char str_what[80];
int what;MyException() { *str_what = 0; what = 0; }
MyException(char *s, int e) {strcpy(str_what, s);what = e;}};494C++:TheCompleteReference
Chapter19:ExceptionHandling
495C++int main(){int i;try {cout << "Enter a positive number: ";cin >> i;
if(i<0)throw MyException("Not Positive", i);}catch (MyException e) { // catch an errorcout << e.str_what << ": ";
cout << e.what << "\n";}return 0;}Here is a sample run:
Enter a positive number: -4Not Positive: -4Theprogrampromptstheuserforapositivenumber.Ifanegativenumberisentered,an
objectoftheclass
MyExceptioniscreatedthatdescribestheerror.Thus,
MyExceptionencapsulatesinformationabouttheerror.Thisinformationisthenusedbytheexception

handler.Ingeneral,youwillwanttocreateexceptionclassesthatwillencapsulate

informationaboutanerrortoenabletheexceptionhandlertorespondeffectively.
Using Multiple catch StatementsAs stated, you can have more than one
catchassociated with atry. In fact, it is commonto do so. However, each
catchmust catch a different type of exception. For example,
this program catches both integers and strings.
#include <iostream>using namespace std;// Different types of exceptions can be caught.void Xhandler(int test){try{if(test) throw test;else throw "Value is zero";}catch(int i) {cout << "Caught Exception #: " << i << '\n';}catch(const char *str) {cout << "Caught a string: ";
cout << str << '\n';}}int main(){cout << "Start\n";Xhandler(1);Xhandler(2);
Xhandler(0);
Xhandler(3);cout << "End";
return 0;}This program produces the following output:
StartCaught Exception #: 1
Caught Exception #: 2
Caught a string: Value is zero
Caught Exception #: 3
EndAs you can see, eachcatchstatement responds only to its own type.
In general,catchexpressions are checked in the order in which they occur in a
program. Only a matching statement is executed. All other
catchblocks are ignored.
496C++:TheCompleteReference
Handling Derived-Class ExceptionsYou need to be careful how you order your
catchstatements when trying to catchexception types that involve base and derived classes because acatchclause for abaseclasswillalsomatchanyclassderivedfromthatbase.Thus,ifyouwantto
catch exceptions of both a base class type and a derived class type, put the derived
class first in thecatchsequence. If you don't do this, the base classcatchwill alsocatch all derived classes. For example, consider the following program.
// Catching derived classes.#include <iostream>
using namespace std;class B {};class D: public B {};int main(){D derived;try {throw derived;}catch(B b) {cout << "Caught a base class.\n";}
catch(D d) {cout << "This won't execute.\n";}return 0;}Here, because
derivedis an object that hasBas a base class, it will be caught by thefirstcatchclause and the second clause will never execute. Some compilers will flagthis condition with a warning message. Others may issue an error. Either way, to
fix this condition, reverse the order of the
catchclauses.Chapter19:ExceptionHandling
497C++498C++:TheCompleteReference
Exception Handling OptionsThere are several additional features and nuances to C++ exception handling that make
it easier and more convenient to use. These attributes are discussed here.
Catching All ExceptionsIn some circumstances you will want an exception handler to catch all exceptions

instead of just a certain type. This is easy to accomplish. Simply use this form ofcatch.catch(...) {//process all exceptions}Here, the ellipsis matches any type of data. The following program illustrates
catch(...).// This example catches all exceptions.#include <iostream>
using namespace std;void Xhandler(int test){try{if(test==0) throw test; // throw int
if(test==1) throw 'a'; // throw char
if(test==2) throw 123.23; // throw double}
catch(...) { // catch all exceptionscout << "Caught One!\n";}}int main(){cout << "Start\n";Xhandler(0);Xhandler(1);
Xhandler(2);cout << "End";return 0;}This program displays the following output.
StartCaught One!
Caught One!
Caught One!
EndAs you can see, all three
throws were caught using the one
catchstatement.One very good use forcatch(...)is as the lastcatchof a cluster of catches. In thiscapacity it provides a useful default or "catch all" statement. For example, this slightly
different version of the preceding program explicity catches integer exceptions but

relies upon
catch(...)to catch all others.// This example uses catch(...) as a default.#include <iostream>
using namespace std;void Xhandler(int test){try{if(test==0) throw test; // throw int
if(test==1) throw 'a'; // throw char
if(test==2) throw 123.23; // throw double}
catch(int i) { // catch an int exceptioncout << "Caught an integer\n";}
catch(...) { // catch all other exceptionscout << "Caught One!\n";}}int main(){cout << "Start\n";Chapter19:ExceptionHandling
499C++Xhandler(0);Xhandler(1);
Xhandler(2);cout << "End";
return 0;}The output produced by this program is shown here.
StartCaught an integer
Caught One!
Caught One!
EndAs this example suggests, usingcatch(...)as a default is a good way to catch allexceptions that you don't want to handle explicitly. Also, by catching all exceptions,
you prevent an unhandled exception from causing an abnormal program termination.
Restricting ExceptionsYoucanrestrictthetypeofexceptionsthatafunctioncanthrowoutsideofitself.In

fact,youcanalsopreventafunctionfromthrowinganyexceptionswhatsoever.To

accomplishtheserestrictions,youmustadda
throwclausetoafunctiondefinition.
Thegeneralformofthisisshownhere:
ret-type func-name(arg-list) throw(type-list)
{// ...}Here, only those data types contained in the comma-separated
type-listmay be thrown
by the function. Throwing any other type of expression will cause abnormal program

termination. If you don't want a function to be able to throw
anyexceptions, then usean empty list.Attempting to throw an exception that is not supported by a function will cause the
standard library function
unexpected( )to be called. By default, this causesabort( )tobe called, which causes abnormal program termination. However, you can specify your

own unexpected handler if you like, as described later in this chapter.
500C++:TheCompleteReference
The following program shows how to restrict the types of exceptions that can be
thrown from a function.
// Restricting function throw types.#include <iostream>
using namespace std;// This function can only throw ints, chars, and doubles.void Xhandler(int test) throw(int, char, double)
{if(test==0) throw test; // throw int
if(test==1) throw 'a'; // throw char
if(test==2) throw 123.23; // throw double}int main(){cout << "start\n";try{Xhandler(0); // also, try passing 1 and 2 to Xhandler()}catch(int i) {cout << "Caught an integer\n";}
catch(char c) {cout << "Caught char\n";}
catch(double d) {cout << "Caught double\n";}cout << "end";
return 0;}In this program, the function
Xhandler( )may only throw integer, character, and
doubleexceptions. If it attempts to throw any other type of exception, an abnormal
program termination will occur. (That is,
unexpected( )will be called.) To see an
example of this, remove
intfrom the list and retry the program.
It is important to understand that a function can be restricted only in what types
of exceptions it throws back to the
tryblock that called it. That is, atryblockwithinaChapter19:ExceptionHandling
501C++502C++:TheCompleteReference
function may throw any type of exception so long as it is caught
withinthat function.The restriction applies only when throwing an exception outside of the function.
The following change toXhandler( )prevents it from throwing any exceptions.
// This function can throw NO exceptions!void Xhandler(int test) throw()
{/* The following statements no longer work.  Instead,they will cause an abnormal program termination. */if(test==0) throw test;
if(test==1) throw 'a';
if(test==2) throw 123.23;}Rethrowing an Exception
If you wish to rethrow an expression from within an exception handler, you may do so
by callingthrow, by itself, with no exception. This causes the current exception to be
passed on to an outertry/catchsequence. The most likely reason for doing so is to
allow multiple handlers access to the exception. For example, perhaps one exception

handler manages one aspect of an exception and a second handler copes with another.

An exception can only be rethrown from within a
catchblock (or from any function
called from within that block). When you rethrow an exception, it will not be recaught

by the samecatchstatement. It will propagate outward to the next
catchstatement. Thefollowing program illustrates rethrowing an exception, in this case a
char *exception.// Example of "rethrowing" an exception.#include <iostream>
using namespace std;void Xhandler(){try {throw "hello"; // throw a char *}
catch(const char *) { // catch a char *cout << "Caught char * inside Xhandler\n";
throw ; // rethrow char * out of function}}Chapter19:ExceptionHandling
503C++int main(){cout << "Start\n";try{Xhandler();}catch(const char *) {cout << "Caught char * inside main\n";}cout << "End";
return 0;}This program displays this output:
StartCaught char * inside Xhandler
Caught char * inside main
EndUnderstanding terminate( ) and unexpected( )
As mentioned earlier,
terminate( )andunexpected( )are called when something goes
wrong during the exception handling process. These functions are supplied by the
Standard C++ library. Their prototypes are shown here:
void terminate( );
void unexpected( );These functions require the header
<exception>.Theterminate( )function is called whenever the exception handling subsystem failsto find a matchingcatchstatement for an exception. It is also called if your program
attemptstorethrowanexceptionwhennoexceptionwasoriginallythrown.The

terminate( )function is also called under various other, more obscure circumstances.
For example, such a circumstance could occur when, in the process of unwinding the

stack because of an exception, a destructor for an object being destroyed throws an

exception. In general,terminate( )is the handler of last resort when no other handlers
for an exception are available. By default,
terminate( )callsabort( ).504C++:TheCompleteReference
Theunexpected()
functioniscalledwhenafunctionattemptstothrowanexception
thatisnotallowedbyits
throwlist.Bydefault,
unexpected()
callsterminate()
.Setting the Terminate and Unexpected Handlers
Theterminate()
andunexpected()
functionssimplycallotherfunctionstoactuallyhandle
anerror.Asjustexplained,bydefault
terminate()
callsabort()
,and
unexpected()
callsterminate()
.Thus,bydefault,bothfunctionshaltprogramexecutionwhenanexception
handlingerroroccurs.However,youcanchangethefunctionsthatarecalledby
terminate()
andunexpected()
.Doingsoallowsyourprogramtotakefullcontrolofthe
exceptionhandlingsubsystem.
To change the terminate handler, use
set_terminate( ), shown here:
terminate_handler set_terminate(terminate_handlernewhandler) throw( );Here,
newhandleris a pointer to the new terminate handler. The function returns a
pointer to the old terminate handler. The new terminate handler must be of type

terminate_handler, which is defined like this:typedef void (*terminate_handler) ( );The only thing that your terminate handler must do is stop program execution. It must

not return to the program or resume it in any way.
To change the unexpected handler, use
set_unexpected( ), shown here:
unexpected_handler set_unexpected(unexpected_handlernewhandler) throw( );Here,
newhandleris a pointer to the new unexpected handler. The function returns a
pointer to the old unexpected handler. The new unexpected handler must be of type

unexpected_handler, which is defined like this:typedef void (*unexpected_handler) ( );This handler may itself throw an exception, stop the program, or call
terminate( ).However, it must not return to the program.
Bothset_terminate( )andset_unexpected( )require the header
<exception>.Here is an example that defines its own
terminate( )handler.
// Set a new terminate handler.#include <iostream>#include <cstdlib>#include <exception>
using namespace std;void my_Thandler() {cout << "Inside new terminate handler\n";abort();}int main(){// set a new terminate handler
set_terminate(my_Thandler);try {cout << "Inside try block\n";throw 100; // throw an error}
catch (double i) { // won't catch an int exception// ...}return 0;}The output from this program is shown here.
Inside try blockInside new terminate handler
abnormal program terminationThe uncaught_exception( ) FunctionThe C++ exception handling subsystem supplies one other function that you may finduseful:uncaught_exception( ). Its prototype is shown here:
bool uncaught_exception( );This function returns
trueif an exception has been thrown but not yet caught. Once
caught, the function returns
false.Chapter19:ExceptionHandling
505C++The exception and bad_exception ClassesWhen a function supplied by the C++ standard library throws an exception, it will be
an object derived from the base class
exception. An object of the classbad_exceptioncanbethrownbytheunexpectedhandler.Theseclassesrequiretheheader
<exception>.Applying Exception HandlingException handling is designed to provide a structured means by which your program

can handle abnormal events. This implies that the error handler must do something

rational when an error occurs. For example, consider the following simple program. It

inputs two numbers and divides the first by the second. It uses exception handling to
manage a divide-by-zero error.
#include <iostream>using namespace std;void divide(double a, double b);
int main(){double i, j;do {cout << "Enter numerator (0 to stop): ";cin >> i;
cout << "Enter denominator: ";
cin >> j;
divide(i, j);} while(i != 0);return 0;}
void divide(double a, double b){try {if(!b) throw b; // check for divide-by-zero
cout << "Result: " << a/b << endl;}
catch (double b) {cout << "Can't divide by zero.\n";506C++:TheCompleteReference
}}While the preceding program is a very simple example, it does illustrate the essential
nature of exception handling. Since division by zero is illegal, the program cannot

continue if a zero is entered for the second number. In this case, the exception is

handled by not performing the division (which would have caused abnormal program

termination) and notifying the user of the error. The program then reprompts the user

for two more numbers. Thus, the error has been handled in an orderly fashion and the

user may continue on with the program. The same basic concepts will apply to more

complex applications of exception handling.Exceptionhandlingisespeciallyusefulforexitingfromadeeplynestedsetof
routines when a catastrophic error occurs. In this regard, C++'s exception handling

is designed to replace the rather clumsy C-based
setjmp( )andlongjmp( )functions.Remember, the key point about using exception handling is to provide an orderly
way of handling errors. This means rectifying the situation, if possible.
Chapter19:ExceptionHandling
507C++This page intentionally left blank Chapter20
The C++ I/OSystem Basics509Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
C++ supports two complete I/O systems: the one inherited from C and the object-orientedI/OsystemdefinedbyC++(hereaftercalledsimplytheC++I/Osystem).

TheC-basedI/OsystemwasdiscussedinPartOne.Herewewillbegintoexamine
theC++I/Osystem.LikeC-basedI/O,C++'sI/Osystemisfullyintegrated.Thedifferent

aspectsofC++'sI/Osystem,suchasconsoleI/OanddiskI/O,areactuallyjust

different perspectives on the same mechanism. This chapter discusses the foundations
of the C++ I/O system. Although the examples in this chapter use "console" I/O, the
informationisapplicabletootherdevices,includingdiskfiles(discussedinChapter

21).Since the I/O system inherited from C is extremely rich, flexible, and powerful, you
might be wondering why C++ defines yet another system. The answer is that C's I/O
system knows nothing about objects. Therefore, for C++ to provide complete support

for object-oriented programming, it was necessary to create an I/O system that could

operateonuser-definedobjects.Inadditiontosupportforobjects,thereareseveral

benefitstousingC++'sI/Osystemeveninprogramsthatdon'tmakeextensive(or

any) use of user-defined objects. Frankly, for all new code, you should use the C++ I/O

system. The C I/O is supported by C++ only for compatibility.
This chapter explains how to format data, how to overload the<<and>>I/Ooperators so they can be used with classes that you create, and how to create special

I/O functions called manipulators that can make your programs more efficient.
Old vs. Modern C++ I/O
TherearecurrentlytwoversionsoftheC++object-orientedI/Olibraryinuse:theolder

one that is based upon the original specifications for C++ and the newer one defined
byStandardC++.TheoldI/Olibraryissupportedbytheheaderfile
<iostream.h>.The new I/O library is supported by the header<iostream>. For the most part the twolibraries appear the same to the programmer. This is because the new I/O library is, in

essence,simplyanupdatedandimprovedversionoftheoldone.Infact,thevastmajority

of differences between the two occur beneath the surface, in the way that the libraries

are implemented—not in how they are used.
From the programmer's perspective, there are two main differences between the
old and new C++ I/O libraries. First, the new I/O library contains a few additional
features and defines some new data types. Thus, the new I/O library is essentially

a superset of the old one. Nearly all programs originally written for the old library

will compile without substantive changes when the new library is used. Second, the
old-style I/O library was in the global namespace. The new-style library is in thestdnamespace. (Recall that thestdnamespace is used by all of the Standard C++ libraries.)
Since the old-style I/O library is now obsolete, this book describes only the new I/O
library, but most of the information is applicable to the old I/O library as well.
510C++:TheCompleteReference
Chapter20:TheC++I/OSystemBasics
511C++C++ Streams
Like the C-based I/O system, the C++ I/O system operates through streams. Streams
werediscussedindetailinChapter9;thatdiscussionwillnotberepeatedhere.However,

tosummarize:A
stream
isalogicaldevicethateitherproducesorconsumesinformation.
AstreamislinkedtoaphysicaldevicebytheI/Osystem.Allstreamsbehaveinthe

samewayeventhoughtheactualphysicaldevicestheyareconnectedtomaydiffer

substantially. Because all streams behave the same, the same I/O functions can operate

on virtually any type of physical device. For example, you can use the same function
thatwritestoafiletowritetotheprinterortothescreen.Theadvantagetothisapproach

is that you need learn only one I/O system.The C++ Stream Classes
As mentioned, Standard C++ provides support for its I/O system in
<iostream>. Inthis header, a rather complicated set of class hierarchies is defined that supports I/O

operations. The I/O classes begin with a system of template classes. As explained in
Chapter 18, a template class defines the form of a class without fully specifying the
datauponwhichitwilloperate.Onceatemplateclasshasbeendefined,specific

instances of it can be created. As it relates to the I/O library, Standard C++ creates

two specializations of the I/O template classes: one for 8-bit characters and another
for wide characters. This book will use only the 8-bit character classes since they are

by far the most common. But the same techniques apply to both.TheC++I/Osystemisbuiltupontworelatedbutdifferenttemplateclasshierarchies.
Thefirstisderivedfromthelow-levelI/Oclasscalled
basic_streambuf.Thisclass
suppliesthe basic, low-level input and output operations, and provides the underlying
support for the entire C++ I/O system. Unless you are doing advanced I/O

programming, you will not need to use
basic_streambufdirectly. The class hierarchy
that you will most commonly be working with is derived from
basic_ios. This is ahigh-level I/O class that provides formatting, error checking, and status information

related to stream I/O. (Abase class for
basic_iosis calledios_base, which definesseveral nontemplate traits used bybasic_ios.)basic_iosis used as a base for severalderived classes, includingbasic_istream,basic_ostream, andbasic_iostream. Theseclasses are used to create streams capable of input, output, and input/output,

respectively.
As explained, the I/O library creates two specializations of the template class
hierarchies just described: one for 8-bit characters and one for wide characters. Here

is a list of the mapping of template class names to their character and wide-character
versions.Template Class
Character-based ClassWide-Character-

based Classbasic_streambufstreambufwstreambuf
basic_iosioswios

basic_istreamistreamwistream

basic_ostreamostreamwostream

basic_iostreamiostreamwiostream

basic_fstreamfstreamwfstream

basic_ifstreamifstreamwifstream

basic_ofstreamofstreamwofstream
The character-based names will be used throughout the remainder of this book,
since they are the names that you will normally use in your programs. They are also
the same names that were used by the old I/O library. This is why the old and the new

I/O library are compatible at the source code level.
One last point: Theiosclass contains many member functions and variables thatcontrolormonitorthefundamentaloperationofastream.Itwillbereferredtofrequently.

Just remember that if you include
<iostream>in your program, you will have access to
this important class.C++'s Predefined Streams
When a C++ program begins execution, four built-in streams are automatically opened.

They are:
StreamMeaning
Default DevicecinStandard input
Keyboard
coutStandard output
Screen
cerrStandard error outputScreen
clogBuffered version of cerrScreen
Streams
cin,cout, andcerrcorrespond to C's
stdin,stdout, andstderr.By default, the standard streams are used to communicate with the console.
However, in environments that support I/O redirection (such as DOS, Unix, OS/2,

and Windows), the standard streams can be redirected to other devices or files. For

the sake of simplicity, the examples in this chapter assume that no I/O redirection

has occurred.
512C++:TheCompleteReference
Standard C++ also defines these four additional streams:
win,wout,werr, andwlog. These are wide-character versions of the standard streams. Wide characters are
of typewchar_tand are generally 16-bit quantities. Wide characters are used to hold
the large character sets associated with some human languages.
Formatted I/O
The C++ I/O system allows you to format I/O operations. For example, you can set
a field width, specify a number base, or determine how many digits after the decimal
pointwillbedisplayed.Therearetworelatedbutconceptuallydifferentwaysthatyou

can format data. First, you can directly access members of the
iosclass. Specifically,
you can set various format status flags defined inside theiosclass or call variousiosmember functions. Second, you can use special functions calledmanipulatorsthat canbe included as part of an I/O expression.
We will begin the discussion of formatted I/O by using the
iosmember functionsand flags.Formatting Using the ios Members
Each stream has associated with it a set of format flags that control the way information

is formatted. Theiosclass declares a bitmask enumeration called
fmtflagsin which thefollowing values are defined. (Technically, these values are defined within
ios_base,which, as explained earlier, is a base class for
ios.)adjustfieldbasefield
boolalphadec
fixedfloatfieldhexinternalleftoctrightscientificshowbaseshowpointshowpos
skipwsunitbufuppercase
Thesevaluesareusedtosetorcleartheformatflags.Ifyouareusinganoldercompiler,

it may not define thefmtflagsenumeration type. In this case, the format flags will beencoded into a long integer.
When theskipwsflag is set, leading white-space characters (spaces, tabs, andnewlines) are discarded when performing input on a stream. When
skipwsis cleared,
white-space characters are not discarded.
When theleftflag is set, output is left justified. Whenrightis set, output is rightjustified.Whenthe
internalflagisset,anumericvalueispaddedtofillafieldbyinserting
spaces between any sign or base character. If none of these flags are set, output is right

justified by default.Chapter20:TheC++I/OSystemBasics
513C++514C++:TheCompleteReference
By default, numeric values are output in decimal. However, it is possible to change
the number base. Setting theoctflag causes output to be displayed in octal. Setting thehexflag causes output to be displayed in hexadecimal. To return output to decimal, set
thedecflag.Settingshowbasecauses the base of numeric values to be shown. For example, ifthe conversion base is hexadecimal, the value 1F will be displayed as 0x1F.
By default, when scientific notation is displayed, theeis in lowercase. Also, when
a hexadecimal value is displayed, thexis in lowercase. When
uppercaseis set, thesecharacters are displayed in uppercase.
Settingshowposcauses a leading plus sign to be displayed before positive values.
Settingshowpointcauses a decimal point and trailing zeros to be displayed for all
floating-point output—whether needed or not.By setting thescientificflag, floating-point numeric values are displayed using
scientific notation. Whenfixedis set, floating-point values are displayed using normal
notation. When neither flag is set, the compiler chooses an appropriate method.
Whenunitbufis set, the buffer is flushed after each insertion operation.
Whenboolalphais set, Booleans can be input or output using the keywords
trueandfalse.Sinceitiscommontorefertothe
oct,dec,and
hexfields,theycanbecollectively
referred to as
basefield. Similarly, the
left,right, andinternalfields can be referred to
asadjustfield. Finally, the
scientificandfixedfields can be referenced as
floatfield.Setting the Format Flags
To set a flag, use the
setf( )function. This function is a member ofios. Its most commonform is shown here:
fmtflags setf(fmtflagsflags);This function returns the previous settings of the format flags and turns on those flags
specified byflags. For example, to turn on theshowposflag, you can use this statement:stream.setf(ios::showpos);Here,
stream
is the stream you wish to affect. Notice the use of
ios::to qualifyshowpos.Sinceshowposis an enumerated constant defined by theiosclass, it must be qualifiedbyioswhen it is used.The following program displays the value 100 with the
showposandshowpointflags turned on.Chapter20:TheC++I/OSystemBasics
515C++#include <iostream>using namespace std;int main(){cout.setf(ios::showpoint);cout.setf(ios::showpos);cout << 100.0; // displays +100.000
return 0;}It is important to understand thatsetf( )is a member function of theiosclass andaffects streams created by that class. Therefore, any call to
setf( )is done relative to a
specific stream. There is no concept of calling
setf( )by itself. Put differently, there is
no concept in C++ of global format status. Each stream maintains its own format status
information individually.
Although there is nothing technically wrong with the preceding program, there
is a more efficient way to write it. Instead of making multiple calls to
setf( ), you cansimply OR together the values of the flags you want set. For example, this single call
accomplishes the same thing:// You can OR together two or more flags,cout.setf(ios::showpoint | ios::showpos);Because the format flags are defined within the
iosclass, you must access their values byusingiosand the scope resolution operator. For example,
showbaseby itself will not berecognized. You must specify
ios::showbase.Clearing Format Flags
The complement ofsetf( )isunsetf( ). This member function ofiosis used to clear oneor more format flags. Its general form is
void unsetf(fmtflagsflags);The flags specified byflagsare cleared. (All other flags are unaffected.)
The following program illustrates
unsetf( ). It first sets both theuppercaseandscientificflags. It then outputs 100.12 in scientific notation. In this case, the "E" usedin the scientific notation is in uppercase. Next, it clears the
uppercaseflag and againoutputs 100.12 in scientific notation, using a lowercase "e."
#include <iostream>using namespace std;int main(){cout.setf(ios::uppercase | ios::scientific);cout << 100.12;  // displays 1.001200E+02
cout.unsetf(ios::uppercase); // clear uppercase
cout << " \n" << 100.12; // displays 1.001200e+02
return 0;}An Overloaded Form of setf( )
There is an overloaded form of
setf( )that takes this general form:fmtflags setf(fmtflagsflags1, fmtflagsflags2);In this version, only the flags specified byflags2are affected. They are first cleared and
then set according to the flags specified by
flags1. Note that even ifflags1contains otherflags,onlythosespecifiedby
flags2willbeaffected.Thepreviousflagssettingisreturned.
For example,#include <iostream>using namespace std;int main( ){cout.setf(ios::showpoint | ios::showpos, ios::showpoint);cout << 100.0; // displays 100.000, not +100.000
return 0;}516C++:TheCompleteReference
Here,
showpointis set, but notshowpos,since it is not specified in the second
parameter.
Perhaps the most common use of the two-parameter form of
setf( )is when settingthe number base, justification, and format flags. As explained, references to the
oct,dec, andhexfields can collectively be referred to as
basefield. Similarly, the
left,right,andinternalfields can be referred to as
adjustfield. Finally, the
scientificandfixedfields can be referenced as
floatfield.Since the flags that comprise these groupingsare
mutuallyexclusive,youmayneedtoturnoffoneflagwhensettinganother.Forexample,
thefollowingprogramsetsoutputtohexadecimal.Tooutputinhexadecimal,some

implementations require that the other number base flags be turned off in addition to

turning on thehexflag. This is most easily accomplished using the two-parameter formofsetf( ).#include <iostream>using namespace std;int main(){cout.setf(ios::hex, ios::basefield);cout << 100; // this displays 64
return 0;}Here, the
basefieldflags (i.,e.,dec,oct, andhex) are first cleared and then the
hexflagis set.Remember, only the flags specified in
flags2can be affected by flags specified by
flags1. For example, in this program, the first attempt to set the
showposflag fails.// This program will not work.#include <iostream>
using namespace std;int main(){cout.setf(ios::showpos, ios::hex); // error, showpos not setcout << 100 << '\n'; // displays 100, not +100
cout.setf(ios::showpos, ios::showpos); // this is correctChapter20:TheC++I/OSystemBasics
517C++518C++:TheCompleteReference
cout << 100; // now displays +100return 0;}Keep in mind that most of the time you will want to useunsetf( )to clear flags andthe single parameter version ofsetf( )(described earlier) to set flags. Thesetf(fmtflags,fmtflags)version ofsetf( )is most often used in specialized situations, such as settingthe number base. Another good use may involve a situation in which you are using
a flag template that specifies the state of all format flags but wish to alter only one or
two.Inthiscase,youcouldspecifythetemplatein
flags1anduse
flags2tospecifywhich
of those flags will be affected.
Examining the Formatting Flags
There will be times when you only want to know the current format settings but not

alter any. To accomplish this goal,
iosincludes the member functionflags( ), whichsimply returns the current setting of each format flag. Its prototype is shown here:
fmtflags flags( );Thefollowingprogramuses
flags()
todisplaythesettingoftheformatflagsrelative
tocout. Pay special attention to theshowflags( )function. You might find it useful in
programs you write.
#include <iostream>using namespace std;void showflags() ;
int main(){// show default condition of format flags
showflags();cout.setf(ios::right | ios::showpoint | ios::fixed);
showflags();
return 0;}Chapter20:TheC++I/OSystemBasics
519C++// This function displays the status of the format flags.void showflags()
{ios::fmtflags f;long i;f = (long) cout.flags(); // get flag settings
// check each flagfor(i=0x4000; i; i = i >> 1)if(i & f) cout << "1 ";
else cout << "0 ";cout << " \n";}Sample output from the program is shown here. (The precise output will vary from
compiler to compiler.)
0 0 0 0 0 1 0 0 0 0 0 0 0 0 1
0 1 0 0 0 1 0 1 0 0 1 0 0 0 1Setting All FlagsTheflags( )function has a second form that allows you to set all format flags associatedwith a stream. The prototype for this version of
flags( )is shown here:
fmtflags flags(fmtflagsf);When you use this version, the bit pattern found infis used to set the format flagsassociated with the stream. Thus, all format flags are affected. The function returns
the previous settings.
The next program illustrates this version of
flags( ). It first constructs a flag mask
that turns onshowpos,showbase,oct, andright. All other flags are off. It then uses
flags()
tosettheformatflagsassociatedwith
couttothesesettings.Thefunction
showflags( )verifies that the flags are set as indicated. (It is the same function used
in the previous program.)
#include <iostream>using namespace std;520C++:TheCompleteReference
void showflags();int main(){// show default condition of format flags
showflags();// showpos, showbase, oct, right are on, others offios::fmtflags f = ios::showpos | ios::showbase | ios::oct | ios::right;
cout.flags(f);  // set all flagsshowflags();
return 0;}Using width( ), precision( ), and fill( )
In addition to the formatting flags, there are three member functions defined by
iosthat set these format parameters: the field width, the precision, and the fill character.
The functions that do these things are
width( ),precision( ), andfill( ), respectively.
Each is examined in turn.By default, when a value is output, it occupies only as much space as the numberof characters it takes to display it. However, you can specify a minimum field width

by using thewidth( )function. Its prototype is shown here:
streamsize width(streamsizew);Here,
wbecomes the field width, and the previous field width is returned. In some
implementations, the field width must be set before each output. If it isn't, the default

fieldwidthisused.The
streamsizetypeisdefinedassomeformofintegerbythe
compiler.
After you set a minimum field width, when a value uses less than the specifiedwidth, the field will be padded with the current fill character (space, by default) to

reach the field width. If the size of the value exceeds the minimum field width, the

field will be overrun. No values are truncated.
When outputting floating-point values, you can determine the number of digitsof precision by using the
precision( )function. Its prototype is shown here:
streamsize precision(streamsizep);Here, the precision is set to
p, and the old value is returned. The default precision is 6.
In some implementations, the precision must be set before each floating-point output.
If it is not, then the default precision will be used.
By default, when a field needs to be filled, it is filled with spaces. You can specify
the fill character by using thefill( )function. Its prototype is
char fill(charch);After a call tofill( ),chbecomes the new fill character, and the old one is returned.
Here is a program that illustrates these functions:
#include <iostream>using namespace std;int main(){cout.precision(4) ;
cout.width(10);cout << 10.12345 << "\n";  // displays 10.12
cout.fill('*');
cout.width(10);cout << 10.12345 << "\n"; // displays *****10.12// field width applies to strings, toocout.width(10);
cout << "Hi!" << "\n"; // displays *******Hi!
cout.width(10);
cout.setf(ios::left); // left justify
cout << 10.12345; // displays 10.12*****return 0;}This program's output is shown here:
10.12*****10.12*******Hi!
10.12*****Chapter20:TheC++I/OSystemBasics
521C++There are overloaded forms of
width( ),precision( ), andfill( )that obtain but donot change the current setting. These forms are shown here:
char fill( );streamsize width( );
streamsize precision( );Using Manipulators to Format I/O
The second way you can alter the format parameters of a stream is through the use

of special functions calledmanipulatorsthat can be included in an I/O expression. The
standard manipulators are shown in Table 20-1. As you can see by examining the table,

many of the I/O manipulators parallel member functions of theiosclass. Many of themanipulatorswereaddedrecentlytoC++andwillnotbesupportedbyoldercompilers.
522C++:TheCompleteReference
ManipulatorPurposeInput/OutputboolalphaTurns on
boolaphaflag.Input/Output
decTurns on
decflag.Input/OutputendlOutput a newline character
and flush the stream.
OutputendsOutput a null.OutputfixedTurns on
fixedflag.Output
flushFlush a stream.
OutputhexTurns on
hexflag.Input/OutputinternalTurns on
internalflag.Output
leftTurns on
leftflag.OutputnobooalphaTurns off
boolalphaflag.Input/Output
noshowbaseTurns off
showbaseflag.Output
noshowpointTurns off
showpointflag.Output
noshowposTurns off
showposflag.Output
Table20-1.
The C++ ManipulatorsChapter20:TheC++I/OSystemBasics
523C++To access manipulators that take parameters (such as
setw( )), you must include<iomanip>in your program.
ManipulatorPurposeInput/OutputnoskipwsTurns off
skipwsflag.Input
nounitbufTurns off
unitbufflag.Output
nouppercase
Turns off
uppercaseflag.Output
octTurns on
octflag.Input/Outputresetiosflags (fmtflags
f)Turn off the flags
specified inf.Input/OutputrightTurns on
rightflag.OutputscientificTurns on
scientificflag.Output
setbase(intbase)Set the number base
tobase.Input/Outputsetfill(intch)Set the fill character toch.Outputsetiosflags(fmtflagsf)Turn on the flags
specified inf.Input/outputsetprecision (int
p)Set the number of digits
of precision.
Outputsetw(intw)Set the field width tow.OutputshowbaseTurns on
showbaseflag.Output
showpointTurns on
showpointflag.Output
showposTurns on
showposflag.Output
skipwsTurns on
skipwsflag.Input
unitbufTurns on
unitbufflag.Output
uppercase
Turns on
uppercaseflag.Output
wsSkip leading white space.Input
Table20-1.
The C++ Manipulators (continued)524C++:TheCompleteReference
Here is an example that uses some manipulators:
#include <iostream>#include <iomanip>
using namespace std;int main(){cout << hex << 100 << endl;cout << setfill('?') << setw(10) << 2343.0;
return 0;}This displays64??????2343Notice how the manipulators occur within a larger I/O expression. Also notice that
when a manipulator does not take an argument, such as
endl( )in the example, it is notfollowed by parentheses. This is because it is the address of the function that is passed
to the overloaded<<operator.
Asacomparison,hereisafunctionallyequivalentversionoftheprecedingprogram
that usesiosmember functions to achieve the same results:
#include <iostream>#include <iomanip>
using namespace std;int main(){cout.setf(ios::hex, ios::basefield);
cout << 100 << "\n";  // 100 in hexcout.fill('?');cout.width(10);
cout << 2343.0;return 0;}As the examples suggest, the main advantage of using manipulators instead oftheiosmember functions is that they often allow more compact code to be written.
You can use the
setiosflags( )manipulator to directly set the various format flags
related to a stream. For example, this program uses
setiosflags( )to set theshowbaseandshowposflags:#include <iostream>#include <iomanip>
using namespace std;int main(){cout << setiosflags(ios::showpos);
cout << setiosflags(ios::showbase);
cout << 123 << " " << hex << 123;return 0;}The manipulatorsetiosflags( )performs the same function as the member functionsetf( ).One of the more interesting manipulators is
boolapha. It allows true and false
values to be input and output using the words "true" and "false" rather than numbers.
For example,#include <iostream>using namespace std;int main(){bool b;b = true;cout << b << " " << boolalpha << b << endl;cout << "Enter a Boolean value: ";cin >> boolalpha >> b;
cout << "Here is what you entered:  " << b;return 0;}Chapter20:TheC++I/OSystemBasics
525C++526C++:TheCompleteReference
Here is a sample run.
1 trueEnter a Boolean value: false
Here is what you entered:  falseOverloading << and >>As you know, the
<<and the>>operators are overloaded in C++ to perform I/O
operations on C++'s built-in types. You can also overload these operators so that
they perform I/O operations on types that you create.
In the language of C++, the<<output operator is referred to as the
insertion operatorbecause it inserts characters into a stream. Likewise, the
>>input operator is calledtheextractionoperator
because it extracts characters from a stream. The functions that
overloadtheinsertionandextractionoperatorsaregenerallycalled
insertersandextractors,respectively.
Creating Your Own Inserters
It is quite simple to create an inserter for a class that you create. All inserter functions

have this general form:ostream &operator<<(ostream &stream, class_type obj)
{//body of inserterreturnstream;}Notice that the function returns a reference to a stream of type
ostream. (Remember,
ostreamis a class derived from
iosthat supports output.) Further, the first parameter
to the function is a reference to the output stream. The second parameter is the object

beinginserted.(Thesecondparametermayalsobeareferencetotheobjectbeinginserted.)

Thelastthingtheinsertermustdobeforeexitingisreturn
stream
.Thisallowstheinserter
to be used in a larger I/O expression.
Within an inserter function, you may put any type of procedures or operations that
you want. That is, precisely what an inserter does is completely up to you. However,

for the inserter to be in keeping with good programming practices, you should limit

its operations to outputting information to a stream. For example, having an inserter

compute pi to 30 decimal places as a side effect to an insertion operation is probably

not a very good idea!To demonstrate a custom inserter, one will be created for objects of type
phonebook, shown here.
class phonebook {public:Chapter20:TheC++I/OSystemBasics
527C++char name[80];int areacode;
int prefix;
int num;
phonebook(char *n, int a, int p, int nm)
{strcpy(name, n);areacode = a;
prefix = p;
num = nm;}};This class holds a person's name and telephone number. Here is one way to create
an inserter function for objects of typephonebook.// Display name and phone number
ostream &operator<<(ostream &stream, phonebook o)
{stream << o.name << " ";
stream << "(" << o.areacode << ") ";
stream << o.prefix << "-" << o.num << "\n";return stream; // must return stream}Here is a short program that illustrates the
phonebookinserter function:#include <iostream>#include <cstring>
using namespace std;class phonebook {public:char name[80];
int areacode;
int prefix;
int num;
phonebook(char *n, int a, int p, int nm)
{strcpy(name, n);
areacode = a;
prefix = p;
num = nm;}};// Display name and phone number.ostream &operator<<(ostream &stream, phonebook o)
{stream << o.name << " ";
stream << "(" << o.areacode << ") ";
stream << o.prefix << "-" << o.num << "\n";return stream; // must return stream}
int main(){phonebook a("Ted", 111, 555, 1234);
phonebook b("Alice", 312, 555, 5768);
phonebook c("Tom", 212, 555, 9991);cout << a << b << c;
return 0;}The program produces this output:
Ted (111) 555-1234Alice (312) 555-5768
Tom (212) 555-9991In the preceding program, notice that the
phonebookinserter is not a member ofphonebook. Although this may seem weird at first, the reason is easy to understand.
When an operator function of any type is a member of a class, the left operand (passed
implicitlythrough
this)istheobjectthatgeneratesthecalltotheoperatorfunction.
Further, this object is an
object of the classfor which the operator function is a member.
Thereisnowaytochangethis.Ifanoverloadedoperatorfunctionisamemberofa

class,theleftoperandmustbeanobjectofthatclass.However,whenyouoverload

inserters,theleftoperandisa
stream
andtherightoperandisanobjectoftheclass.
Therefore,overloadedinserterscannotbemembersoftheclassforwhichtheyare

overloaded. The variablesname,areacode,prefix, andnumare public in the preceding
program so that they can be accessed by the inserter.
528C++:TheCompleteReference
The fact that inserters cannot be members of the class for which they are defined
seems to be a serious flaw in C++. Since overloaded inserters are not members, how
can they access the private elements of a class? In the foregoing program, all members

weremadepublic.However,encapsulationisanessentialcomponentofobject-oriented

programming. Requiring that all data that will be output be public conflicts with this

principle. Fortunately, there is a solution to this dilemma: Make the inserter a
friendoftheclass.Thispreservestherequirementthatthefirstargumenttotheoverloadedinserter

be a stream and still grants the function access to the private members of the class for

which it is overloaded. Here is the same program modified to make the inserter into

afriendfunction:#include <iostream>#include <cstring>
using namespace std;class phonebook {// now privatechar name[80];
int areacode;
int prefix;
int num;public:phonebook(char *n, int a, int p, int nm)
{strcpy(name, n);
areacode = a;
prefix = p;
num = nm;}
friend ostream &operator<<(ostream &stream, phonebook o);};// Display name and phone number.ostream &operator<<(ostream &stream, phonebook o)
{stream << o.name << " ";
stream << "(" << o.areacode << ") ";
stream << o.prefix << "-" << o.num << "\n";return stream; // must return stream}Chapter20:TheC++I/OSystemBasics
529C++int main(){phonebook a("Ted", 111, 555, 1234);phonebook b("Alice", 312, 555, 5768);
phonebook c("Tom", 212, 555, 9991);cout << a << b << c;
return 0;}Whenyoudefinethebodyofaninserterfunction,remembertokeepitasgeneralas
possible. For example, the inserter shown in the preceding example can be used with
any stream because the body of the function directs its output to
stream, which is thestreamthatinvokedtheinserter.Whileitwouldnotbetechnicallywrongtohavewritten
stream << o.name << " ";ascout << o.name << " ";thiswouldhavetheeffectofhard-coding
coutastheoutputstream.Theoriginal
versionwillworkwithanystream,includingthoselinkedtodiskfiles.Althoughin

some situations, especially where special output devices are involved, you may want to

hard-codetheoutputstream,inmostcasesyouwillnot.Ingeneral,themoreflexible

yourinsertersare,themorevaluabletheyare.
The inserter for thephonebookclass works fine unless the value ofnumis somethinglike 0034, in which case the preceding zeroes will not be displayed. To fix this, you can

eithermake
numintoastringoryoucansetthefillcharactertozeroandusethe
width()
format function to generate the leading zeroes. The solution is left to the reader as

an exercise.
Beforemovingontoextractors,let'slookatonemoreexampleofaninserter
function. An inserter need not be limited to handling only text. An inserter can be used
to output data in any form that makes sense. For example, an inserter for some class
that is part of a CAD system may output plotter instructions. Another inserter might

generate graphics images. An inserter for a Windows-based program could display

a dialog box. To sample the flavor of outputting things other than text, examine the

following program, which draws boxes on the screen. (Because C++ does not define
530C++:TheCompleteReference
Chapter20:TheC++I/OSystemBasics
531C++a graphics library, the program uses characters to draw a box, but feel free to substitute
graphics if your system supports them.)#include <iostream>using namespace std;class box {int x, y;public:box(int i, int j) { x=i; y=j; }friend ostream &operator<<(ostream &stream, box o);};// Output a box.ostream &operator<<(ostream &stream, box o)
{register int i, j;for(i=0; i<o.x; i++)stream << "*";stream << "\n";
for(j=1; j<o.y-1; j++) {for(i=0; i<o.x; i++)if(i==0 || i==o.x-1) stream << "*";else stream << " ";stream << "\n";}for(i=0; i<o.x; i++)stream << "*";stream << "\n";
return stream;}
int main(){box a(14, 6), b(30, 7), c(40, 5);532C++:TheCompleteReference
cout << "Here are some boxes:\n";cout << a << b << c;return 0;}The program displays the following:
Here are some boxes:**************
*            *
*            *
*            *
*            *
**************
******************************
*                            *
*                            *
*                            *
*                            *
*                            *
******************************
****************************************
*                                      *
*                                      *
*                                      *
****************************************Creating Your Own Extractors
Extractors are the complement of inserters. The general form of an extractor function is
istream &operator>>(istream &stream, class_type &obj){//body of extractorreturnstream;}Extractors return a reference to a stream of type
istream, which is an input stream.
The first parameter must also be a reference to a stream of type
istream. Notice thatChapter20:TheC++I/OSystemBasics
533C++thesecondparametermustbeareferencetoanobjectoftheclassforwhichthe
extractor is overloaded. This is so the object can be modified by the input (extraction)
operation.Continuing with thephonebookclass, here is one way to write an extraction
function:istream &operator>>(istream &stream, phonebook &o){cout << "Enter name: ";
stream >> o.name;
cout << "Enter area code: ";
stream >> o.areacode;
cout << "Enter prefix: ";
stream >> o.prefix;
cout << "Enter number: ";
stream >> o.num;
cout << "\n";return stream;}Noticethatalthoughthisisaninputfunction,itperformsoutputbypromptingtheuser.
The point is that although the main purpose of an extractor is input, it can perform any
operations necessary to achieve that end. However, as with inserters, it is best to keep

the actions performed by an extractor directly related to input. If you don't, you run the

risk of losing much in terms of structure and clarity.
Here is a program that illustrates the
phonebookextractor:#include <iostream>#include <cstring>
using namespace std;class phonebook {char name[80];int areacode;
int prefix;
int num;public:phonebook() { };
phonebook(char *n, int a, int p, int nm)
{strcpy(name, n);
areacode = a;
prefix = p;num = nm;}friend ostream &operator<<(ostream &stream, phonebook o);
friend istream &operator>>(istream &stream, phonebook &o);};// Display name and phone number.ostream &operator<<(ostream &stream, phonebook o)
{stream << o.name << " ";
stream << "(" << o.areacode << ") ";
stream << o.prefix << "-" << o.num << "\n";return stream; // must return stream}
// Input name and telephone number.istream &operator>>(istream &stream, phonebook &o)
{cout << "Enter name: ";
stream >> o.name;
cout << "Enter area code: ";
stream >> o.areacode;
cout << "Enter prefix: ";
stream >> o.prefix;
cout << "Enter number: ";
stream >> o.num;
cout << "\n";return stream;}
int main(){phonebook a;cin >> a;
cout << a;
return 0;}534C++:TheCompleteReference
C++Chapter20:TheC++I/OSystemBasics
535Actually,theextractorfor
phonebookislessthanperfectbecausethe
coutstatementsareneededonlyiftheinputstreamisconnectedtoaninteractivedevicesuchastheconsole
(that is, when the input stream is
cin). If the extractor is used on a stream connected to
a disk file, for example, then thecoutstatements would not be applicable. For fun, youmight want to try suppressing the
coutstatements except when the input stream refers
tocin. For example, you might useifstatements such as the one shown here.
if(stream == cin) cout << "Enter name: ";Now, the prompt will take place only when the output device is most likely the screen.
Creating Your Own Manipulator Functions
Inadditiontooverloadingtheinsertionandextractionoperators,youcanfurther

customizeC++'sI/Osystembycreatingyourownmanipulatorfunctions.Custom

manipulators are important for two main reasons. First, you can consolidate a sequence

ofseveralseparateI/Ooperationsintoonemanipulator.Forexample,itisnotuncommon

tohavesituationsinwhichthesamesequenceofI/Ooperationsoccursfrequentlywithin

a program. In these cases you can use a custom manipulator to perform these actions,

thussimplifyingyoursourcecodeandpreventingaccidentalerrors.Acustommanipulator

canalsobeimportantwhenyouneedtoperformI/Ooperationsonanonstandarddevice.

For example, you might use a manipulator to send control codes to a special type of

printer or to an optical recognition system.
Custom manipulators are a feature of C++ that supports OOP, but also can benefit
programs that aren't object oriented. As you will see, custom manipulators can help

make any I/O-intensive program clearer and more efficient.
As you know, there are two basic types of manipulators: those that operate on
inputstreamsandthosethatoperateonoutputstreams.Inadditiontothesetwobroad

categories, there is a secondary division: those manipulators that take an argument

andthosethatdon't.Frankly,theproceduresnecessarytocreateaparameterized

manipulator vary widely from compiler to compiler, and even between two different

versions of the same compiler. For this reason, you must consult the documentation

to your compiler for instructions on creating parameterized manipulators. However,

the creation of parameterless manipulators is straightforward and the same for all

compilers. It is described here.
All parameterless manipulator output functions have this skeleton:ostream &manip-name(ostream &stream){//your code herereturnstream;}Here,
manip-nameis the name of the manipulator. Notice that a reference to a stream of
typeostreamis returned. This is necessary if a manipulator is used as part of a larger
I/O expression. It is important to note that even though the manipulator has as its
single argument a reference to the stream upon which it is operating, no argument

is used when the manipulator is inserted in an output operation.As a simple first example, the following program creates a manipulator called
sethex( ), which turns on theshowbaseflag and sets output to hexadecimal.#include <iostream>#include <iomanip>
using namespace std;// A simple output manipulator.ostream &sethex(ostream &stream)
{stream.setf(ios::showbase);
stream.setf(ios::hex, ios::basefield);return stream;}
int main(){cout << 256 << " " << sethex << 256;return 0;}This program displays
256 0x100. As you can see,sethexis used as part of an I/Oexpression in the same way as any of the built-in manipulators.
Custom manipulators need not be complex to be useful. For example, the simplemanipulatorsla( )andra( )display a left and right arrow for emphasis, as shown here:
#include <iostream>#include <iomanip>
using namespace std;// Right Arrowostream &ra(ostream &stream)
{stream << "-------> ";
return stream;536C++:TheCompleteReference
C++Chapter20:TheC++I/OSystemBasics
537}// Left Arrowostream &la(ostream &stream)
{stream << " <-------";return stream;}int main(){cout << "High balance " << ra << 1233.23 << "\n";
cout << "Over draft " << ra << 567.66 << la;return 0;}This program displays:
High balance -------> 1233.23Over draft -------> 567.66 <-------If used frequently, these simple manipulators save you from some tedious typing.
Using an output manipulator is particularly useful for sending special codes toadevice.Forexample,aprintermaybeabletoacceptvariouscodesthatchangethe
typesizeorfont,orthatpositiontheprintheadinaspeciallocation.Iftheseadjustments

are going to be made frequently, they are perfect candidates for a manipulator.
All parameterless input manipulator functions have this skeleton:istream &manip-name(istream &stream){//your code herereturnstream;}An input manipulator receives a reference to the stream for which it was invoked. This

stream must be returned by the manipulator.
The following program creates the
getpass( )input manipulator, which rings the
bell and then prompts for a password:
#include <iostream>#include <cstring>using namespace std;// A simple input manipulator.istream &getpass(istream &stream)
{cout << '\a';  // sound bellcout << "Enter password: ";return stream;}
int main(){char pw[80];do {cin >> getpass >> pw;} while (strcmp(pw, "password"));
cout << "Logon complete\n";
return 0;}Remember that it is crucial that your manipulator return
stream. If it does not, yourmanipulator cannot be used in a series of input or output operations.538C++:TheCompleteReference
Chapter21
C++ File I/O539Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
Although C++ I/O forms an integrated system, file I/O is sufficiently specializedthat it is generally thought of as a special case, subject to its own constraints and
quirks. In part, this is because the most common file is a disk file, and disk fileshavecapabilitiesandfeaturesthatmostotherdevicesdon't.Keepinmind,however,

that disk file I/O is simply a special case of the general I/O system and that most of the
material discussed in this chapter also applies to streams connected to other types of
devices.<fstream> and the File Classes
To perform file I/O, you must include the header
<fstream>in your program. It
defines several classes, includingifstream,ofstream, andfstream. These classes are
derivedfrom
istream,ostream,and
iostream,respectively.Remember,
istream,ostream, andiostreamare derived from
ios, soifstream,ofstream, andfstreamalsohaveaccesstoalloperationsdefinedby
ios(discussedintheprecedingchapter).
Another class used by the file system isfilebuf, which provides low-level facilities to
manage a file stream. Usually, you don't use
filebufdirectly, but it is part of the other
file classes.Opening and Closing a FileIn C++, you open a file by linking it to a stream. Before you can open a file, you must

first obtain a stream. There are three types of streams: input, output, and input/output.

To create an input stream, you must declare the stream to be of class
ifstream. To create
anoutputstream,youmustdeclareitasclass
ofstream.Streamsthatwillbeperforming
both input and output operations must be declared as class
fstream. For example, thisfragment creates one input stream, one output stream, and one stream capable of both

input and output:ifstream in;  // inputofstream out; // output
fstream io;   // input and outputOnceyouhavecreatedastream,onewaytoassociateitwithafileisbyusing
open()
.Thisfunctionisamemberofeachofthethreestreamclasses.Theprototypeforeachis
shown here:
voidifstream::open(constchar*
filename,ios::openmode
mode=ios::in);
voidofstream::open(constchar*
filename,ios::openmode
mode=ios::out|ios::trunc);
voidfstream::open(constchar*
filename,ios::openmode
mode=
ios::in|ios::out);540C++:TheCompleteReference
Here,
filenameisthenameofthefile;itcanincludeapathspecifier.Thevalueof
modedetermineshowthefileisopened.Itmustbeoneormoreofthefollowingvaluesdefined
byopenmode,whichisanenumerationdefinedby
ios(throughitsbaseclass
ios_base).ios::app
ios::ate
ios::binary
ios::in
ios::out
ios::truncYou can combine two or more of these values by ORing them together.
Includingios::appcauses all output to that file to be appended to the end. Thisvalue can be used only with files capable of output. Includingios::atecauses a seektotheendofthefiletooccurwhenthefileisopened.Although
ios::atecausesan
initialseektoend-of-file,I/Ooperationscanstilloccuranywherewithinthefile.
Theios::invalue specifies that the file is capable of input. Theios::outvaluespecifies that the file is capable of output.Theios::binaryvalue causes a file to be opened in binary mode. By default, allfiles are opened in text mode. In text mode, various character translations may take

place, such as carriage return/linefeed sequences being converted into newlines.

However, when a file is opened in binary mode, no such character translations will

occur. Understand that any file, whether it contains formatted text or raw data, can

be opened in either binary or text mode. The only difference is whether character

translations take place.Theios::truncvalue causes the contents of a preexisting file by the same name to
be destroyed, and the file is truncated to zero length. When creating an output stream

usingofstream, any preexisting file by that name is automatically truncated.
The following fragment opens a normal output file.ofstream out;out.open("test", ios::out);However, you will seldom see
open( )called as shown, because themodeparameterprovides default values for each type of stream. As their prototypes show, for
ifstream,modedefaults toios::in; forofstream, it isios::out | ios::trunc; and forfstream, it isios::in | ios::out. Therefore, the preceding statement will usually look like this:
out.open("test"); // defaults to output and normal fileDepending on your compiler, the mode parameter for
fstream::open( )
may not defaulttoin | out. Therefore, you might need to specify this explicitly.
Chapter21:C++FileI/O
541C++Ifopen( )fails, the stream will evaluate to false when used in a Boolean expression.
Therefore, before using a file, you should test to make sure that the open operation
succeeded. You can do so by using a statement like this:
if(!mystream) {cout << "Cannot open file.\n";// handle error}Although it is entirely proper to open a file by using the
open( )function, mostof the time you will not do so because theifstream,ofstream, andfstreamclasseshave constructors that automatically open the file. The constructors have the same
parameters and defaults as theopen( )function. Therefore, you will most commonly
see a file opened as shown here:
ifstream mystream("myfile"); // open file for inputAs stated, if for some reason the file cannot be opened, the value of the associated
stream variable will evaluate to false. Therefore, whether you use a constructor to open

the file or an explicit call toopen( ), you will want to confirm that the file has actuallybeen opened by testing the value of the stream.
You can also check to see if you have successfully opened a file by using the
is_open( )function, which is a member offstream,ifstream, andofstream. It hasthis prototype:
bool is_open( );It returns true if the stream is linked to an open file and false otherwise. For example,

the following checks ifmystreamis currently open:
if(!mystream.is_open()) {cout << "File is not open.\n";// ...To close a file, use the member function
close( ). For example, to close the file linkedto a stream called
mystream, use this statement:mystream.close();Theclose( )function takes no parameters and returns no value.
542C++:TheCompleteReference
Reading and Writing Text Files
It is very easy to read from or write to a text file. Simply use the
<<and>>operatorsthe same way you do when performing console I/O, except that instead of usingcinandcout, substitute a stream that is linked to a file. For example, this program creates
a short inventory file that contains each item's name and its cost:#include <iostream>#include <fstream>
using namespace std;int main(){ofstream out("INVNTRY"); // output, normal fileif(!out) {cout << "Cannot open INVENTORY file.\n";return 1;}out << "Radios " << 39.95 << endl;out << "Toasters " << 19.95 << endl;
out << "Mixers " << 24.80 << endl;out.close();return 0;}The following program reads the inventory file created by the previous program
and displays its contents on the screen:
#include <iostream>
#include <fstream>
using namespace std;int main(){ifstream in("INVNTRY"); // inputif(!in) {cout << "Cannot open INVENTORY file.\n";return 1;Chapter21:C++FileI/O
543C++544C++:TheCompleteReference
}char item[20];float cost;in >> item >>  cost;cout << item << " " << cost << "\n";
in >> item >> cost;
cout << item << " " << cost << "\n";
in >> item >> cost;
cout << item << " " << cost << "\n";in.close();return 0;}In a way, reading and writing files by using
>>and<<is like using the C-basedfunctionsfprintf( )andfscanf( ). All information is stored in the file in the same format
as it would be displayed on the screen.
FollowingisanotherexampleofdiskI/O.Thisprogramreadsstringsentered
atthekeyboardandwritesthemtodisk.Theprogramstopswhentheuserenters
an exclamation point. To use the program, specify the name of the output file on the

command line.#include <iostream>#include <fstream>
using namespace std;int main(int argc, char *argv[]){if(argc!=2) {cout << "Usage: output <filename>\n";
return 1;}ofstream out(argv[1]); // output, normal file
if(!out) {cout << "Cannot open output file.\n";return 1;}Chapter21:C++FileI/O
545C++char str[80];cout << "Write strings to disk. Enter ! to stop.\n";do {cout << ": ";cin >> str;
out << str << endl;} while (*str != '!');out.close();return 0;}When reading text files using the
>>operator, keep in mind that certain character
translations will occur. For example, white-space characters are omitted. If you want
to prevent any character translations, you must open a file for binary access and use

the functions discussed in the next section.When inputting, if end-of-file is encountered, the stream linked to that file will
evaluate as false. (The next section illustrates this fact.)Unformatted and Binary I/O
While reading and writing formatted text files is very easy, it is not always the most

efficientwaytohandlefiles.Also,therewillbetimeswhenyouneedtostoreunformatted

(raw) binary data, not text. The functions that allow you to do this are described here.
Whenperformingbinaryoperationsonafile,besuretoopenitusingthe
ios::binarymode specifier. Although the unformatted file functions will work on files opened for

text mode, some character translations may occur. Character translations negate the

purpose of binary file operations.Characters vs. BytesBefore beginning our examination of unformatted I/O, it is important to clarify an

important concept. For many years, I/O in C and C++ was thought of asbyte oriented.Thisisbecausea
charisequivalenttoabyteandtheonlytypesofstreamsavailable
were
charstreams. However, with the advent of wide characters (of type
wchar_t) andtheirattendantstreams,wecannolongersaythatC++I/Oisbyteoriented.Instead,

we must say that it ischaracteroriented
. Of course,charstreams are still byte oriented
andwecancontinuetothinkintermsofbytes,especiallywhenoperatingonnontextual
546C++:TheCompleteReference
data. But the equivalency between a byte and a character can no longer be taken forgranted.As explained in Chapter 20, all of the streams used in this book are
charstreams
since they are by far the most common. They also make unformatted file handling

easier because acharstream establishes a one-to-one correspondence between bytes
and characters, which is a benefit when reading or writing blocks of binary data.
put( ) and get( )One way that you may read and write unformatted data is by using the member

functionsget( )andput( ).These functions operate on characters. That is,
get( )willread a character and
put( )will write a character. Of course, if you have opened the
file for binary operations and are operating on a
char(rather than awchar_tstream),
then these functions read and write bytes of data.
Theget( )function has many forms, but the most commonly used version is shownhere along with
put( ):istream &get(char &ch);
ostream &put(charch);Theget( )function reads a single character from the invoking stream and puts that
value inch. It returns a reference to the stream. The
put( )function writeschto thestream and returns a reference to the stream.
The following program displays the contents of any file, whether it contains text
or binary data, on the screen. It uses the
get( )function.#include <iostream>#include <fstream>
using namespace std;int main(int argc, char *argv[]){char ch;if(argc!=2) {cout << "Usage: PR <filename>\n";return 1;}ifstream in(argv[1], ios::in | ios::binary);if(!in) {cout << "Cannot open file.";Chapter21:C++FileI/O
547C++return 1;}while(in) { // in will be false when eof is reachedin.get(ch);if(in) cout << ch;}return 0;}As stated in the preceding section, when the end-of-file is reached, the stream
associated with the file becomes false. Therefore, when
inreaches the end of the file,
it will be false, causing thewhileloop to stop.There is actually a more compact way to code the loop that reads and displays
a file, as shown here:
while(in.get(ch))cout << ch;This works becauseget( )returns a reference to the stream
in, andinwill be false whenthe end of the file is encountered.
The next program uses
put( )to write all characters from zero to 255 to a file called
CHARS.Asyouprobablyknow,theASCIIcharactersoccupyonlyabouthalftheavailable
values that can be held by achar. The other values are generally called the
extendedcharacterset
and include such things as foreign language and mathematical symbols.
(Not all systems support the extended character set, but most do.)#include <iostream>#include <fstream>
using namespace std;int main(){int i;
ofstream out("CHARS", ios::out | ios::binary);if(!out) {cout << "Cannot open output file.\n";return 1;}548C++:TheCompleteReference
// write all characters to diskfor(i=0; i<256; i++) out.put((char) i);out.close();return 0;}You might find it interesting to examine the contents of the CHARS file to see what
extended characters your computer has available.read( ) and write( )
Another way to read and write blocks of binary data is to use C++'s
read( )andwrite()
functions. Their prototypes are
istream &read(char*buf, streamsizenum);ostream &write(const char*buf, streamsizenum);Theread()
functionreads
numcharactersfromtheinvokingstreamandputstheminthe
bufferpointedtoby
buf.The
write()
functionwrites
numcharacterstotheinvoking
streamfromthebufferpointedtoby
buf.Asmentionedintheprecedingchapter,
streamsizeis a type defined by the C++ library as some form of integer. It is capable of
holdingthelargestnumberofcharactersthatcanbetransferredinanyoneI/Ooperation.
The next program writes a structure to disk and then reads it back in:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;struct status {char name[80];double balance;
unsigned long account_num;};int main(){struct status acc;strcpy(acc.name, "Ralph Trantor");acc.balance = 1123.23;
acc.account_num = 34235678;// write dataofstream outbal("balance", ios::out | ios::binary);
if(!outbal) {cout << "Cannot open file.\n";return 1;}outbal.write((char *) &acc, sizeof(struct status));outbal.close();// now, read back;ifstream inbal("balance", ios::in | ios::binary);
if(!inbal) {cout << "Cannot open file.\n";
return 1;}inbal.read((char *) &acc, sizeof(struct status));
cout << acc.name << endl;cout << "Account # " << acc.account_num;
cout.precision(2);
cout.setf(ios::fixed);
cout << endl << "Balance: $" << acc.balance;inbal.close();return 0;}As you can see, only a single call toread( )orwrite( )is necessary to read or write
the entire structure. Each individual field need not be read or written separately. As
this example illustrates, the buffer can be any type of object.
The type casts inside the calls toread( )
andwrite( )are necessary when operating
onabufferthatisnotdefinedasacharacterarray.BecauseofC++'sstrongtypechecking,

a pointer of one type will not automatically be converted into a pointer of another type.Chapter21:C++FileI/O
549C++550C++:TheCompleteReference
If the end of the file is reached before
numcharacters have been read, then
read( )simply stops, and the buffer contains as many characters as were available. You can
find out how many characters have been read by using another member function,

calledgcount( ), which has this prototype:
streamsize gcount();It returns the number of characters read by the last binary input operation. The

following program shows another example of
read( )andwrite( )and illustratesthe use ofgcount( ):#include <iostream>#include <fstream>
using namespace std;int main(){double fnum[4] = {99.75, -34.4, 1776.0, 200.1};
int i;ofstream out("numbers", ios::out | ios::binary);if(!out) {cout << "Cannot open file.";
return 1;}out.write((char *) &fnum, sizeof fnum);out.close();
for(i=0; i<4; i++) // clear arrayfnum[i] = 0.0;ifstream in("numbers", ios::in | ios::binary);in.read((char *) &fnum, sizeof fnum);// see how many bytes have been readcout << in.gcount() << " bytes read\n";for(i=0; i<4; i++) // show values read from filecout << fnum[i] << " ";in.close();return 0;}The preceding program writes an array of floating-point values to disk and then
reads them back. After the call to
read( ),gcount( )is used to determine how manybytes were just read.
More get( ) Functions
In addition to the form shown earlier, the
get( )function is overloaded in severaldifferent ways. The prototypes for the three most commonly used overloaded forms
are shown here:
istream &get(char *buf, streamsizenum);istream &get(char *buf, streamsizenum, chardelim);int get( );The first form reads characters into the array pointed to by
bufuntil eithernum-1charactershavebeenread,anewlineisfound,ortheendofthefilehasbeenencountered.
The array pointed to bybufwill be null terminated byget( ). If the newline characteris encountered in the input stream, it is
notextracted. Instead, it remains in the stream
until the next input operation.The second form reads characters into the array pointed to by
bufuntil eithernum-1characters have been read, the character specified by
delimhas been found, or the endof the file has been encountered. The array pointed to by
bufwill be null terminated byget( ). If the delimiter character is encountered in the input stream, it is
notextracted.Instead, it remains in the stream until the next input operation.
The third overloaded form of
get( )returns the next character from the stream. It
returns
EOFif the end of the file is encountered. This form of
get( )is similar to C'sgetc( )function.getline( )Another function that performs input isgetline( ). It is a member of each input stream
class. Its prototypes are shown here:
istream &getline(char *buf, streamsizenum);istream &getline(char *buf, streamsizenum, chardelim);Chapter21:C++FileI/O
551C++552C++:TheCompleteReference
The first form reads characters into the array pointed to by
bufuntil eithernum−1characters have been read, a newline character has been found, or the end of the file
has been encountered. The array pointed to by
bufwill be null terminated bygetline( ).If the newline character is encountered in the input stream, it is extracted, but is not put

intobuf.The second form reads characters into the array pointed to by
bufuntil eithernum−1characters have been read, the character specified by
delimhas been found, or the endof the file has been encountered. The array pointed to by
bufwill be null terminated bygetline( ). If the delimiter character is encountered in the input stream, it is extracted,

but is not put intobuf.As you can see, the two versions ofgetline( )are virtually identical to the
get(buf,num)andget(buf, num, delim)versions ofget( ). Both read characters from input and
put them into the array pointed to bybufuntil eithernum−1 characters have been read
or until the delimiter character is encountered. The difference is that
getline( )reads
and removes the delimiter from the input stream;
get( )does not.Here is a program that demonstrates the
getline( )function. It reads the contents of
a text file one line at a time and displays it on the screen.
// Read and display a text file line by line.#include <iostream>#include <fstream>
using namespace std;int main(int argc, char *argv[]){if(argc!=2) {cout << "Usage: Display <filename>\n";
return 1;}ifstream in(argv[1]); // input
if(!in) {cout << "Cannot open input file.\n";return 1;}char str[255];Chapter21:C++FileI/O
553C++while(in) {in.getline(str, 255);  // delim defaults to '\n'if(in) cout << str << endl;}in.close();
return 0;}Detecting EOFYou can detect when the end of the file is reached by using the member function
eof( ),which has this prototype:
bool eof( );It returns true when the end of the file has been reached; otherwise it returns false.
Thefollowingprogramuses
eof()
todisplaythecontentsofafileinbothhexadecimal
and ASCII./* Display contents of specified filein both ASCII and in hex.*/#include <iostream>
#include <fstream>
#include <cctype>
#include <iomanip>
using namespace std;int main(int argc, char *argv[]){if(argc!=2) {cout << "Usage: Display <filename>\n";
return 1;}ifstream in(argv[1], ios::in | ios::binary);if(!in) {cout << "Cannot open input file.\n";return 1;}register int i, j;int count = 0;
char c[16];cout.setf(ios::uppercase);while(!in.eof()) {for(i=0; i<16 && !in.eof(); i++) {in.get(c[i]);}
if(i<16) i--; // get rid of eoffor(j=0; j<i; j++)cout << setw(3) << hex << (int) c[j];for(; j<16; j++) cout << "  ";
cout << "\t";for(j=0; j<i; j++)if(isprint(c[j])) cout << c[j];
else cout << ".";cout << endl;count++;if(count==16) {count = 0;
cout << "Press ENTER to continue: ";
cin.get();
cout << endl;}}in.close();
return 0;}554C++:TheCompleteReference
Chapter21:C++FileI/O
555C++When this program is used to display itself, the first screen looks like this:
2F 2A 20 44 69 73 70 6C 61 79 20 63 6F 6E 74 65   /* Display conte6E 74 73 20 6F 66 20 73 70 65 63 69 66 69 65 64   nts of specified
20 66 69 6C 65  D  A 20 20 20 69 6E 20 62 6F 74   file..    in bot
68 20 41 53 43 49 49 20 61 6E 64 20 69 6E 20 68   h ASCII and in h
65 78 2E  D  A 2A 2F  D  A 23 69 6E 63 6C 75 64   ex...*/..#includ
65 20 3C 69 6F 73 74 72 65 61 6D 3E  D  A 23 69   e <iostream>..#i
6E 63 6C 75 64 65 20 3C 66 73 74 72 65 61 6D 3E   nclude <fstream>D  A 23 69 6E 63 6C 75 64 65 20 3C 63 63 74 79   ..#include <ccty70 65 3E  D  A 23 69 6E 63 6C 75 64 65 20 3C 69   pe>..#include <i
6F 6D 61 6E 69 70 3E  D  A 75 73 69 6E 67 20 6E   omanip>..using n
61 6D 65 73 70 61 63 65 20 73 74 64 3B  D  A  D   amespace std;...A 69 6E 74 20 6D 61 69 6E 28 69 6E 74 20 61 72   .int main(int ar67 63 2C 20 63 68 61 72 20 2A 61 72 67 76 5B 5D   gc, char *argv[]
29  D  A 7B  D  A 20 20 69 66 28 61 72 67 63 21   )..{..  if(argc!
3D 32 29 20 7B  D  A 20 20 20 20 63 6F 75 74 20   =2) {..    cout
3C 3C 20 22 55 73 61 67 65 3A 20 44 69 73 70 6C   << "Usage: DisplPress ENTER to continue:The ignore( ) Function
You can use the
ignore( )member function to read and discard characters from the
input stream. It has this prototype:
istream &ignore(streamsizenum=1, int_typedelim=EOF);It reads and discards characters until either
numcharacters have been ignored (1 by
default) or the character specified bydelimis encountered (
EOFby default). If thedelimiting character is encountered, it is not removed from the input stream. Here,
int_typeis defined as some form of integer.
The next program reads a file called TEST. It ignores characters until either a space
is encountered or 10 characters have been read. It then displays the rest of the file.
#include <iostream>#include <fstream>
using namespace std;int main(){ifstream in("test");556C++:TheCompleteReference
if(!in) {cout << "Cannot open file.\n";return 1;}/* Ignore up to 10 characters or until firstspace is found. */in.ignore(10, ' ');char c;
while(in) {in.get(c);
if(in) cout << c;}in.close();return 0;}peek( ) and putback( )You can obtain the next character in the input stream without removing it from that
stream by using
peek( ).It has this prototype:
int_type peek( );It returns the next character in the stream or
EOFif the end of the file is encountered.
(int_typeis defined as some form of integer.)
You can return the last character read from a stream to that stream by using
putback( ).Its prototype is
istream &putback(charc);where
cis the last character read.
flush( )When output is performed, data is not necessarily immediately written to the physical
device linked to the stream. Instead, information is stored in an internal buffer until the

buffer is full. Only then are the contents of that buffer written to disk. However, you
Chapter21:C++FileI/O
557C++can force the information to be physically written to disk before the buffer is full by
callingflush( ). Its prototype is
ostream &flush( );Calls toflush( )might be warranted when a program is going to be used in adverse
environments (for example, in situations where power outages occur frequently).
Closing a file or terminating a program also flushes all buffers.
Random AccessIn C++'s I/O system, you perform random access by using theseekg( )andseekp( )functions. Their most common forms are
istream &seekg(off_typeoffset, seekdirorigin);ostream &seekp(off_typeoffset, seekdirorigin);Here,
off_type
is an integer type defined byiosthat is capable of containing the largest
validvaluethat
offsetcanhave.
seekdirisanenumerationdefinedby
iosthatdetermines
how the seek will take place.The C++ I/O system manages two pointers associated with a file. One is thegetpointer, which specifies where in the file the next input operation will occur. The other
is theput pointer, which specifies where in the file the next output operation will occur.
Eachtimeaninputoroutputoperationtakesplace,theappropriatepointerisautomatically
sequentially advanced. However, using the
seekg( )andseekp( )functions allows youto access the file in a nonsequential fashion.Theseekg()
functionmovestheassociatedfile'scurrentgetpointer
offsetnumberofcharactersfromthespecified
origin,whichmustbeoneofthesethreevalues:
ios::begBeginning-of-file
ios::curCurrent location

ios::endEnd-of-file
Theseekp( )function moves the associated file's current put pointer
offsetnumberof characters from the specified
origin, which must be one of the values just shown.Generally, random-access I/O should be performed only on those files opened for
binary operations. The character translations that may occur on text files could causea position request to be out of sync with the actual contents of the file.
The following program demonstrates the
seekp( )function. It allows you to changea specific character in a file. Specify a filename on the command line, followed by thenumber of the character in the file you want to change, followed by the new character.

Notice that the file is opened for read/write operations.
#include <iostream>#include <fstream>
#include <cstdlib>
using namespace std;int main(int argc, char *argv[]){if(argc!=4) {cout << "Usage: CHANGE <filename> <character> <char>\n";
return 1;}fstream out(argv[1], ios::in | ios::out | ios::binary);if(!out) {cout << "Cannot open file.";
return 1;}out.seekp(atoi(argv[2]), ios::beg);
out.put(*argv[3]);out.close();return 0;}For example, to use this program to change the twelfth character of a file called
TEST to a Z, use this command line:change test 12 ZThe next program uses
seekg( ). It displays the contents of a file beginning with thelocation you specify on the command line.#include <iostream>#include <fstream>558C++:TheCompleteReference
#include <cstdlib>using namespace std;int main(int argc, char *argv[]){char ch;if(argc!=3) {cout << "Usage: SHOW <filename> <starting location>\n";return 1;}ifstream in(argv[1], ios::in | ios::binary);if(!in) {cout << "Cannot open file.";
return 1;}in.seekg(atoi(argv[2]), ios::beg);
while(in.get(ch))cout << ch;return 0;}The following program uses both
seekp( )andseekg( )to reverse the first
<num>characters in a file.#include <iostream>#include <fstream>
#include <cstdlib>
using namespace std;int main(int argc, char *argv[]){if(argc!=3) {cout << "Usage: Reverse <filename> <num>\n";
return 1;}Chapter21:C++FileI/O
559C++fstream inout(argv[1], ios::in | ios::out | ios::binary);if(!inout) {cout << "Cannot open input file.\n";return 1;}long e, i, j;char c1, c2;
e = atol(argv[2]);for(i=0, j=e; i<j; i++, j--) {inout.seekg(i, ios::beg);inout.get(c1);
inout.seekg(j, ios::beg);
inout.get(c2);inout.seekp(i, ios::beg);inout.put(c2);
inout.seekp(j, ios::beg);
inout.put(c1);}inout.close();return 0;}To use the program, specify the name of the file that you want to reverse, followed
by the number of characters to reverse. For example, to reverse the first 10 characters of
a file called TEST, use this command line:
reverse test 10If the file had contained this:This is a test.it will contain the following after the program executes:
a si sihTtest.560C++:TheCompleteReference
Chapter21:C++FileI/O
561C++Obtaining the Current File Position
You can determine the current position of each file pointer by using these functions:
pos_type tellg( );pos_type tellp( );Here,
pos_typeis a type defined byiosthat is capable of holding the largest value that
either function can return. You can use the values returned by
tellg( )andtellp( )asarguments to the following forms of
seekg( )andseekp( ),respectively.
istream &seekg(pos_typepos);ostream &seekp(pos_typepos);These functions allow you to save the current file location, perform other file

operations, and then reset the file location to its previously saved location.
I/O StatusThe C++ I/O system maintains status information about the outcome of each I/O
operation.ThecurrentstateoftheI/Osystemisheldinanobjectoftype
iostate,which is an enumeration defined byiosthat includes the following members.NameMeaning
ios::goodbitNo error bits set
ios::eofbit1 when end-of-file is encountered; 0 otherwise

ios::failbit1 when a (possibly) nonfatal I/O error has occurred;
0 otherwiseios::badbit1 when a fatal I/O error has occurred; 0 otherwise
There are two ways in which you can obtain I/O status information. First, you can
call therdstate( )function. It has this prototype:
iostate rdstate( );It returns the current status of the error flags. As you can probably guess from looking
at the preceding list of flags,
rdstate( )returns
goodbitwhen no error has occurred.
Otherwise, an error flag is turned on.
Thefollowingprogramillustrates
rdstate()
.Itdisplaysthecontentsofatextfile.
Ifanerroroccurs,theprogramreportsit,using
checkstatus()
.#include <iostream>#include <fstream>
using namespace std;void checkstatus(ifstream &in);
int main(int argc, char *argv[]){if(argc!=2) {cout << "Usage: Display <filename>\n";
return 1;}ifstream in(argv[1]);
if(!in) {cout << "Cannot open input file.\n";return 1;}char c;while(in.get(c)) {if(in) cout << c;
checkstatus(in);}checkstatus(in);  // check final statusin.close();
return 0;}void checkstatus(ifstream &in){ios::iostate i;i = in.rdstate();
if(i & ios::eofbit)cout << "EOF encountered\n";562C++:TheCompleteReference
Chapter21:C++FileI/O
563C++else if(i & ios::failbit)cout << "Non-Fatal I/O error\n";else if(i & ios::badbit)cout << "Fatal I/O error\n";}This program will always report one "error." After the
whileloop ends, the final calltocheckstatus()
reports,asexpected,thatan
EOFhasbeenencountered.Youmightfind
thecheckstatus( )function useful in programs that you write.
The other way that you can determine if an error has occurred is by using one or
more of these functions:
bool bad( );bool eof( );
bool fail( );
bool good( );Thebad( )function returns true if
badbitis set. Theeof( )function was discussedearlier. The
fail( )returns true if
failbitis set. Thegood( )function returns true if there
are no errors. Otherwise, it returns false.
Onceanerrorhasoccurred,itmayneedtobeclearedbeforeyourprogramcontinues.
To do this, use the
clear( )function, which has this prototype:
void clear(iostateflags=ios::goodbit);Ifflagsisgoodbit(as it is by default), all error flags are cleared. Otherwise, set
flagsasyou desire.
Customized I/O and FilesInChapter20youlearnedhowtooverloadtheinsertionandextractionoperators
relativetoyourownclasses.Inthatchapter,onlyconsoleI/Owasperformed,but

becauseallC++streamsarethesame,youcanusethesameoverloadedinserteror

extractor function to perform I/O on the console or a file with no changes whatsoever.

As an example, the following program reworks the phone book example in Chapter 20

so that it stores a list on disk. The program is very simple: It allows you to add names

to the list or to display the list on the screen. It uses custom inserters and extractors to

input and output the telephone numbers. You might find it interesting to enhance the

program so that it will find a specific number or delete unwanted numbers.
#include <iostream>#include <fstream>
#include <cstring>
using namespace std;class phonebook {char name[80];char areacode[4];
char prefix[4];
char num[5];public:phonebook() { };
phonebook(char *n, char *a, char *p, char *nm)
{strcpy(name, n);
strcpy(areacode, a);
strcpy(prefix, p);
strcpy(num, nm);}
friend ostream &operator<<(ostream &stream, phonebook o);
friend istream &operator>>(istream &stream, phonebook &o);};// Display name and phone number.ostream &operator<<(ostream &stream, phonebook o)
{stream << o.name << " ";
stream << "(" << o.areacode << ") ";
stream << o.prefix << "-";
stream << o.num << "\n";
return stream; // must return stream}// Input name and telephone number.istream &operator>>(istream &stream, phonebook &o)
{cout << "Enter name: ";
stream >> o.name;
cout << "Enter area code: ";
stream >> o.areacode;
cout << "Enter prefix: ";
stream >> o.prefix;
cout << "Enter number: ";564C++:TheCompleteReference
stream >> o.num;cout << "\n";
return stream;}int main(){phonebook a;
char c;fstream pb("phone", ios::in | ios::out | ios::app);
if(!pb) {cout << "Cannot open phone book file.\n";return 1;}for(;;) {do {cout << "1. Enter numbers\n";cout << "2. Display numbers\n";
cout << "3. Quit\n";
cout << "\nEnter a choice: ";
cin >> c;} while(c<'1' || c>'3');switch(c) {case '1':cin >> a;cout << "Entry is: ";
cout << a;  // show on screen
pb << a;  // write to disk
break;case '2':char ch;
pb.seekg(0, ios::beg);
while(!pb.eof()) {pb.get(ch);
if(!pb.eof()) cout << ch;}
pb.clear();  // reset eof
cout << endl;Chapter21:C++FileI/O
565C++break;case '3':pb.close();return 0;}}}Notice that the overloaded<<operator can be used to write to a disk file or to thescreen without any changes. This is one of the most important and useful features of
C++'s approach to I/O.
566C++:TheCompleteReference
Chapter22
Run-Time Type ID and
the Casting Operators567Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
568C++:TheCompleteReference
Standard C++ contains two features that help support modern, object-orientedprogramming: run-time type identification (RTTI for short) and a set of four
additionalcastingoperators.Neitherofthesewerepartoftheoriginalspecification
forC++,butbothwereaddedtoprovideenhancedsupportforrun-timepolymorphism.

RTTIallowsyoutoidentifythetypeofanobjectduringtheexecutionofyourprogram.

The casting operators give you safer, more controlled ways to cast. Since one of the
castingoperators,
dynamic_cast,relatesdirectlytoRTTI,itmakessensetodiscussthem
inthesamechapter.
Run-Time Type Identification (RTTI)
Run-timetypeinformationmaybenewtoyoubecauseitisnotfoundinnonpoly-

morphiclanguages,suchasC.Innonpolymorphiclanguagesthereisnoneedfor

run-time type information because the type of each object is known at compile time

(i.e., when the program is written). However, in polymorphic languages such as C++,

therecanbesituationsinwhichthetypeofanobjectisunknownatcompiletimebecause

theprecisenatureofthatobjectisnotdetermineduntiltheprogramisexecuted.As

explainedinChapter17,C++implementspolymorphismthroughtheuseofclass

hierarchies, virtual functions, and base-class pointers. Since base-class pointers may be

usedtopointtoobjectsofthebaseclassor
anyobjectderivedfromthatbase
,itisnotalways
possible to know in advance what type of object will be pointed to by a base pointer at
anygivenmomentintime.Thisdeterminationmustbemadeatruntime,usingrun-time

type identification.To obtain an object's type, use
typeid. You must include the header <
typeinfo>inorder to use
typeid. Its most commonly used form is shown here:
typeid(object)Here,
objectis the object whose type you will be obtaining. It may be of any type,including the built-in types and class types that you create.
typeidreturns a reference
to an object of typetype_infothat describes the type ofobject.Thetype_infoclass defines the following public members:bool operator==(const type_info &ob);
bool operator!=(const type_info &ob);
bool before(const type_info &ob);
const char *name( );The overloaded==and!=provide for the comparison of types. The
before( )function returns true if the invoking object is before the object used as a parameter
in collation order. (This function is mostly for internal use only. Its return value has
Chapter22:Run-TimeTypeIDandtheCastingOperators
569C++nothing to do with inheritance or class hierarchies.) The
name( )function returns
a pointer to the name of the type.Here is a simple example that uses
typeid.// A simple example that uses typeid.#include <iostream>
#include <typeinfo>
using namespace std;class myclass1 {// ...};
class myclass2 {// ...};
int main(){int i, j;
float f;
char *p;
myclass1 ob1;
myclass2 ob2;cout << "The type of i is: " << typeid(i).name();cout << endl;
cout << "The type of f is: " << typeid(f).name();
cout << endl;
cout << "The type of p is: " << typeid(p).name();
cout << endl;cout << "The type of ob1 is: " << typeid(ob1).name();cout << endl;
cout << "The type of ob2 is: " << typeid(ob2).name();
cout << "\n\n";if(typeid(i) == typeid(j))cout << "The types of i and j are the same\n";if(typeid(i) != typeid(f))cout << "The types of i and f are not the same\n";570C++:TheCompleteReference
if(typeid(ob1) != typeid(ob2))cout << "ob1 and ob2 are of differing types\n";return 0;}The output produced by this program is shown here:
The type of i is: intThe type of f is: float
The type of p is: char *
The type of ob1 is: class myclass1
The type of ob2 is: class myclass2The types of i and j are the sameThe types of i and f are not the same
ob1 and ob2 are of differing typesThe most important use oftypeidoccurs when it is applied through a pointer of a
polymorphic base class. In this case, it will automatically return the type of the actual
object being pointed to, which may be a base-class object or an object derived from that

base.(Remember,abase-classpointercanpointtoobjectsofthebaseclassorofanyclass

derived from that base.) Thus, using
typeid, you can determine at run time the type
of the object that is being pointed to by a base-class pointer. The following program

demonstrates this principle.//Anexamplethatusestypeidonapolymorphicclasshierarchy.
#include<iostream>

#include<typeinfo>

usingnamespacestd;
classMammal{
public:virtualboollays_eggs(){returnfalse;}//Mammalispolymorphic

//...
};classCat:publicMammal{
public://...
};classPlatypus:publicMammal{
public:boollays_eggs(){returntrue;}

//...
};intmain()
{Mammal*p,AnyMammal;

Catcat;

Platypusplatypus;
p=&AnyMammal;
cout<<"pispointingtoanobjectoftype";

cout<<typeid(*p).name()<<endl;
p=&cat;
cout<<"pispointingtoanobjectoftype";

cout<<typeid(*p).name()<<endl;
p=&platypus;
cout<<"pispointingtoanobjectoftype";

cout<<typeid(*p).name()<<endl;
return0;
}The output produced by this program is shown here:
p is pointing to an object of type class Mammalp is pointing to an object of type class Cat
p is pointing to an object of type class PlatypusAs explained, whentypeidis applied to a base-class pointer of a polymorphic type,the type of object pointed to will be determined at run time, as shown by the output
produced by the program.
Inallcases,when
typeidisappliedtoapointerofanonpolymorphicclasshierarchy,
then the base type of the pointer is obtained. That is, no determination of what that
pointer is actually pointing to is made. For example, comment out thevirtualkeyword
Chapter22:Run-TimeTypeIDandtheCastingOperators
571C++572C++:TheCompleteReference
before the function
lays_eggs( )inMammaland then compile and run the program.
You will see the following output.
p is pointing to an object of type class Mammalp is pointing to an object of type class Mammal
p is pointing to an object of type class MammalSinceMammalis no longer a polymorphic class, the type of each object will beMammalbecause that is the type of the pointer.
Sincetypeidis commonly applied to a dereferenced pointer (i.e., one to which the *
operator has been applied), a special exception has been created to handle the situation
in which the pointer being dereferenced is null. In this case,
typeidthrows
bad_typeid.References to an object of a polymorphic class hierarchy work the same as pointers.
Whentypeidis applied to a reference to an object of a polymorphic class, it will return
the type of the object actually being referred to, which may be of a derived type. The

circumstance where you will most often make use of this feature is when objects are

passed to functions by reference. For example, in the following program, the function

WhatMammal()
declaresareferenceparametertoobjectsoftype
Mammal.This
meansthat
WhatMammal()
canbepassedreferencestoobjectsoftype
Mammaloranyclassderivedfrom
Mammal.Whenthe
typeidoperatorisappliedtothis
parameter,itreturnstheactualtypeoftheobjectbeingpassed.
//Useareferencewithtypeid.
#include<iostream>

#include<typeinfo>

usingnamespacestd;
classMammal{
public:virtualboollays_eggs(){returnfalse;}//Mammalispolymorphic

//...
};classCat:publicMammal{
public://...
};classPlatypus:publicMammal{
public:Chapter22:Run-TimeTypeIDandtheCastingOperators
573C++boollays_eggs(){returntrue;}
//...
};//Demonstratetypeidwithareferenceparameter.
voidWhatMammal(Mammal&ob)

{cout<<"obisreferencinganobjectoftype";
cout<<typeid(ob).name()<<endl;
}intmain()
{MammalAnyMammal;

Catcat;

Platypusplatypus;
WhatMammal(AnyMammal);WhatMammal(cat);
WhatMammal(platypus);return0;
}The output produced by this program is shown here:
ob is referencing an object of type class Mammalob is referencing an object of type class Cat
ob is referencing an object of type class PlatypusThere is a second form of
typeidthat takes a type name as its argument. This form
is shown here:
typeid(type-name)For example, the following statement is perfectly acceptable:cout << typeid(int).name();The main use of this form oftypeidis to obtain atype_infoobject that describes thespecified type so that it can be used in a type comparison statement. For example, thisform ofWhatMammal( )reports that cats don't like water:
void WhatMammal(Mammal &ob){cout << "ob is referencing an object of type ";
cout << typeid(ob).name() << endl;
if(typeid(ob) == typeid(Cat))cout << "Cats don't like water.\n";}ASimple Application of Run-Time Type ID
The following program hints at the power of RTTI. In the program, the function called
factory( )creates instances of various types of objects derived from the class
Mammal.(Afunctionthatproducesobjectsissometimescalledan
objectfactory
.)Thespecific
type of object created is determined by the outcome of a call to
rand( ), C++'s randomnumber generator. Thus, there is no way to know in advance what type of object will

be generated. The program creates 10 objects and counts the number of each type of

mammal.Sinceanytypeofmammalmaybegeneratedbyacallto
factory()
,theprogramr
eliesupontypeidto determine which type of object has actually been made.//Demonstratingrun-timetypeid.
#include<iostream>

usingnamespacestd;
classMammal{
public:virtualboollays_eggs(){returnfalse;}//Mammalispolymorphic

//...
};classCat:publicMammal{
public://...
};classPlatypus:publicMammal{
public:boollays_eggs(){returntrue;}

//...
574C++:TheCompleteReference
Chapter22:Run-TimeTypeIDandtheCastingOperators
575C++};classDog:publicMammal{
public://...
};//AfactoryforobjectsderivedfromMammal.
Mammal*factory()

{switch(rand()%3){case0:returnnewDog;

case1:returnnewCat;

case2:returnnewPlatypus;
}
return0;
}intmain()
{Mammal*ptr;//pointertobaseclass

inti;

intc=0,d=0,p=0;
//generateandcountobjects
for(i=0;i<10;i++){
ptr=factory();//generateanobject
cout<<"Objectis"<<typeid(*ptr).name();
cout<<endl;
//countit
if(typeid(*ptr)==typeid(Dog))d++;

if(typeid(*ptr)==typeid(Cat))c++;

if(typeid(*ptr)==typeid(Platypus))p++;
}cout<<endl;
cout<<"Animalsgenerated:\n";

cout<<"Dogs:"<<d<<endl;

cout<<"Cats:"<<c<<endl;
576C++:TheCompleteReference
cout<<"Platypuses:"<<p<<endl;
return0;
}Sample output is shown here.
Object is class PlatypusObject is class Platypus
Object is class Cat
Object is class Cat
Object is class Platypus
Object is class Cat
Object is class Dog
Object is class Dog
Object is class Cat
Object is class PlatypusAnimals generated:Dogs: 2Cats: 4
Platypuses: 4typeid Can Be Applied to Template Classes
Thetypeidoperator can be applied to template classes. The type of an object that is aninstanceofatemplateclassisinpartdeterminedbywhatdataisusedforitsgeneric
data when the object is instantiated. Two instances of the same template class that are

created using different data are therefore different types. Here is a simple example:
// Using typeid with templates.#include <iostream>
using namespace std;template <class T> class myclass {T a;public:myclass(T i) { a = i; }// ...};int main(){myclass<int> o1(10), o2(9);myclass<double> o3(7.2);cout << "Type of o1 is ";cout << typeid(o1).name() << endl;cout << "Type of o2 is ";cout << typeid(o2).name() << endl;cout << "Type of o3 is ";cout << typeid(o3).name() << endl;cout << endl;
if(typeid(o1) == typeid(o2))cout << "o1 and o2 are the same type\n";if(typeid(o1) == typeid(o3))cout << "Error\n";elsecout << "o1 and o3 are different types\n";return 0;}The output produced by this program is shown here.
Type of o1 is class myclass<int>Type of o2 is class myclass<int>
Type of o3 is class myclass<double>o1 and o2 are the same typeo1 and o3 are different typesAs you can see, even though two objects are of the same template class type, if their
parameterized data does not match, they are not equivalent types. In the program,

o1isoftype
myclass<int>ando3isoftype
myclass<double>.Thus,theyareof
differenttypes.
Chapter22:Run-TimeTypeIDandtheCastingOperators
577C++Run-timetypeidentificationisnotsomethingthateveryprogramwilluse.However,
whenyou are working with polymorphic types, it allows you to know what type of object is
being operated upon in any given situation.The Casting OperatorsC++ defines five casting operators. The first is the traditional-style cast inherited from

C. The remaining four were added a few years ago. They are
dynamic_cast,const_cast,reinterpret_cast, andstatic_cast.These operators give you additional control over how
casting takes place.dynamic_castPerhapsthemostimportantofthenewcastingoperatorsis
dynamic_cast.The
dynamic_castperforms a run-time cast that verifies the validity of a cast. If the cast
is invalid at the timedynamic_castis executed, then the cast fails. The general formofdynamic_castis shown here:
dynamic_cast<target-type> (expr)Here,
target-type
specifies the target type of the cast, and
expris the expression being
cast into the new type. The target type must be a pointer or reference type, and the

expression being cast must evaluate to a pointer or reference. Thus,
dynamic_castmaybe used to cast one type of pointer into another or one type of reference into another.
Thepurposeof
dynamic_castistoperformcastsonpolymorphictypes.Forexample,
given two polymorphic classes B and D, with D derived from B, a
dynamic_castcanalwayscastaD*pointerintoaB*pointer.Thisisbecauseabasepointercanalwayspoint

to a derived object. But adynamic_castcan cast a B* pointer into a D* pointer only ifthe object being pointed toactuallyis
a D object. In general,dynamic_castwill succeedif the pointer (or reference) being cast is a pointer (or reference) to either an object of the

targettypeoranobjectderivedfromthetargettype.Otherwise,thecastwillfail.Ifthecast

fails,then
dynamic_castevaluatestonullifthecastinvolvespointers.Ifa
dynamic_caston reference types fails, a
bad_castexception is thrown.
Here is a simple example. Assume that
Baseis a polymorphic class and thatDerivedis derived from
Base.Base *bp, b_ob;Derived *dp, d_ob;bp = &d_ob; // base pointer points to Derived object578C++:TheCompleteReference
dp = dynamic_cast<Derived *> (bp); // cast to derived pointer OKif(dp) cout << "Cast OK";Here, the cast from the base pointer
bpto the derived pointerdpworks becausebpisactually pointing to aDerivedobject. Thus, this fragment displaysCast OK. But in thenext fragment, the cast fails becausebpis pointing to aBaseobject and it is illegal tocast a base object into a derived object.bp = &b_ob; // base pointer points to Base objectdp = dynamic_cast<Derived *> (bp); // error
if(!dp) cout << "Cast Fails";Because the cast fails, this fragment displaysCast Fails.The following program demonstrates the various situations that
dynamic_castcanhandle.// Demonstrate dynamic_cast.
#include <iostream>
using namespace std;class Base {public:virtual void f() { cout << "Inside Base\n"; }
// ...};class Derived : public Base {public:void f() { cout << "Inside Derived\n"; }};int main(){Base *bp, b_ob;
Derived *dp, d_ob;dp = dynamic_cast<Derived *> (&d_ob);if(dp) {cout << "Cast from Derived * to Derived * OK.\n";
dp->f();} elseChapter22:Run-TimeTypeIDandtheCastingOperators
579C++cout << "Error\n";cout << endl;bp = dynamic_cast<Base *> (&d_ob);if(bp) {cout << "Cast from Derived * to Base * OK.\n";bp->f();} elsecout << "Error\n";cout << endl;bp = dynamic_cast<Base *> (&b_ob);if(bp) {cout << "Cast from Base * to Base * OK.\n";
bp->f();} elsecout << "Error\n";cout << endl;dp = dynamic_cast<Derived *> (&b_ob);if(dp)cout << "Error\n";elsecout << "Cast from Base * to Derived * not OK.\n";cout << endl;bp = &d_ob; // bp points to Derived objectdp = dynamic_cast<Derived *> (bp);
if(dp) {cout << "Casting bp to a Derived * OK\n" <<"because bp is really pointing\n" <<
"to a Derived object.\n";dp->f();} elsecout << "Error\n";cout << endl;580C++:TheCompleteReference
bp = &b_ob; // bp points to Base objectdp = dynamic_cast<Derived *> (bp);
if(dp)cout << "Error";else {cout << "Now casting bp to a Derived *\n" <<"is not OK because bp is really \n" <<"pointing to a Base object.\n";}cout << endl;
dp = &d_ob; // dp points to Derived objectbp = dynamic_cast<Base *> (dp);
if(bp) {cout << "Casting dp to a Base * is OK.\n";
bp->f();} elsecout << "Error\n";return 0;}The program produces the following output:
Cast from Derived * to Derived * OK.
Inside DerivedCast from Derived * to Base * OK.Inside DerivedCast from Base * to Base * OK.Inside BaseCast from Base * to Derived * not OK.
Casting bp to a Derived * OKbecause bp is really pointing
to a Derived object.
Inside DerivedChapter22:Run-TimeTypeIDandtheCastingOperators
581C++582C++:TheCompleteReference
Now casting bp to a Derived *is not OK because bp is really
pointing to a Base object.Casting dp to a Base * is OK.Inside DerivedReplacing typeid with dynamic_castThedynamic_castoperator can sometimes be used instead oftypeidin certain cases.Forexample,againassumethat
Baseisapolymorphicbaseclassfor
Derived.The
followingfragmentwillassign
dptheaddressoftheobjectpointedtoby
bpifand
onlyiftheobjectreallyisa
Derivedobject.Base *bp;Derived *dp;
// ...
if(typeid(*bp) == typeid(Derived)) dp = (Derived *) bp;In this case, a traditional-style cast is used to actually perform the cast. This is safebecause theifstatement checks the legality of the cast usingtypeidbefore the cast
actually occurs. However, a better way to accomplish this is to replace the
typeidoperators andifstatement with thisdynamic_cast.dp = dynamic_cast<Derived *> (bp);Sincedynamic_castsucceeds only if the object being cast is either an object of thetarget type or an object derived from the target type, after this statement executes
dpwill contain either a null or a pointer to an object of typeDerived. Sincedynamic_castsucceedsonlyifthecastislegal,itcansimplifythelogicincertainsituations.The

following program illustrates how a
dynamic_castcan be used to replace
typeid. Itperformsthesamesetofoperationstwice—firstwith
typeid,thenusing
dynamic_cast.// Use dynamic_cast to replace typeid.#include <iostream>
#include <typeinfo>
using namespace std;class Base {public:Chapter22:Run-TimeTypeIDandtheCastingOperators
583C++virtual void f() {}};class Derived : public Base {public:void derivedOnly() {cout << "Is a Derived Object.\n";}};int main(){Base *bp, b_ob;
Derived *dp, d_ob;// ************************************// use typeid
// ************************************
bp = &b_ob;
if(typeid(*bp) == typeid(Derived)) {dp = (Derived *) bp;
dp->derivedOnly();}
elsecout << "Cast from Base to Derived failed.\n";bp = &d_ob;
if(typeid(*bp) == typeid(Derived)) {dp = (Derived *) bp;
dp->derivedOnly();}
elsecout << "Error, cast should work!\n";// ************************************
// use dynamic_cast
// ************************************
bp = &b_ob;
dp = dynamic_cast<Derived *> (bp);
if(dp) dp->derivedOnly();
elsecout << "Cast from Base to Derived failed.\n";584C++:TheCompleteReference
bp = &d_ob;dp = dynamic_cast<Derived *> (bp);
if(dp) dp->derivedOnly();
elsecout << "Error, cast should work!\n";return 0;}As you can see, the use ofdynamic_castsimplifies the logic required to cast a base
pointer into a derived pointer. The output from the program is shown here:
Cast from Base to Derived failed.Is a Derived Object.
Cast from Base to Derived failed.
Is a Derived Object.Using dynamic_cast with Template Classes
Thedynamic_castoperator can also be used with template classes. For example,// Demonstrate dynamic_cast on template classes.
#include <iostream>
using namespace std;template <class T> class Num {protected:T val;public:Num(T x) { val = x; }
virtual T getval() { return val; }
// ...};template <class T> class SqrNum : public Num<T> {public:SqrNum(T x) : Num<T>(x) { }
T getval() { return val * val; }};int main(){Num<int> *bp, numInt_ob(2);SqrNum<int> *dp, sqrInt_ob(3);
Num<double> numDouble_ob(3.3);bp = dynamic_cast<Num<int> *> (&sqrInt_ob);if(bp) {cout << "Cast from SqrNum<int>* to Num<int>* OK.\n";
cout << "Value is " << bp->getval() << endl;} elsecout << "Error\n";cout << endl;dp = dynamic_cast<SqrNum<int> *> (&numInt_ob);if(dp)cout << "Error\n";else {cout << "Cast from Num<int>* to SqrNum<int>* not OK.\n";
cout << "Can't cast a pointer to a base object into\n";
cout << "a pointer to a derived object.\n";}
cout << endl;bp = dynamic_cast<Num<int> *> (&numDouble_ob);if(bp)cout << "Error\n";elsecout << "Can't cast from Num<double>* to Num<int>*.\n";
cout << "These are two different types.\n";return 0;}The output from this program is shown here:
Cast from SqrNum<int>* to Num<int>* OK.
Value is 9Cast from Num<int>* to SqrNum<int>* not OK.Chapter22:Run-TimeTypeIDandtheCastingOperators
585C++586C++:TheCompleteReference
Can't cast a pointer to a base object intoa pointer to a derived object.Can't cast from Num<double>* to Num<int>*.These are two different types.Akey point illustrated by this example is that it is not possible to use
dynamic_castto cast a pointer to one type of template instantiation into a pointer to another type ofinstance. Remember, the precise type of an object of a template class is determined by

the type of data used to create an instance of the template. Thus,
Num<double>andNum<int>are two different types.
const_castTheconst_castoperator is used to explicitly overrideconstand/orvolatilein a cast.The target type must be the same as the source type except for the alteration of its
constorvolatileattributes. The most common use ofconst_castis to remove
const-ness. Thegeneral form ofconst_castis shown here.
const_cast<type> (expr)Here,
typespecifies the target type of the cast, and
expris the expression being cast into
the new type.The following program demonstrates
const_cast.// Demonstrate const_cast.#include <iostream>
using namespace std;void sqrval(const int *val){int *p;// cast away const-ness.p = const_cast<int *> (val);*p = *val * *val; // now, modify object through v}
int main(){int x = 10;cout << "x before call: " << x << endl;sqrval(&x);
cout << "x after call: " << x << endl;return 0;}The output produced by this program is shown here:
x before call: 10x after call: 100As you can see,xwas modified bysqrval( )even though the parameter tosqrval( )wasspecified as aconstpointer.
const_castcan also be used to cast awayconst-ness from a
constreference. For
example, here is the preceding program reworked so that the value being squared is
passed as aconstreference.
// Use const_cast on a const reference.#include <iostream>
using namespace std;void sqrval(const int &val){// cast away const on val
const_cast<int &> (val) = val * val;}int main(){int x = 10;cout << "x before call: " << x << endl;sqrval(x);
cout << "x after call: " << x << endl;return 0;}Chapter22:Run-TimeTypeIDandtheCastingOperators
587C++588C++:TheCompleteReference
This program produces the same output as before. Again, it works only because the
const_casttemporarily removes the
constattribute from
val, allowing it to be used toassign a new value to the calling argument (in this case,
x).It must be stressed that the use of
const_castto cast wayconst-ness is a potentiallydangerous feature. Use it with care.
One other point: Onlyconst_castcan cast awayconst-ness. That is, neitherdynamic_cast, static_castnorreinterpret_castcan alter theconst-ness of an object.static_castThestatic_castoperator performs a nonpolymorphic cast. It can be used for anystandard conversion. No run-time checks are performed. Its general form is
static_cast<type> (expr)Here,
typespecifies the target type of the cast, and
expris the expression being cast into
the new type.Thestatic_castoperator is essentially a substitute for the original cast operator. It
simply performs a nonpolymorphic cast. For example, the following casts anintvalueinto adouble.// Use static_cast.#include <iostream>
using namespace std;int main(){int i;for(i=0; i<10; i++)cout << static_cast<double> (i) / 3 << " ";return 0;}reinterpret_cast
Thereinterpret_castoperator converts one type into a fundamentally different type.
Forexample,itcanchangeapointerintoanintegerandanintegerintoapointer.It
can also be used for casting inherently incompatible pointer types. Its general form is
reinterpret_cast<type>(expr)Here,
typespecifies the target type of the cast, and
expris the expression being cast into
the new type.The following program demonstrates the use of
reinterpret_cast:// An example that uses reinterpret_cast.#include <iostream>
using namespace std;int main(){int i;
char *p = "This is a string";i = reinterpret_cast<int> (p); // cast pointer to integer
cout << i;
return 0;}Here,
reinterpret_castconverts the pointerpinto an integer. This conversion represents
a fundamental type change and is a good use ofreinterpret_cast.Chapter22:Run-TimeTypeIDandtheCastingOperators
589C++This page intentionally left blank Chapter23
Namespaces,Conversion Functions,
and Other Advanced Topics
591Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
592C++:TheCompleteReference
This chapter describes namespaces and several other advanced features, includingconversion functions, explicit constructors,constandvolatilemember functions,theasmkeyword, and linkage specifications. It ends with a discussion of C++'sarray-based I/O and a summary of the differences between C and C++.NamespacesNamespaces were briefly introduced earlier in this book. They are a relatively recent

addition to C++. Their purpose is to localize the names of identifiers to avoid name
collisions.TheC++programmingenvironmenthasseenanexplosionofvariable,

function,andclassnames.Priortotheinventionofnamespaces,allofthesenames

competed for slots in the global namespace and many conflicts arose. For example, if

your program defined a function called
abs( ), it could (depending upon its parameterlist) override the standard library function
abs( )because both names would be stored
intheglobalnamespace.Namecollisionswerecompoundedwhentwoormore

third-party libraries were used by the same program. In this case, it was possible—

even likely—that a name defined by one library would conflict with the same name
defined by the other library. The situation can be particularly troublesome for class

names. For example, if your program defines a class call
ThreeDCircleand a libraryused by your program defines a class by the same name, a conflict will arise.
The creation of the
namespacekeyword was a response to these problems. Because
itlocalizesthevisibilityofnamesdeclaredwithinit,anamespaceallowsthesamename

to be used in different contexts without conflicts arising. Perhaps the most noticeable

beneficiary ofnamespaceis the C++ standard library. Prior to
namespace, the entire
C++ library was defined within the global namespace (which was, of course, the only
namespace). Since the addition ofnamespace, the C++ library is now defined withinits own namespace, calledstd, which reduces the chance of name collisions. You can
also create your own namespaces within your program to localize the visibility of any

namesthatyouthinkmaycauseconflicts.Thisisespeciallyimportantifyouarecreating

class or function libraries.Namespace FundamentalsThenamespacekeyword allows you to partition the global namespace by creating
a declarative region. In essence, a
namespacedefines a scope. The general form ofnamespaceis shown here:
namespacename{//declarations}C++Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
593Anything defined within anamespacestatement is within the scope of that namespace.Here is an example of a
namespace. It localizes the names used to implement asimple countdown counter class. In the namespace are defined the
counterclass, whichimplementsthecounter,andthevariables
upperboundandlowerbound,whichcontain
the upper and lower bounds that apply to all counters.
namespace CounterNameSpace {int upperbound;int lowerbound;class counter {int count;public:counter(int n) {if(n <= upperbound) count = n;else count = upperbound;}void reset(int n) {if(n <= upperbound) count = n;}
int run() {if(count > lowerbound) return count--;else return lowerbound;}};}Here,
upperbound,lowerbound, and the classcounterare part of the scope defined by
theCounterNameSpacenamespace.Inside a namespace, identifiers declared within that namespace can be referred to
directly,withoutanynamespacequalification.Forexample,within
CounterNameSpace,therun( )function can refer directly to
lowerboundin the statementif(count > lowerbound) return count--;However, since
namespacedefines a scope, you need to use the scope resolution
operator to refer to objects declared within a namespace from outside that namespace.
594C++:TheCompleteReference
For example, to assign the value 10 toupperboundfrom code outside
CounterNameSpace,you must use this statement:
CounterNameSpace::upperbound = 10;Or to declare an object of type
counterfrom outside
CounterNameSpace, you will usea statement like this:CounterNameSpace::counter ob;In general, to access a member of a namespace from outside its namespace, precede
the member's name with the name of the namespace followed by the scope resolution

operator.
Here is a program that demonstrates the use of
CounterNameSpace.// Demonstrate a namespace.#include <iostream>
using namespace std;namespace CounterNameSpace {int upperbound;int lowerbound;class counter {int count;public:counter(int n) {if(n <= upperbound) count = n;else count = upperbound;}void reset(int n) {if(n <= upperbound) count = n;}
int run() {if(count > lowerbound) return count--;else return lowerbound;}};}int main(){CounterNameSpace::upperbound = 100;CounterNameSpace::lowerbound = 0;CounterNameSpace::counter ob1(10);int i;do {i = ob1.run();cout << i << " ";} while(i > CounterNameSpace::lowerbound);
cout << endl;CounterNameSpace::counter ob2(20);
do {i = ob2.run();cout << i << " ";} while(i > CounterNameSpace::lowerbound);
cout << endl;ob2.reset(100);CounterNameSpace::lowerbound = 90;
do {i = ob2.run();
cout << i << " ";} while(i > CounterNameSpace::lowerbound);return 0;}Noticethatthedeclarationofa
counterobjectandthereferencesto
upperboundandlowerboundare qualified by
CounterNameSpace. However, once an object of
typecounterhas been declared, it is not necessary to further qualify it or any of its
members. Thus,ob1.run( )can be called directly; the namespace has already been
resolved.
Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
595C++usingAsyoucanimagine,ifyourprogramincludesfrequentreferencestothemembers
ofanamespace,havingtospecifythenamespaceandthescoperesolutionoperator

eachtimeyouneedtorefertoonequicklybecomesatediouschore.The
usingstatementwasinventedtoalleviatethisproblem.The
usingstatementhasthese
twogeneralforms:
using namespacename;usingname::member;In the first form,namespecifies the name of the namespace you want to access. All ofthe members defined within the specified namespace are brought into view (i.e., they

become part of the current namespace) and may be used without qualification. In the

second form, only a specific member of the namespace is made visible. For example,
assumingCounterNameSpaceas shown above, the followingusingstatements andassignments are valid.
using CounterNameSpace::lowerbound; // only lowerbound is visiblelowerbound = 10; // OK because lowerbound is visibleusing namespace CounterNameSpace; // all members are visibleupperbound = 100; // OK because all members are now visibleThe following program illustrates
usingby reworking the counter example from
the previous section.
// Demonstrate using.
#include <iostream>
using namespace std;namespace CounterNameSpace {int upperbound;int lowerbound;class counter {int count;public:counter(int n) {if(n <= upperbound) count = n;else count = upperbound;}596C++:TheCompleteReference
Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
597C++void reset(int n) {if(n <= upperbound) count = n;}int run() {if(count > lowerbound) return count--;else return lowerbound;}};}int main(){// use only upperbound from CounterNameSpace
using CounterNameSpace::upperbound;// now, no qualification needed to set upperboundupperbound = 100;// qualification still needed for lowerbound, etc.CounterNameSpace::lowerbound = 0;CounterNameSpace::counter ob1(10);int i;do {i = ob1.run();cout << i << " ";} while(i > CounterNameSpace::lowerbound);
cout << endl;// now, use entire CounterNameSpaceusing namespace CounterNameSpace;counter ob2(20);
do {i = ob2.run();cout << i << " ";} while(i > lowerbound);
cout << endl;ob2.reset(100);598C++:TheCompleteReference
lowerbound = 90;do {i = ob2.run();cout << i << " ";} while(i > lowerbound);return 0;}The program illustrates one other important point: using one namespace does not
override another. When you bring a namespace into view, it simply adds its names

to whatever other namespaces are currently in effect. Thus, by the end of the program,

bothstdandCounterNameSpacehave been added to the global namespace.Unnamed NamespacesThere is a special type of namespace, called an
unnamed namespace,that allows you tocreate identifiers that are unique within a file. Unnamed namespaces are also called

anonymousnamespaces
. They have this general form:namespace{
//declarations}Unnamed namespaces allow you to establish unique identifiers that are known only

within the scope of a single file. That is, within the file that contains the unnamed
namespace,themembersofthatnamespacemaybeuseddirectly,withoutqualification.

But outside the file, the identifiers are unknown.
Unnamed namespaces eliminate the need for certain uses of thestaticstorage classmodifier. As explained in Chapter 2, one way to restrict the scope of a global name to

the file in which it is declared is to use
static. For example, consider the following twofiles that are part of the same program.
File OneFile Two
static int k;
void f1() {k = 99; // OK}extern int k;
void f2() {k = 10; // error}Becausekis defined in File One, it may be used in File One. In File Two,
kis specifiedasextern,whichmeansthatitsnameandtypeareknownbutthat
kitselfisnotactually
Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
599C++defined. When these two files are linked, the attempt to use
kwithin File Two results in
an error because there is no definition for
k. By preceding
kwithstaticin File One, itsscope is restricted to that file and it is not available to File Two.
While the use ofstaticglobal declarations is still allowed in C++, a better way toaccomplish the same effect is to use an unnamed namespace. For example:
File OneFile Two
namespace {int k;}void f1() {k = 99; // OK}extern int k;
void f2() {k = 10; // error}Here,
kis also restricted to File One. The use of the unnamed namespace rather than
staticis recommended for new code.
Some Namespace OptionsThere may be more than one namespace declaration of the same name. This allows

a namespace to be split over several files or even separated within the same file.
For example:#include <iostream>using namespace std;namespace NS {int i;}
// ...
namespace NS {int j;}
int main(){NS::i = NS::j = 10;// refer to NS specificallycout << NS::i * NS::j << "\n";// use NS namespaceusing namespace NS;cout << i * j;
return 0;}This program produces the following output:
100100Here,
NSis split into two pieces. However, the contents of each piece are still within
the same namespace, that is,NS.Anamespace must be declared outside of all other scopes. This means that you
cannot declare namespaces that are localized to a function, for example. There is,
however, one exception: a namespace can be nested within another. Consider
this program:
#include <iostream>using namespace std;namespace NS1 {int i;namespace NS2 { // a nested namespaceint j;}}int main(){NS1::i = 19;
// NS2::j = 10; Error, NS2 is not in view
NS1::NS2::j = 10; // this is rightcout << NS1::i << " "<<  NS1::NS2::j << "\n";
// use NS1600C++:TheCompleteReference
using namespace NS1;/* Now that NS1 is in view, NS2 can be used torefer to j. */cout << i * NS2::j;
return 0;}This program produces the following output:
19 10190Here, the namespace
NS2is nested withinNS1. Thus, when the program begins, to
refer to
j, you must qualify it with both theNS1andNS2namespaces.NS2by itselfis insufficient. After the statement
using namespace NS1;executes, you can refer directly to
NS2since theusingstatement bringsNS1into view.
Typically, you will not need to create namespaces for most small to medium-sized
programs. However, if you will be creating libraries of reusable code or it you want to
ensure the widest portability, then consider wrapping your code within a namespace.
The std NamespaceStandard C++ defines its entire library in its own namespace called
std. This is thereason that most of the programs in this book include the following statement:
using namespace std;This causes thestdnamespace to be brought into the current namespace, which gives
you direct access to the names of the functions and classes defined within the library

without having to qualify each one withstd::.Of course, you can explicitly qualify each name withstd::if you like. For example,the following program does not bring the library into the global namespace.
// Use explicit std:: qualification.Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
601C++602C++:TheCompleteReference
#include <iostream>int main(){int val;std::cout << "Enter a number: ";
std::cin >> val;
std::cout << "This is your number: ";std::cout << std::hex << val;return 0;}Here,
cout,cin, and the manipulatorhexare explicitly qualified by their namespace.
That is, to write to standard output, you must specify
std::cout; to read from standard
input, you must usestd::cin; and the hex manipulator must be referred to as
std::hex.You may not want to bring the standard C++ library into the global namespace if
your program will be making only limited use of it. However, if your program contains
hundreds of references to library names, then including
stdin the current namespace is
far easier than qualifying each name individually.
Ifyouareusingonlyafewnamesfromthestandardlibrary,itmaymakemoresense
tospecifya
usingstatementforeachindividually.Theadvantagetothisapproachisthat
youcanstillusethosenameswithoutan
std::qualification,butyouwillnotbebringing
the entire standard library into the global namespace. For example:
// Bring only a few names into the global namespace.#include <iostream>// gain access to cout, cin, and hexusing std::cout;
using std::cin;
using std::hex;int main(){int val;C++Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
603cout << "Enter a number: ";cin >> val;cout << "This is your number: ";
cout << hex << val;
return 0;}Here,
cin,cout, andhexmay be used directly, but the rest of the
stdnamespace has notbeen brought into view.
As explained, the original C++ library was defined in the global namespace. If youwill be converting older C++ programs, then you will need to either include a
usingnamespace stdstatement or qualify each reference to a library member with
std::. Thisisespeciallyimportantifyouarereplacingold
.Hheaderfileswiththenew-styleheaders.
Remember,theold
.Hheadersputtheircontentsintotheglobalnamespace;thenew-style
headers put their contents into thestdnamespace.Creating Conversion Functions
In some situations, you will want to use an object of a class in an expression involving
other types of data. Sometimes, overloaded operator functions can provide the means

of doing this. However, in other cases, what you want is a simple type conversion from

the class type to the target type. To handle these cases, C++ allows you to create custom

conversion functions. Aconversion function converts your class into a type compatible

withthatoftherestoftheexpression.Thegeneralformatofatypeconversionfunctionis
operatortype( ) { returnvalue; }Here,
typeis the target type that you are converting your class to, and
valueis the valueoftheclassafterconversion.Conversionfunctionsreturndataoftype
type,andnoother
return type specifier is allowed. Also, no parameters may be included. Aconversion

function must be a member of the class for which it is defined. Conversion functions
are inherited and they may be virtual.
Thefollowingillustrationofaconversionfunctionusesthe
stackclassfirst
developed in Chapter 11. Suppose that you want to be able to use objects of type
stackwithin an integer expression. Further, suppose that the value of a
stackobject used inan integer expression is the number of values currently on the stack. (You might want
604C++:TheCompleteReference
to do something like this if, for example, you are using
stackobjects in a simulationand are monitoring how quickly the stacks fill up.) One way to approach this is to
convert an object of typestackinto an integer that represents the number of items
on the stack. To accomplish this, you use a conversion function that looks like this:
operator int() { return tos; }Here is a program that illustrates how the conversion function works:
#include <iostream>using namespace std;const int SIZE=100;
// this creates the class stackclass stack {int stck[SIZE];
int tos;public:stack() { tos=0; }
void push(int i);
int pop(void);
operator int() { return tos; } // conversion of stack to int};void stack::push(int i){if(tos==SIZE) {cout << "Stack is full.\n";
return;}
stck[tos] = i;
tos++;}int stack::pop(){if(tos==0) {cout << "Stack underflow.\n";
return 0;}tos--;return stck[tos];}int main(){stack stck;int i, j;for(i=0; i<20; i++)  stck.push(i);
j = stck; // convert to integer
cout << j << " items on stack.\n";
cout << SIZE - stck << " spaces open.\n";return 0;}This program displays this output:
20 items on stack.
80 spaces open.As the program illustrates, when a
stackobject is used in an integer expression,
such asj = stck, the conversion function is applied to the object. In this specific case,the conversion function returns the value 20. Also, when
stckis subtracted from
SIZE,the conversion function is also called.Hereisanotherexampleofaconversionfunction.Thisprogramcreatesaclasscalled
pwr()
that stores and computes the outcome of some number raised to some power. It
stores the result as a
double. By supplying a conversion function to typedoubleandreturning the result, you can use objects of type
pwrin expressions involving other
doublevalues.#include <iostream>
using namespace std;class pwr {double b;int e;
double val;Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
605C++606C++:TheCompleteReference
public:pwr(double base, int exp);pwr operator+(pwr o) {double base;int exp;
base = b + o.b;
exp = e + o.e;pwr temp(base, exp);return temp;}
operator double() { return val; } // convert to double};pwr::pwr(double base, int exp){b = base;
e = exp;
val = 1;
if(exp==0) return;
for( ; exp>0; exp--) val = val * b;}int main(){pwr x(4.0, 2);
double a;a = x; // convert to doublecout << x + 100.2; // convert x to double and add 100.2
cout << "\n";pwr y(3.3, 3), z(0, 0);
z = x + y;  // no conversiona = z;  // convert to double
cout << a;return 0;}Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
607C++The output from the program is shown here.
116.220730.7As you can see, whenxis used in the expression
x + 100.2, the conversion function isusedtoproducethe
doublevalue.Noticealsothatintheexpression
x+y,noconversion
is applied because the expression involves only objects of type
pwr.As you can infer from the foregoing examples, there are many situations in which
itisbeneficialtocreateaconversionfunctionforaclass.Often,conversionfunctions
provide a more natural syntax to be used when class objects are mixed with the built-in

types.Specifically,inthecaseofthe
pwrclass,theavailabilityoftheconversionto
doublemakesusingobjectsofthatclassin"normal"mathematicalexpressionsboth
easier to program and easier to understand.
You can create different conversion functions to meet different needs. You could
define another that converts tolong, for example. Each will be applied automaticallyas determined by the type of each expression.
const Member Functions and mutableClass member functions may be declared as
const, which causesthisto be treated as a
constpointer. Thus, that function cannot modify the object that invokes it. Also, a
constobjectmaynotinvokeanon-
constmemberfunction.However,a
constmemberfunction
can be called by eitherconstor non-constobjects.To specify a member function as
const,use the form shown in the following
example.class X {int some_var;public:int f1() const; // const member function};As you can see, theconstfollows the function's parameter declaration.Thepurposeofdeclaringamemberfunctionas
constistopreventitfrommodifying
the object that invokes it. For example, consider the following program.
/*Demonstrate const member functions.This program won't compile.*/#include <iostream>
using namespace std;class Demo {int i;public:int geti() const {return i; // ok}
void seti(int x) const {i = x; // error!}};
int main(){Demo ob;ob.seti(1900);cout << ob.geti();return 0;}Thisprogramwillnotcompilebecause
seti()
isdeclaredas
const.Thismeansthatitisnot
allowed to modify the invoking object. Since it attempts to changei, the program is in
error. In contrast, since
geti( )does not attempt to modifyi, it is perfectly acceptable.Sometimes there will be one or more members of a class that you want a
constfunction to be able to modify even though you don't want the function to be able tomodify any of its other members. You can accomplish this through the use of
mutable.It overridesconstness. That is, amutablemember can be modified by aconstmemberfunction. For example:// Demonstrate mutable.#include <iostream>
using namespace std;class Demo {608C++:TheCompleteReference
mutable int i;int j;public:int geti() const {return i; // ok}void seti(int x) const {i = x; // now, OK.}/* The following function won't compile.void setj(int x) const {j = x; // Still Wrong!}*/};int main(){Demo ob;ob.seti(1900);cout << ob.geti();return 0;}Here,
iis specified asmutable, so it may be changed by theseti( )function. However,
jis notmutableandsetj( )is unable to modify its value.Volatile Member Functions
Class member functions may be declared as
volatile, which causesthisto be treated as
avolatilepointer. To specify a member function as
volatile,use the form shown in the
following example:class X {public:void f2(int a) volatile; // volatile member function};Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
609C++610C++:TheCompleteReference
Explicit Constructors
As explained in Chapter 12, any time you have a constructor that requires only one
argument, you can use either
ob(x) orob=xto initialize an object. The reason for this is
that whenever you create a constructor that takes one argument, you are also implicitly

creating a conversion from the type of that argument to the type of the class. But there

may be times when you do not want this automatic conversion to take place. For this
purpose, C++ defines the keyword
explicit.To understand its effects, consider the
following program.
#include <iostream>using namespace std;class myclass {int a;public:myclass(int x) { a = x; }int geta() { return a; }};int main(){myclass ob = 4; // automatically converted into myclass(4)cout << ob.geta();
return 0;}Here, the constructor for
myclasstakes one parameter. Pay special attention to how
obis declared in
main( ). The statementmyclass ob = 4; // automatically converted into myclass(4)is automatically converted into a call to themyclassconstructor with 4 being the
argument. That is, the preceding statement is handled by the compiler as if it were
written like this:myclass ob(4);C++If you do not want this implicit conversion to be made, you can prevent it by using
explicit.The
explicitspecifierappliesonlytoconstructors.Aconstructorspecified
asexplicitwill only be used when an initialization uses the normal constructor syntax.
It will not perform any automatic conversion. For example, by declaring themyclassconstructoras
explicit,theautomaticconversionwillnotbesupplied.Hereis
myclass()
declared as
explicit.#include <iostream>using namespace std;class myclass {int a;public:explicit myclass(int x) { a = x; }int geta() { return a; }};Now, only constructors of the form
myclass ob(4);will be allowed and a statement likemyclass ob = 4; // now in errorwill be invalid.The Member Initialization SyntaxExample code throughout the preceding chapters has initialized member variables
inside the constructor for their class. For example, the following program contains the

MyClassclass, which has two integer data members callednumAandnumB. Thesemember variables are initialized inside
MyClass’ constructor.
#include <iostream>using namespace std;Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
611class MyClass {int numA;int numB;public:/* Initialize numA and numB inside the MyClass constructorusing normal syntax. */MyClass(int x, int y) {numA = x;numB = y;}int getNumA() { return numA; }int getNumB() { return numB; }};int main(){MyClass ob1(7, 9), ob2(5, 2);cout << "Values in ob1 are " << ob1.getNumB() <<" and " << ob1.getNumA() << endl;cout << "Values in ob2 are " << ob2.getNumB() <<" and " << ob2.getNumA() << endl;return 0;}Assigning initial values to member variablesnumAandnumBinside the constructor,
asMyClass( )does, is the usual approach, and is the way that member initialization is
accomplished for many, many classes. However, this approach won’t work in all cases.
For example, ifnumAandnumBwere specified as
const, like thisclass MyClass {const int numA; // const memberconst int numB; // const memberthentheycouldnotbegivenvaluesbythe
MyClassconstructorbecause
constvariablesmustbeinitializedandcannotbeassignedvaluesafterthefact.Similar
problems arise when using reference members, which must be initialized, and when

usingclassmembersthatdon’thavedefaultconstructors.Tosolvethesetypesof
612C++:TheCompleteReference
C++Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
613problems, C++ supports an alternative member initialization syntax, which is used to
give a class member an initial value when an object of the class is created.
The member initialization syntax is similar to that used to call a base classconstructor. Here is the general form:
constructor(arg-list) :member1(initializer),member2(initializer),// ...memberN(initializer){// body of constructor}Themembersthatyouwanttoinitializearespecifiedbeforethebodyoftheconstructor,

separated from the constructor’s name and argument list by a colon. You can mix calls

to base class constructors with member initializations in the same list.
Here is
MyClassrewritten so that
numAandnumBare
constmembers that are
given values using the member initialization syntax.#include <iostream>using namespace std;class MyClass {const int numA; // const memberconst int numB; // const memberpublic:// Initialize numA and numB using initialization syntax.
MyClass(int x, int y) : numA(x), numB(y) { }int getNumA() { return numA; }int getNumB() { return numB; }};int main(){MyClass ob1(7, 9), ob2(5, 2);cout << "Values in ob1 are " << ob1.getNumB() <<" and " << ob1.getNumA() << endl;cout << "Values in ob2 are " << ob2.getNumB() <<" and " << ob2.getNumA() << endl;return 0;}614C++:TheCompleteReference
Notice hownumAandnumBare initialized by this statement:
MyClass(int x, int y) : numA(x), numB(y) { }Here,
numAis initialized with the value passed inx, andnumBis initialized with thevaluepassedin
y.Eventhough
numAandnumBarenow
const,theycanbegiven
initialvalueswhena
MyClassobjectiscreatedbecausethememberinitialization
syntax is used.The member initialization syntax is especially useful when you have a member thatis of a class type for which there is no default constructor. To understand why, consider
this slightly different version of
MyClassthat attempts to store the two integer values
in an object of typeIntPair. BecauseIntPairhas no default constructor, this program is
in error and won’t compile.
// This program is in error and won't compile.#include <iostream>
using namespace std;class IntPair {public:int a;
int b;IntPair(int i, int j) : a(i), b(j) { }};
class MyClass {IntPair nums; // Error: no default constructor for IntPair!public:// This won't work!MyClass(int x, int y) {nums.a = x;
nums.b = y;}int getNumA() { return nums.a; }int getNumB() { return nums.b; }};int main(){MyClass ob1(7, 9), ob2(5, 2);Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
615C++cout << "Values in ob1 are " << ob1.getNumB() <<" and " << ob1.getNumA() << endl;cout << "Values in ob2 are " << ob2.getNumB() <<" and " << ob2.getNumA() << endl;return 0;}The reason that the program won’t compile is that
IntPairhas only one constructor and
itrequirestwoarguments.However,
numsisdeclaredinside
MyClasswithoutany
parametersandthevaluesof
aandbaresetinside
MyClass’constructor.Thiscauses
an error because it implies that a default (i.e., parameterless) constructor is available to
initially create an
IntPairobject, which is not the case.To fix this problem, you could add a default constructor to
IntPair. However, this
only works if you have access to the source code for the class, which might not always

be the case. Abetter solution is to use the member initialization syntax, as shown in

this correct version of the program.
// This program is now correct.#include <iostream>
using namespace std;class IntPair {public:int a;
int b;IntPair(int i, int j) : a(i), b(j) { }};
class MyClass {IntPair nums; // now OKpublic:// Initialize nums object using initialization syntax.MyClass(int x, int y) : nums(x,y) { }int getNumA() { return nums.a; }int getNumB() { return nums.b; }};int main()616C++:TheCompleteReference
{MyClass ob1(7, 9), ob2(5, 2);cout << "Values in ob1 are " << ob1.getNumB() <<" and " << ob1.getNumA() << endl;cout << "Values in ob2 are " << ob2.getNumB() <<" and " << ob2.getNumA() << endl;return 0;}Here,
numsis given an initial value when aMyClassobject is created. Thus, no default
constructor is required.
One last point: Class members are constructed and initialized in the order in which
they are declared in a class, not in the order in which their initializers occur.
Using the asm Keyword
While C++ is a comprehensive and powerful programming language, there are a
few highly specialized situations that it cannot handle. (For example, there is no C++

statement that disables interrupts.) To accommodate special situations, C++ provides

a"trapdoor"thatallowsyoutodropintoassemblycodeatanytime,bypassingthe

C++compilerentirely.This"trapdoor"isthe
asmstatement.Using
asm,youcanembed
assembly language directly into your C++ program. This assembly code is compiled

without any modification, and it becomes part of your program's code at the point at

which theasmstatement occurs.The general form of theasmkeyword is shown here:
asm ("op-code");where
op-codeis the assembly language instruction that will be embedded in your
program. However, several compilers also allow the following forms of
asm:asminstruction;asminstruction newlineasm {instruction sequence}Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
617C++Here,
instructionisanyvalidassemblylanguageinstruction.Becauseofthe
implementation- specific nature of
asm, you must check the documentation thatcame with your compiler for details.At the time of this writing, Microsoft's Visual C++ uses
_ _asmfor embeddingassembly code. It is otherwise similar toasm.Here is a simple (and fairly "safe") example that uses the
asmkeyword:
#include <iostream>using namespace std;int main(){asm int 5; // generate intertupt 5return 0;}When run under DOS, this program generates an INT 5 instruction, which invokes the
print-screen function.
Athorough working knowledge of assembly language programming is required for using

theasmstatement. If you are not proficient with assembly language, it is best to avoid
usingasmbecause very nasty errors may result.
Linkage SpecificationInC++youcanspecifyhowafunctionislinkedintoyourprogram.Bydefault,functions

are linked as C++ functions. However, by using a
linkage specification,you can causea function to be linked for a different type of language. The general form of a linkage

specifier isextern "language"function-prototypewhere
languagedenotes the desired language. All C++ compilers support both C and
C++linkage.SomewillalsoallowlinkagespecifiersforFortran,Pascal,orBASIC.

(Youwillneedtocheckthedocumentationforyourcompiler.)
This program causes
myCfunc( )to be linked as a C function.#include <iostream>using namespace std;618C++:TheCompleteReference
extern "C" void myCfunc();int main(){myCfunc();return 0;}
// This will link as a C function.void myCfunc()
{cout << "This links as a C function.\n";}Theexternkeyword is a necessary part of the linkage specification. Further, the linkage
specification must be global; it cannot be used inside of a function.You can specify more than one function at a time using this form of the linkage
specification:extern  "language" {prototypes}Array-Based I/OIn addition to console and file I/O, C++'s stream-based I/O system allows
array-basedI/O.Array-basedI/Ousesacharacterarrayaseithertheinputdevice,theoutput
device, or both. Array-based I/O is performed through normal C++ streams. In fact,

everything you already know about C++ I/O is applicable to array-based I/O. The

only thing that makes array-based I/O unique is that the device linked to the stream

is an array of characters. Streams that are linked to character arrays are commonly

referred to as
char *streams. To use array-based I/O in your programs, you must
include<strstream>.The character-based stream classes described in this section are deprecated by Standard

C++. This means that they are still valid, but not recommended for new code. This brief

discussion is included for the benefit of readers working on older code.
Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
619C++The Array-Based ClassesThe array-based I/O classes are
istrstream,ostrstream, andstrstream. These classesare used to create input, output, and input/output streams, respectively. Further, the
istrstreamclass is derived from
istream, theostrstreamclass is derived from
ostream,andstrstreamhasiostreamasabaseclass.Therefore,allarray-basedclassesare
indirectly derived from
iosand have access to the same member functions that the"normal" I/O classes do.Creating an Array-Based Output Stream
Toperformoutputtoanarray,youmustlinkthatarraytoastreamusingthis
ostrstreamconstructor:
ostrstreamostr(char *buf, streamsizesize, openmodemode=ios::out);Here,
bufis a pointer to the array that will be used to collect characters written to thestream
ostr. The size of the array is passed in thesizeparameter. By default, the stream
is opened for normal output, but you can OR various other options with it to create the

modethatyouneed.Forexample,youmightinclude
ios::apptocauseoutputtobe
writtenattheendofanyinformationalreadycontainedinthearray.Formostpurposes,

modewill be allowed to default.Once you have opened an array-based output stream, all output to that stream is
put into the array. However, no output will be written outside the bounds of the array.

Attempting to do so will result in an error.
Here is a simple program that demonstrates an array-based output stream.
#include <strstream>#include <iostream>
using namespace std;int main(){char str[80];ostrstream outs(str, sizeof(str));
outs << "C++ array-based I/O. ";outs << 1024 << hex << " ";
outs.setf(ios::showbase);
outs << 100 << ' ' << 99.789 << ends;620C++:TheCompleteReference
cout << str;  // display string on consolereturn 0;}This program displays the following:
C++ array-based I/O. 1024 0x64 99.789Keep in mind thatoutsis a stream like any other stream; it has the same capabilities
asanyothertypeofstreamthatyouhaveseenearlier.Theonlydifferenceisthatthe
device that it is linked to is a character array. Because
outsis a stream, manipulators
likehexandendsare perfectly valid.
ostreammember functions, such assetf( ), are
also available for use.This program manually null terminates the array by using the
endsmanipulator.
Whetherthearraywillbeautomaticallynullterminatedornotdependsonthe

implementation, so it is best to perform null termination manually if it is important
to your application.You can determine how many characters are in the output array by calling the
pcount( )member function. It has this prototype:
streamsize pcount( );The number returned by
pcount( )also includes the null terminator, if it exists.
Thefollowingprogramdemonstrates
pcount()
.Itreportsthat
outscontains18characters:17charactersplusthenullterminator.
#include <strstream>#include <iostream>
using namespace std;int main(){char str[80];ostrstream outs(str, sizeof(str));
outs << "abcdefg ";outs << 27 << " "  << 890.23;
outs << ends;  // null terminateC++cout << outs.pcount(); // display how many chars in outscout << " " << str;
return 0;}Using an Array as InputTo link an input stream to an array, use this
istrstreamconstructor:
istrstreamistr(const char *buf);Here,
bufis a pointer to the array that will be used as a source of characters each time
input is performed on the stream
istr. The contents of the array pointed to bybufmustbe null terminated. However, the null terminator is never read from the array.
Here is a sample program that uses a string as input.
#include <iostream>#include <strstream>
using namespace std;int main(){char s[] = "10 Hello 0x75 42.73 OK";istrstream ins(s);
int i;char str[80];
float f;// reading: 10 Helloins >> i;
ins >> str;
cout << i << " " << str << endl;// reading 0x75 42.73 OKins >> hex >> i;Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
621622C++:TheCompleteReference
ins >> f;ins >> str;cout << hex << i << " " << f << " " << str;
return 0;}If you want only part of a string to be used for input, use this form of theistrstreamconstructor:
istrstreamistr(const char *buf, streamsizesize);Here, only the first
sizeelements of the array pointed to bybufwill be used. This stringneednotbenullterminated,sinceitisthevalueof
sizethatdeterminesthesizeof
the string.Streamslinkedtomemorybehavejustlikethoselinkedtootherdevices.Forexample,
the following program demonstrates how the contents of any text array can be read.
When the end of the array (same as end-of-file) is reached,
inswill be false./* This program shows how to read the contents of anyarray that contains text. */#include <iostream>#include <strstream>
using namespace std;int main(){char s[] = "10.23 this is a test <<>><<?!\n";istrstream ins(s);
char ch;
/* This will read and display the contentsof any text array. */ins.unsetf(ios::skipws); // don't skip spaceswhile (ins) { // false when end of array is reachedins >> ch;
cout << ch;Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
623C++}return 0;}Input/Output Array-Based Streams
To create an array-based stream that can perform both input and output, use this
strstreamconstructor function:
strstreamiostr(char *buf, streamsizesize, openmodemode =ios::in|ios::out);Here,
bufpoints to the string that will be used for I/O operations. The value ofsizespecifiesthesizeofthearray.Thevalueof
modedetermineshowthestream
iostroperates.Fornormalinput/outputoperations,
modewillbe
ios::in|ios::out.For
input,the 
array must be null terminated.Here is a program that uses an array to perform both input and output.
// Perform both input and output.#include <iostream>
#include <strstream>
using namespace std;int main(){char iostr[80];strstream strio(iostr, sizeof(iostr), ios::in | ios::out);
int a, b;char str[80];strio << "10 20 testing ";strio >> a >> b >> str;
cout << a << " " << b << " " << str << endl;return 0;}This program first writes
10 20 testingto the array and then reads it back in again.
624C++:TheCompleteReference
Using Dynamic ArraysIn the preceding examples, when you linked a stream to an output array, the array and
its size were passed to the
ostrstreamconstructor. This approach is fine as long as you
knowthemaximumnumberofcharactersthatyouwillbeoutputtingtothearray.

However, what if you don't know how large the output array needs to be? The solution

to this problem is to use a second form of the
ostrstreamconstructor, shown here:
ostrstream( );When this constructor is used,
ostrstreamcreates and maintains a dynamically
allocated array, which automatically grows in length to accommodate the output

that it must store.
To access the dynamically allocated array, you must use a second function, called
str( ), which has this prototype:
char *str( );Thisfunction"freezes"thearrayandreturnsapointertoit.Youusethepointerreturned

bystr()
toaccessthedynamicarrayasastring.Onceadynamicarrayisfrozen,it
cannot be used for output again unless its is unfrozen (see below). Therefore, you will

not want to freeze the array until you are through outputting characters to it.
Here is a program that uses a dynamic output array.
#include <strstream>#include <iostream>
using namespace std;int main(){char *p;ostrstream outs;  // dynamically allocate array
outs << "C++ array-based I/O ";outs << -10 << hex << " ";
outs.setf(ios::showbase);
outs << 100 << ends;p = outs.str(); // Freeze dynamic buffer and return// pointer to it.cout << p;C++return 0;}You can also use dynamic I/O arrays with the
strstreamclass, which can performboth input and output on an array.
It is possible to freeze or unfreeze a dynamic array by calling the
freeze( )function.Its prototype is shown here:
void freeze(boolaction= true);Ifactionis true, the array is frozen. If
actionis false, the array is unfrozen.
Using Binary I/O with Array-Based Streams
Remember that array-based I/O has all of the functionality and capability of "normal"I/O.Therefore,arrayslinkedtoarray-basedstreamscanalsocontainbinaryinformation.

Whenreadingbinaryinformation,youmayneedtousethe
eof()
functiontodetermine
whentheendofthearrayhasbeenreached.Forexample,thefollowingprogramshows

how to read the contents of any array—binary or text—using the function
get( ).#include <iostream>#include <strstream>
using namespace std;int main(){char *p = "this is a test\1\2\3\4\5\6\7";istrstream ins(p);
char ch;
// read and display binary infowhile (!ins.eof()) {ins.get(ch);
cout << hex << (int) ch << ' ';}return 0;}In this example, the values formed by \1\2\3, and so on are nonprinting values.
Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
625To output binary characters, use the
put( )function. If you need to read buffers of
binary data, you can use theread( )member function. To write buffers of binary data,
use thewrite( )function.Summarizing the Differences
Between C and C++Forthemostpart,StandardC++isasupersetofStandardC,andvirtuallyallC
programs are also C++ programs. However, a few differences do exist, and these have

been discussed throughout Parts One and Two of this book. The most important are

summarized here.
In C++, local variables can be declared anywhere within a block. In C, they must
bedeclaredatthestartofablock,beforeany"action"statementsoccur.(C99hasremoved

this restriction.)
In C, a function declared like
int f();saysnothingaboutanyparameterstothatfunction.Thatis,whenthereisnothing
specified between the parentheses following the function's name, in C this means that

nothingisbeingstated,onewayortheother,aboutanyparameterstothatfunction.

Itmight have parameters, or it might not. However, in C++, a function declaration like

thismeansthatthefunctiondoes
nothaveparameters.Thatis,inC++,thesetwo
declarations are equivalent:
int f();int f(void);In C++,voidin a parameter list is optional. Many C++ programmers include
voidasa means of making it completely clear to anyone reading the program that a function
does not have any parameters, but this is technically unnecessary.
In C++, all functions must be prototyped. This is an option in C (although good
programming practice suggests full prototyping be used in a C program).
Asmall but potentially important difference between C and C++ is that in C,
a character constant is automatically elevated to an integer. In C++, it is not.
In C, it is not an error to declare a global variable several times, even though this is
bad programming practice. In C++, it is an error.
In C, an identifier will have at least 31 significant characters. In C++, all charactersare significant. However, from a practical point of view, extremely long identifiers are

unwieldy and seldom needed.626C++:TheCompleteReference
In C, although it is unusual, you can callmain( )from within your program. This is
not allowed by C++.In C, you cannot take the address of a
registervariable. In C++, this is allowed.In C, if no type specifier is present in some types of declaration statements, the type
intis assumed. This "default-to-int" rule no longer applies to C++. (C99 also drops the
"default-to-int" rule.)
Chapter23:Namespaces,ConversionFunctions,andOtherAdvancedTopics
627C++This page intentionally left blank Chapter24
Introducing theStandard Template

Library629Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
630C++:TheCompleteReference
This chapter explores what is considered by many to be the most important featureadded to C++ in recent years: thestandard template library(STL). The inclusion ofthe STL was one of the major efforts that took place during the standardizationof C++.It provides general-purpose, templatized classes and functions that implement

manypopularandcommonlyusedalgorithmsanddatastructures,including,for

example, support for vectors, lists, queues, and stacks. It also defines various routines
that access them. Because the STL is constructed from template classes, the algorithms
and data structures can be applied to nearly any type of data.The STLis a complex piece of software engineering that uses some of C++'s most
sophisticatedfeatures.TounderstandandusetheSTL,youmusthaveacomplete

understandingoftheC++language,includingpointers,references,andtemplates.

Frankly,thetemplatesyntaxthatdescribestheSTLcanseemquiteintimidating—

althoughitlooksmorecomplicatedthanitactuallyis.Whilethereisnothinginthis

chapterthatisanymoredifficultthanthematerialintherestofthisbook,don'tbe

surprised or dismayed if you find the STLconfusing at first. Just be patient, study the

examples, and don't let the unfamiliar syntax override the STL's basic simplicity.
The purpose of this chapter is to present an overview of the STL, including its
designphilosophy,organization,constituents,andtheprogrammingtechniques

needed to use it. Because the STLis a large library, it is not possible to discuss all of

its features here. However, a complete reference to the STLis provided in Part Four.
This chapter also describes one of C++'s most important classes:string. Thestringclass defines a string data type that allows you to work with character strings much as
you do other data types: using operators. Thestringclass is closely related to the STL.
An Overview of the STL
Although the standard template library is large and its syntax can be intimidating,

it is actually quite easy to use once you understand how it is constructed and what

elements it employs. Therefore, before looking at any code examples, an overview

of the STLis warranted.
At the core of the standard template library are three foundational items:
containers,algorithms, anditerators. These items work in conjunction with one another to provide
off-the-shelf solutions to a variety of programming problems.
ContainersContainersareobjectsthatholdotherobjects,andthereareseveraldifferenttypes.
For example, thevectorclass defines a dynamic array,
dequecreates a double-ended
queue, andlistprovides a linear list. These containers are called
sequence containersbecauseinSTLterminology,asequenceisalinearlist.Inadditiontothebasiccontainers,
Chapter24:IntroducingtheStandardTemplateLibrary
631C++the STLalso defines
associativecontainers,
which allow efficient retrieval of values based
on keys. For example, amapprovides access to values with unique keys. Thus, a
mapstores a key/value pair and allows a value to be retrieved given its key.
Each container class defines a set of functions that may be applied to the container.
For example, a list container includes functions that insert, delete, and merge elements.
Astack includes functions that push and pop values.
AlgorithmsAlgorithmsact on containers. They provide the means by which you will manipulate
the contents of containers. Their capabilities include initialization, sorting, searching,

and transforming the contents of containers. Many algorithms operate on arangeofelements within a container.
IteratorsIteratorsare objects that act, more or less, like pointers. They give you the ability to
cycle through the contents of a container in much the same way that you would use

a pointer to cycle through an array. There are five types of iterators:
IteratorAccess Allowed
Random AccessStore and retrieve values. Elements may be accessed randomly.
BidirectionalStore and retrieve values. Forward and backward moving.

ForwardStore and retrieve values. Forward moving only.

InputRetrieve, but not store values. Forward moving only.
OutputStore, but not retrieve values. Forward moving only.
In general, an iterator that has greater access capabilities can be used in place of one
that has lesser capabilities. For example, a forward iterator can be used in place of an

input iterator.
Iteratorsarehandledjustlikepointers.Youcanincrementanddecrementthem.You
can apply the*operator to them. Iterators are declared using the
iteratortype definedby the various containers.TheSTLalsosupports
reverseiterators
.Reverseiteratorsareeitherbidirectionalor
random-access iterators that move through a sequence in the reverse direction. Thus, if

a reverse iterator points to the end of a sequence, incrementing that iterator will cause

it to point to one element before the end.
When referring to the various iterator types in template descriptions, this book will
use the following terms:632C++:TheCompleteReference
Term
Represents
BiIterBidirectional iterator
ForIterForward iterator
InIterInput iteratorOutIterOutput iteratorRandIterRandom access iteratorOther STL ElementsIn addition to containers, algorithms, and iterators, the STLrelies upon several other
standardcomponentsforsupport.Chiefamongtheseareallocators,predicates,

comparison functions, and function objects.Each container has defined for it anallocator. Allocators manage memory allocationfor a container. The default allocator is an object of class
allocator, but you can defineyour own allocators if needed by specialized applications. For most uses, the default
allocator is sufficient.
Severalofthealgorithmsandcontainersuseaspecialtypeoffunctioncalleda
predicate
.Therearetwovariationsofpredicates:unaryandbinary.A
unarypredicate
takes one argument, while a
binarypredicate has two. These functions return true/false
results. But the precise conditions that make them return true or false are defined by

you. For the rest of this chapter, when a unary predicate function is required, it will be

notated using the typeUnPred. When a binary predicate is required, the type
BinPredwill be used. In a binary predicate, the arguments are always in the order of
first,second.For both unary and binary predicates, the arguments will contain values of the type of

objects being stored by the container.
Some algorithms and classes use a special type of binary predicate that compares
two elements. Comparison functions return true if their first argument is less than their

second. Comparison functions will be notated using the typeComp.In addition to the headers required by the various STLclasses, the C++ standard
library includes the<utility>and<functional>headers, which provide support for
theSTL.Forexample,thetemplateclass
pair,whichcanholdapairofvalues,is
defined in<utility>. We will make use of
pairlater in this chapter.
The templates in<functional>help you construct objects that define
operator( ).These are called
functionobjects
and they may be used in place of function pointersinmanyplaces.Thereareseveralpredefinedfunctionobjectsdeclaredwithin

<functional>. They are shown here:
plusminusmultipliesdividesmodulus
negateequal_tonot_equal_togreatergreater_equal

lessless_equallogical_andlogical_orlogical_not
Perhapsthemostwidelyusedfunctionobjectis
less,whichdetermineswhenoneobject
is less than another. Function objects can be used in place of actual function pointers in
the STLalgorithms described later. Using function objects rather than function pointers

allows the STLto generate more efficient code.
Two other entities that populate the STLare
bindersandnegators.Abinder binds
an argument to a function object. Anegator returns the complement of a predicate.
One final term to know isadaptor. In STLterms, an adaptor transforms one thing
into another. For example, the container
queue(which creates a standard queue) is
an adaptor for thedequecontainer.
The Container ClassesAs explained, containers are the STLobjects that actually store data. The containers

defined by the STLare shown in Table 24-1. Also shown are the headers necessary

to use each container. The
stringclass, which manages character strings, is alsoa container, but it is discussed later in this chapter.
Chapter24:IntroducingtheStandardTemplateLibrary
633C++ContainerDescription
Required Header
bitsetAset of bits.
<bitset>dequeAdouble-ended queue.
<deque>listAlinear list.
<list>mapStores key/value pairs in which each key is

associated with only one value.<map>multimapStores key/value pairs in which one key
may be associated with two or more values.
<map>multisetAset in which each element is not
necessarily unique.<set>priority_queueApriority queue.
<queue>queueAqueue.
<queue>setAset in which each element is unique.<set>
stackAstack.
<stack>vectorAdynamic array.
<vector>Table24-1.
The Containers Defined by the STL634C++:TheCompleteReference
Since the names of the generic placeholder types in a template class declaration are
arbitrary, the container classes declare
typedefed versions of these types. This makesthe type names concrete. Some of the most common
typedefnames are shown here:
size_typeSome type of integerreferenceAreference to an element
const_referenceAconstreference to an element
iteratorAn iteratorconst_iteratorAconstiteratorreverse_iteratorAreverse iterator
const_reverse_iteratorAconstreverse iterator
value_typeThe type of a value stored in a container
allocator_typeThe type of the allocatorkey_typeThe type of a keykey_compareThe type of a function that compares two keys
value_compareThe type of a function that compares two values
General Theory of Operation
Although the internal operation of the STLis highly sophisticated, to use the STL
is actually quite easy. First, you must decide on the type of container that you wish

touse.Eachofferscertainbenefitsandtrade-offs.Forexample,a
vectorisvery
good when a random-access, array-like object is required and not too many insertions

or deletions are needed. A
listoffers low-cost insertion and deletion but trades away
speed.A
mapprovidesanassociativecontainer,butofcourseincursadditionaloverhead.
Onceyouhavechosenacontainer,youwilluseitsmemberfunctionstoadd
elements to the container, access or modify those elements, and delete elements. Except

forbitset, a container will automatically grow as needed when elements are added to
it and shrink when elements are removed.
Elements can be added to and removed from a container a number of different
ways.Forexample,boththesequencecontainers(
vector,list,and
deque)andthe
associative containers (map,multimap,set, andmultiset) provide a member function
calledinsert( ), which inserts elements into a container, and
erase( ), which removes
elementsfromacontainer.Thesequencecontainersalsoprovide
push_back()
andpop_back()
,whichaddanelementtoorremoveanelementfromtheend,
respectively. These functions are probably the most common way that individual

elements are added to or removed from a sequence container.  The
listanddequecontainers also includepush_front( )andpop_front( ), which add and remove
elements from the start of the container.
One of the most common ways to access the elements within a container is through
an iterator. The sequence and the associative containers provide the member functions
begin()
andend()
,whichreturniteratorstothestartandendofthecontainer,respectively.
These iterators are very useful when accessing the contents of a container. For example,

to cycle through a container, you can obtain an iterator to its beginning using
begin( )and then increment that iterator until its value is equal to
end( ).The associative containers provide the function
find( ), which is used to locate anelement in an associative container given its key. Since associative containers link a key

with its value,find( )is how most elements in such a container are located.
Sincea
vectorisadynamicarray,italsosupportsthestandardarray-indexingsyntax
for accessing its elements.Once you have a container that holds information, it can be manipulated using oneormorealgorithms.Thealgorithmsnotonlyallowyoutoalterthecontentsofacontainer

in some prescribed fashion, but they also let you transform one type of sequence into

another.
In the following sections, you will learn to apply these general techniques to three
representativecontainers:
vector,list,and
map.Onceyouunderstandhowthese
containers work, you will have no trouble using the others.
Vectors
Perhaps the most general-purpose of the containers is
vector. Thevectorclass supportsadynamicarray.Thisisanarraythatcangrowasneeded.Asyouknow,inC++the

size of an array is fixed at compile time. While this is by far the most efficient way to

implement arrays, it is also the most restrictive because the size of the array cannot be

adjusted at run time to accommodate changing program conditions. Avector solves

this problem by allocating memory as needed. Although a vector is dynamic, you can

still use the standard array subscript notation to access its elements.
The template specification forvectoris shown here:
template <class T, class Allocator = allocator<T> > class vectorHere,
Tis the type of data being stored and
Allocatorspecifies the allocator, which
defaults to the standard allocator.
vectorhas the following constructors:
explicit vector(const Allocator &a= Allocator( ) );explicit vector(size_typenum, const T &val= T ( ),const Allocator &a= Allocator( ));vector(const vector<T, Allocator> &ob);
template <class InIter> vector(InIterstart, InIterend,const Allocator &a= Allocator( ));Chapter24:IntroducingtheStandardTemplateLibrary
635C++636C++:TheCompleteReference
The first form constructs an empty vector. The second form constructs a vector that
hasnumelements with the valueval. The value ofvalmay be allowed to default. Thethird form constructs a vector that contains the same elements as
ob. The fourth formconstructs a vector that contains the elements in the range specified by the iterators
startandend.For maximum flexibility and portability, any object that will be stored in a
vectorshoulddefineadefaultconstructor.Itshouldalsodefinethe<and==operations.

Somecompilersmayrequirethatothercomparisonoperatorsbedefined.(Since

implementations vary, consult your compiler's documentation for precise information.)

All of the built-in types automatically satisfy these requirements.
Although the template syntax looks rather complex, there is nothing difficult about
declaring a vector. Here are some examples:
vector<int> iv;           // create zero-length int vectorvector<char> cv(5);       // create 5-element char vector
vector<char> cv(5,  'x'); // initialize a 5-element char vector
vector<int> iv2(iv);      // create int vector from an int vectorThe following comparison operators are defined for
vector:==, <, <=, !=, >, >=The subscripting operator [ ] is also defined forvector. This allows you to access theelements of a vector using standard array subscripting notation.
Severalofthememberfunctionsdefinedby
vectorareshowninTable24-2.
(Remember, Part Four contains a complete reference to the STLclasses.) Some of the
mostcommonlyusedmemberfunctionsare
size()
,begin()
,end()
,push_back()
,insert( ), anderase( ). Thesize( )function returns the current size of the vector. This
function is quite useful because it allows you to determine the size of a vector at run

time. Remember, vectors will increase in size as needed, so the size of a vector must

be determined during execution, not during compilation.Thebegin()
functionreturnsaniteratortothestartofthevector.The
end()
functionreturnsaniteratortotheendofthevector.Asexplained,iteratorsaresimilartopointers,

and it is through the use of the
begin( )andend( )functions that you obtain an iteratorto the beginning and end of a vector.
Thepush_back( )function puts a value onto the end of the vector. If necessary,
the vector is increased in length to accommodate the new element. You can also add

elements to the middle usinginsert( ). Avector can also be initialized. In any event,
once a vector contains elements, you can use array subscripting to access or modify
those elements. You can remove elements from a vector using
erase( ).Chapter24:IntroducingtheStandardTemplateLibrary
637C++MemberDescriptionreference back( );
const_reference back( ) const;
Returns a reference to the last element

in the vector.
iterator begin( );
const_iterator begin( ) const;Returns an iterator to the first element
in the vector.
void clear( );Removes all elements from the vector.
bool empty( ) const;Returns true if the invoking vector is
empty and false otherwise.iterator end( );const_iterator end( ) const;Returns an iterator to the end of
the vector.
iterator erase(iteratori);Removes the element pointed to byi.Returns an iterator to the element after
the one removed.
iterator erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend. Returns an iterator to theelement after the last element removed.
reference front( );

const_reference front( ) const;
Returns a reference to the first element

in the vector.
iterator insert(iteratori,const T &val);Insertsvalimmediately before the
element specified byi.An iteratorto the element is returned.
void insert(iteratori, size_typenum,const T &val)Insertsnumcopies ofvalimmediatelybefore the element specified by
i.template <class InIter>void insert(iteratori, InIterstart,InIterend);Inserts the sequence defined bystartandendimmediately before the element
specified byi.reference operator[ ](size_type
i) const;const_reference operator[ ](size_type
i)const;Returns a reference to the element

specified byi.void pop_back( );Removes the last element in the vector.
void push_back(const T &val);Adds an element with the value speci-
fied byvalto the end of the vector.
size_type size( ) const;Returns the number of elements
currently in the vector.
Table24-2.
Some Commonly Used Member Functions Defined byvector638C++:TheCompleteReference
Here is a short example that illustrates the basic operation of a vector.
// Demonstrate a vector.#include <iostream>
#include <vector>
#include <cctype>
using namespace std;int main(){vector<char> v(10); // create a vector of length 10
unsigned int i;// display original size of vcout << "Size = " << v.size() << endl;// assign the elements of the vector some valuesfor(i=0; i<10; i++) v[i] = i + 'a';// display contents of vectorcout << "Current Contents:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << "\n\n";cout << "Expanding vector\n";/* put more values onto the end of the vector,it will grow as needed */for(i=0; i<10; i++) v.push_back(i + 10 + 'a');// display current size of vcout << "Size now = " << v.size() << endl;// display contents of vectorcout << "Current contents:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << "\n\n";// change contents of vectorfor(i=0; i<v.size(); i++) v[i] = toupper(v[i]);
cout << "Modified Contents:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << endl;return 0;}The output of this program is shown here:
Size = 10Current Contents:
a b c d e f g h i jExpanding vectorSize now = 20
Current contents:
a b c d e f g h i j k l m n o p q r s tModified Contents:A B C D E F G H I J K L M N O P Q R S TLet's look at this program carefully. In
main( ), a character vector calledvis created
with an initial capacity of 10. That is,vinitially contains 10 elements. This is confirmedbycallingthe
size()
memberfunction.Next,these10elementsareinitializedtothe
charactersathroughjandthecontentsof
varedisplayed.Noticethatthestandard
array subscripting notation is employed. Next, 10 more elements are added to the end
ofvusing thepush_back( )function. This causesvto grow in order to accommodate
the new elements. As the output shows, its size after these additions is 20. Finally, the

values ofv's elements are altered using standard subscripting notation.
Thereisoneotherpointofinterestinthisprogram.Noticethattheloopsthat
display the contents ofvuse as their target value
v.size( )
. One of the advantages thatvectors have over arrays is that it is possible to find the current size of a vector. As you

can imagine, this can be quite useful in a variety of situations.Accessing a Vector Through an Iterator
As you know, arrays and pointers are tightly linked in C++. An array can be accessed

either through subscripting or through a pointer. The parallel to this in the STLis the

linkbetweenvectorsanditerators.Youcanaccessthemembersofavectorusing

subscripting or through the use of an iterator. The following example shows how.
// Access the elements of a vector through an iterator.#include <iostream>
#include <vector>
#include <cctype>Chapter24:IntroducingtheStandardTemplateLibrary
639C++using namespace std;int main(){vector<char> v(10); // create a vector of length 10
vector<char>::iterator p; // create an iterator
int i;// assign elements in vector a valuep = v.begin();
i = 0;
while(p != v.end()) {*p = i + 'a';
p++;
i++;}// display contents of vectorcout << "Original contents:\n";
p = v.begin();
while(p != v.end()) {cout << *p << " ";
p++;}
cout << "\n\n";// change contents of vectorp = v.begin();
while(p != v.end()) {*p = toupper(*p);
p++;}// display contents of vectorcout << "Modified Contents:\n";
p = v.begin();
while(p != v.end()) {cout << *p << " ";
p++;}
cout << endl;640C++:TheCompleteReference
return 0;}The output from this program is
Original contents:a b c d e f g h i jModified Contents:A B C D E F G H I JIn the program, notice how the iterator
pis declared. The type
iteratoris defined bythe container classes. Thus, to obtain an iterator for a particular container, you will use
adeclarationsimilartothatshownintheexample:simplyqualify
iteratorwiththename
ofthecontainer.Intheprogram,
pisinitializedtopointtothestartofthevectorbyusing
thebegin( )member function. This function returns an iterator to the start of the vector.
This iterator can then be used to access the vector an element at a time by incrementing

it as needed. This process is directly parallel to the way a pointer can be used to access

the elements of an array. To determine when the end of the vector has been reached, the

end( )member function is employed. This function returns an iterator to the location
that is one past the last element in the vector. Thus, when
pequalsv.end( )
, the end ofthe vector has been reached.
Inserting and Deleting Elements in a Vector
In addition to putting new values on the end of a vector, you can insert elements into

the middle using theinsert( )function. You can also remove elements using
erase( ).The following program demonstrates
insert( )anderase( ).// Demonstrate insert and erase.#include <iostream>
#include <vector>
using namespace std;int main(){vector<char> v(10);
vector<char> v2;
char str[] = "<Vector>";
unsigned int i;Chapter24:IntroducingtheStandardTemplateLibrary
641C++// initialize vfor(i=0; i<10; i++) v[i] = i + 'a';// copy characters in str into v2for(i=0; str[i]; i++) v2.push_back(str[i]);// display original contents of vectorcout << "Original contents of v:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << "\n\n";vector<char>::iterator p = v.begin();p += 2; // point to 3rd element// insert 10 X's into vv.insert(p, 10, 'X');// display contents after insertioncout << "Size after inserting X's = " << v.size() << endl;
cout << "Contents after insert:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << "\n\n";// remove those elementsp = v.begin();
p += 2; // point to 3rd element
v.erase(p, p+10); // remove next 10 elements// display contents after deletioncout << "Size after erase = " << v.size() << endl;
cout << "Contents after erase:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << "\n\n";// Insert v2 into vv.insert(p, v2.begin(), v2.end());
cout << "Size after v2's insertion = ";
cout << v.size() << endl;
cout << "Contents after insert:\n";
for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << endl;642C++:TheCompleteReference
Chapter24:IntroducingtheStandardTemplateLibrary
643C++return 0;}This program produces the following output:
Original contents of v:a b c d e f g h i jSize after inserting X's = 20Contents after insert:
a b X X X X X X X X X X c d e f g h i jSize after erase = 10Contents after erase:
a b c d e f g h i jSize after v2's insertion = 18Contents after insert:
a b < V e c t o r > c d e f g h i jThis program demonstrates two forms of
insert( ). The first time it is used, it inserts10 X's intov. The second time, it inserts the contents of a second vector,
v2, intov. Thissecond use is the most interesting. It takes three iterator arguments. The first specifies
the point at which the insertion will occur within the invoking container. The last two

point to the beginning and ending of the sequence to be inserted.Storing Class Objects in a Vector
Although the preceding examples have only stored objects of the built-in types in

a vector,
vectors are not limited to this. They can store any type of objects, including
those of classes that you create. Here is an example that uses a
vectorto store objects
that hold the daily temperature highs for a week. Notice that
DailyTemp
defines thedefault constructor and that overloaded versions of < and == are provided. Remember,

depending upon how your compiler implements the STL, these (or other) comparison
operators may need to be defined.// Store a class object in a vector.#include <iostream>
#include <vector>
#include <cstdlib>
using namespace std;644C++:TheCompleteReference
class DailyTemp {int temp;public:DailyTemp() { temp = 0; }DailyTemp(int x) { temp = x; }DailyTemp &operator=(int x) {temp = x; return *this;}
double get_temp() { return temp; }};
bool operator<(DailyTemp a, DailyTemp b){return a.get_temp() < b.get_temp();}bool operator==(DailyTemp a, DailyTemp b){return a.get_temp() == b.get_temp();}int main(){vector<DailyTemp> v;
unsigned int i;for(i=0; i<7; i++)v.push_back(DailyTemp(60 + rand()%30));cout << "Fahrenheit temperatures:\n";for(i=0; i<v.size(); i++)cout << v[i].get_temp() << " ";cout << endl;// convert from Fahrenheit to Centigradefor(i=0; i<v.size(); i++)v[i] = (int)(v[i].get_temp()-32) * 5/9 ;cout << "Centigrade temperatures:\n";
for(i=0; i<v.size(); i++)Chapter24:IntroducingtheStandardTemplateLibrary
645C++cout << v[i].get_temp() << " ";return 0;}Sample output from this program is shown here:
Fahrenheit temperatures:71 77 64 70 89 64 78
Centigrade temperatures:
21 25 17 21 31 17 25Vectors offer great power, safety, and flexibility, but they are less efficient than
normal arrays. Thus, for most programming tasks, normal arrays will still be your
first choice. But watch for situations in which the benefits of using avectoroutweighits costs.ListsThelistclass supports a bidirectional, linear list. Unlike a vector, which supports
random access, a list can be accessed sequentially only. Since lists are bidirectional,

they may be accessed front to back or back to front.
Alisthas this template specification:template <class T, class Allocator = allocator<T> > class listHere,
Tis the type of data stored in the list. The allocator is specified by
Allocator,which defaults to the standard allocator. It has the following constructors:
explicit list(const Allocator &a= Allocator( ) );explicit list(size_typenum, const T &val= T ( ),const Allocator &a= Allocator( ));list(const list<T, Allocator> &ob);
template <class InIter>list(InIterstart, InIterend,const Allocator &a= Allocator( ));The first form constructs an empty list. The second form constructs a list that has
numelements with the valueval, which can be allowed to default. The third form constructs
alistthatcontainsthesameelementsas
ob.Thefourthformconstructsalistthatcontains
the elements in the range specified by the iteratorsstartandend.The following comparison operators are defined for
list:==, <, <=, !=, >, >=Some of the commonly usedlistmember functions are shown in Table 24-3. Like
vectors, elements may be put into a list by using thepush_back( )function.You can
put elements on the front of the list by using
push_front( ). An element can also be646C++:TheCompleteReference
MemberDescriptionreference back( );
const_reference back( ) const;
Returns a reference to the last element

in the list.iterator begin( );
const_iterator begin( ) const;Returns an iterator to the first element
in the list.void clear( );Removes all elements from the list.
bool empty( ) const;Returns true if the invoking list is empty
and false otherwise.iterator end( );const_iterator end( ) const;Returns an iterator to the end of the list.iterator erase(iteratori);Removes the element pointed to byi.Returns an iterator to the element after
the one removed.
iterator erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend. Returns an iterator to the elementafter the last element removed.
reference front( );

const_reference front( ) const;
Returns a reference to the first element

in the list.iterator insert(iteratori,const T &val);Insertsvalimmediately before the
element specified byi.An iteratorto the element is returned.
void insert(iteratori, size_typenum,const T &val)Insertsnumcopies ofvalimmediatelybefore the element specified by
i.template <class InIter>void insert(iteratori,InIterstart, InIterend);Inserts the sequence defined bystartandendimmediately before the element
specified byi.Table24-3.
Some Commonly UsedlistMember FunctionsChapter24:IntroducingtheStandardTemplateLibrary
647C++MemberDescriptionvoid merge(list<T, Allocator> &
ob);template <class Comp>void merge(list<T,  Allocator> &
ob,Compcmpfn);Merges the ordered list contained in
obwith the ordered invoking list. The result

isordered.Afterthemerge,thelist

contained inobis empty. In the second
form,acomparisonfunctioncanbe

specifiedthatdetermineswhenone

element is less than another.
void pop_back( );Removes the last element in the list.
void pop_front( );Removes the first element in the list.

void push_back(const T &val);Adds an element with the value specifiedbyvalto the end of the list.void push_front(const T &
val);Adds an element with the value specified
byvalto the front of the list.
void remove(const T &
val);Removes elements with the valuevalfrom
the list.void reverse( );
Reverses the invoking list.size_type size( ) const;Returns the number of elements currently
in the list.void sort( );
template <class Comp>void sort(Compcmpfn);Sorts the list. The second form sorts the
list using the comparison functioncmpfnto determine when one element is less
than another.
void splice(iteratori,list<T, Allocator> &
ob);The contents ofobare inserted into the
invoking list at the location pointed to
byi. After the operation,obis empty.
void splice(iteratori,list<T, Allocator> &
ob,
iteratorel);The element pointed to byelis removed
from the list
oband stored in the invoking
list at the location pointed to byi.void splice(iteratori,list<T, Allocator> &
ob,
iteratorstart, iteratorend);The range defined bystartandendis removed from
oband stored in the
invoking list beginning at the location
pointed to byi.Table24-3.
Some Commonly UsedlistMember Functions (continued)648C++:TheCompleteReference
inserted into the middle of a list by usinginsert( ). Two lists may be joined using
splice( ). One list may be merged into another using
merge( ).Formaximumflexibilityandportability,anyobjectthatwillbeheldinalist
should define a default constructor. It should also define the
<operator, and possibly
other comparison operators. The precise requirements for an object that will be stored
in a list vary from compiler to compiler, so you will need to check your compiler's

documentation.Here is a simple example of a
list.// List basics.#include <iostream>
#include <list>
using namespace std;int main(){list<int> lst; // create an empty list
int i;for(i=0; i<10; i++) lst.push_back(i);
cout << "Size = " << lst.size() << endl;
cout << "Contents: ";list<int>::iterator p = lst.begin();
while(p != lst.end()) {cout << *p << " ";
p++;}
cout << "\n\n";// change contents of listp = lst.begin();
while(p != lst.end()) {*p = *p + 100;
p++;}cout << "Contents modified: ";p = lst.begin();
while(p != lst.end()) {cout << *p << " ";p++;}return 0;}The output produced by this program is shown here:
Size = 10Contents: 0 1 2 3 4 5 6 7 8 9Contents modified: 100 101 102 103 104 105 106 107 108 109This program creates a list of integers. First, an empty
listobject is created. Next,
10 integers are put into the list. This is accomplished using the
push_back( )function,which puts each new value on the end of the existing list. Next, the size of the list andthe list itself is displayed. The list is displayed via an iterator, using the following code:
list<int>::iterator p = lst.begin();while(p != lst.end()) {cout << *p << " ";
p++;}Here, the iterator
pis initialized to point to the start of the list. Each time through the
loop,pisincremented,causingittopointtothenextelement.Theloopendswhen
ppoints to the end of the list. This code is essentially the same as was used to cyclethrough a vector using an iterator. Loops like this are common in STLcode, and the
fact that the same constructs can be used to access different types of containers is part

of the power of the STL.Understanding end( )Nowisagoodtimetoemphasizeasomewhatunexpectedattributeofthe
end()
container function.end( )does not return a pointer to the last element in a container.
Instead,itreturnsapointer
onepast
thelastelement.Thus,thelastelementina
containerispointedtoby
end()-1
.Thisfeatureallowsustowriteveryefficient
algorithms that cycle through all of the elements of a container, including the last one,

using an iterator. When the iterator has the same value as the one returned by
end( ),we know that all elements have been accessed. However, you must keep this feature

in mind since it may seem a bit counterintuitive. For example, consider the following
program, which displays a list forward and backward.
Chapter24:IntroducingtheStandardTemplateLibrary
649C++650C++:TheCompleteReference
// Understanding end().#include <iostream>
#include <list>
using namespace std;int main(){list<int> lst; // create an empty list
int i;for(i=0; i<10; i++) lst.push_back(i);
cout << "List printed forwards:\n";list<int>::iterator p = lst.begin();
while(p != lst.end()) {cout << *p << " ";
p++;}
cout << "\n\n";cout << "List printed backwards:\n";p = lst.end();
while(p != lst.begin()) {p--; // decrement pointer before using
cout << *p << " ";}return 0;}The output produced by this program is shown here:
List printed forwards:0 1 2 3 4 5 6 7 8 9List printed backwards:9 8 7 6 5 4 3 2 1 0The code that displays the list in the forward direction is the same as we have been
using. But pay special attention to the code that displays the list in reverse order. The

iteratorpisinitiallysettotheendofthelistthroughtheuseofthe
end()
function.Sinceend( )returns an iterator to an object that is one past the last object actually
stored in the list,
pmust be decremented before it is used. This is why
pis decremented
before the
coutstatement inside the loop, rather than after. Remember:
end( )does notreturn a pointer to the last object in the list; it returns a pointer that is one past the last
value in the list.push_front( ) vs. push_back( )
You can build a list by adding elements to either the end or the start of the list. So far,

we have been adding elements to the end by usingpush_back( ). To add elements to
the start, usepush_front( ). For example,/* Demonstrating the difference betweenpush_back() and push_front(). */#include <iostream>#include <list>
using namespace std;int main(){list<int> lst1, lst2;
int i;for(i=0; i<10; i++) lst1.push_back(i);for(i=0; i<10; i++) lst2.push_front(i);list<int>::iterator p;
cout << "Contents of lst1:\n";p = lst1.begin();
while(p != lst1.end()) {cout << *p << " ";
p++;}
cout << "\n\n";cout << "Contents of lst2:\n";p = lst2.begin();
while(p != lst2.end()) {cout << *p << " ";
p++;}Chapter24:IntroducingtheStandardTemplateLibrary
651C++return 0;}The output produced by this program is shown here:
Contents of lst1:0 1 2 3 4 5 6 7 8 9Contents of lst2:9 8 7 6 5 4 3 2 1 0Sincelst2is built by putting elements onto its front, the resulting list is in the reverse
order of
lst1, which is built by putting elements onto its end.Sort a List
Alist may be sorted by calling the
sort( )member function. The following program
creates a list of random integers and then puts the list into sorted order.
// Sort a list.
#include <iostream>
#include <list>
#include <cstdlib>
using namespace std;int main(){list<int> lst;
int i;// create a list of random integersfor(i=0; i<10; i++)lst.push_back(rand());cout << "Original contents:\n";
list<int>::iterator p = lst.begin();
while(p != lst.end()) {cout << *p << " ";
p++;}652C++:TheCompleteReference
cout << endl << endl;// sort the listlst.sort();cout << "Sorted contents:\n";p = lst.begin();
while(p != lst.end()) {cout << *p << " ";
p++;}return 0;}Here is sample output produced by the program:
Original contents:41 18467 6334 26500 19169 15724 11478 29358 26962 24464Sorted contents:41 6334 11478 15724 18467 19169 24464 26500 26962 29358Merging One List with Another
One ordered list may be merged with another. The result is an ordered list that contains
thecontentsofthetwooriginallists.Thenewlistisleftintheinvokinglist,andthe

second list is left empty. The next example merges two lists. The first contains the even

numbers between 0 and 9. The second contains the odd numbers. These lists are then

merged to produce the sequence 0 1 2 3 4 5 6 7 8 9.
// Merge two lists.#include <iostream>
#include <list>
using namespace std;int main(){list<int> lst1, lst2;
int i;Chapter24:IntroducingtheStandardTemplateLibrary
653C++654C++:TheCompleteReference
for(i=0; i<10; i+=2) lst1.push_back(i);for(i=1; i<11; i+=2) lst2.push_back(i);cout << "Contents of lst1:\n";list<int>::iterator p = lst1.begin();
while(p != lst1.end()) {cout << *p << " ";
p++;}
cout << endl << endl;cout << "Contents of lst2:\n";p = lst2.begin();
while(p != lst2.end()) {cout << *p << " ";
p++;}
cout << endl << endl;// now, merge the two listslst1.merge(lst2);
if(lst2.empty())cout << "lst2 is now empty\n";cout << "Contents of lst1 after merge:\n";
p = lst1.begin();
while(p != lst1.end()) {cout << *p << " ";
p++;}return 0;}The output produced by this program is shown here:
Contents of lst1:0 2 4 6 8Contents of lst2:1 3 5 7 9lst2 is now emptyContents of lst1 after merge:
0 1 2 3 4 5 6 7 8 9One other thing to notice about this example is the use of theempty( )function.It returns true if the invoking container is empty. Since
merge( )removes all of the
elements from the list being merged, it will be empty after the merge is completed,
as the program output confirms.
Storing Class Objects in a ListHere is an example that uses a list to store objects of type
myclass. Notice that the <, >,!=, and == are overloaded for objects of type
myclass. (For some compilers, you willnot need to define all of these. For other compilers, you may need to define additional
operators.)TheSTLusesthesefunctionstodeterminetheorderingandequalityof

objects in a container. Even though a list is not an ordered container, it still needs a way

to compare elements when searching, sorting, or merging.
// Store class objects in a list.#include <iostream>
#include <list>
#include <cstring>
using namespace std;class myclass {int a, b;int sum;public:myclass() { a = b = 0; }
myclass(int i, int j) {a = i;
b = j;
sum = a + b;}
int getsum() { return sum; }friend bool operator<(const myclass &o1,const myclass &o2);friend bool operator>(const myclass &o1,const myclass &o2);friend bool operator==(const myclass &o1,Chapter24:IntroducingtheStandardTemplateLibrary
655C++656C++:TheCompleteReference
const myclass &o2);friend bool operator!=(const myclass &o1,const myclass &o2);};bool operator<(const myclass &o1, const myclass &o2){return o1.sum < o2.sum;}bool operator>(const myclass &o1, const myclass &o2){return o1.sum > o2.sum;}bool operator==(const myclass &o1, const myclass &o2){return o1.sum == o2.sum;}bool operator!=(const myclass &o1, const myclass &o2){return o1.sum != o2.sum;}int main(){int i;// create first listlist<myclass> lst1;
for(i=0; i<10; i++) lst1.push_back(myclass(i, i));cout << "First list: ";list<myclass>::iterator p = lst1.begin();
while(p != lst1.end()) {cout << p->getsum() << " ";
p++;}cout << endl;// create a second listlist<myclass> lst2;
for(i=0; i<10; i++) lst2.push_back(myclass(i*2, i*3));cout << "Second list: ";p = lst2.begin();
while(p != lst2.end()) {cout << p->getsum() << " ";
p++;}
cout << endl;// now, merget lst1 and lst2lst1.merge(lst2);// display merged listcout << "Merged list: ";
p = lst1.begin();
while(p != lst1.end()) {cout << p->getsum() << " ";
p++;}return 0;}The program creates two lists of
myclassobjects and displays the contents of eachlist. It then merges the two lists and displays the result. The output from this program
is shown here:
First list: 0 2 4 6 8 10 12 14 16 18Second list: 0 5 10 15 20 25 30 35 40 45
Merged list: 0 0 2 4 5 6 8 10 10 12 14 15 16 18 20 25 30 35 40 45Chapter24:IntroducingtheStandardTemplateLibrary
657C++658C++:TheCompleteReference
MapsThemapclass supports an associative container in which unique keys are mapped
with values. In essence, a key is simply a name that you give to a value. Once a valuehas been stored, you can retrieve it by using its key. Thus, in its most general sense, a

mapisalistofkey/valuepairs.Thepowerofamapisthatyoucanlookupavalue

givenitskey.Forexample,youcoulddefineamapthatusesaperson'snameasits

key and stores that person's telephone number as its value. Associative containers are

becoming more popular in programming.
As mentioned, a map can hold only unique keys. Duplicate keys are not allowed.
To create a map that allows nonunique keys, use
multimap.Themapcontainer has the following template specification:template <class Key, class T, class Comp = less<Key>,class Allocator = allocator<pair<const key, T> > class mapHere,
Keyis the data type of the keys,Tis the data type of the values being stored
(mapped),and
Compisafunctionthatcomparestwokeys.Thisdefaultstothe
standard
less( )utility function object.Allocatoris the allocator (which defaultstoallocator) .Amaphas the following constructors:
explicit map(const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ) );map(const map<Key, T, Comp, Allocator> &ob);
template <class InIter> map(InIterstart, InIterend,const Comp &cmpfn= Comp( ), const Allocator &a= Allocator( ));Thefirstformconstructsanemptymap.Thesecondformconstructsamapthat

contains the same elements asob. The third form constructs a map that contains the
elements in the range specified by the iteratorsstartandend. The function specifiedbycmpfn,if present, determines the ordering of the map.
Ingeneral,anyobjectusedasakeyshoulddefineadefaultconstructorand
overload the < operator and any other necessary comparison operators. The specific
requirements vary from compiler to compiler.
The following comparison operators are defined for
map.==, <, <=, !=, >, >=Several of themapmember functions are shown in Table 24-4. In the descriptions,
key_typeis the type of the key, and
value_typerepresents
pair<Key, T>
.Chapter24:IntroducingtheStandardTemplateLibrary
659C++MemberDescriptioniterator begin( );const_iterator begin( ) const;Returns an iterator to the first
element in the map.void clear( );Removes all elements from the map.
size_type count(const key_type &k) const;Returns the number of times
koccursin the map (1 or zero).
bool empty( ) const;Returns true if the invoking map is
empty and false otherwise.iterator end( );const_iterator end( ) const;Returns an iterator to the end of
the list.void erase(iteratori);Removes the element pointed to byi.void erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend.size_type erase(const key_type &k)Removes from the map elements that
have keys with the valuek.iterator find(const key_type &k);
const_iterator find(const key_type &k)const;Returns an iterator to the specified
key.Ifthekeyisnotfound,then

aniterator to the end of the map

is returned.
iterator insert(iteratori,const value_type &val);Insertsvalat or after the elementspecified byi.An iterator to theelement is returned.
template <class InIter>void insert(InIterstart, InIterend)Inserts a range of elements.pair<iterator, bool>
insert(const value_type &val);Insertsvalinto the invoking map.An iterator to the element is returned.

The element is inserted only if it does
not already exist. If the element was

inserted,pair<iterator,true>is

returned. Otherwise, pair<iterator,

false> is returned.
Table24-4.
Several Commonly UsedmapMember Functions660C++:TheCompleteReference
Key/value pairs are stored in a map as objects of type
pair, which has thistemplate specification.template <class Ktype, class Vtype> struct pair {typedef Ktype first_type; // type of keytypedef Vtype second_type; // type of value
Ktype first; // contains the key
Vtype second; // contains the value// constructorspair();
pair(const Ktype &k, const Vtype &v);
template<class A, class B> pair(const<A, B> &ob);}As the comments suggest, the value infirstcontains the key and the value insecondcontains the value associated with that key.
Youcanconstructapairusingeitheroneof
pair'sconstructorsorbyusing
make_pair( ), which constructs a
pairobject based upon the types of the data usedas parameters.make_pair( )is a generic function that has this prototype.
template <classKtype, classVtype>pair<Ktype,Vtype> make_pair(constKtype&k, constVtype&v);As you can see, it returns a pair object consisting of values of the types specified by
KtypeandVtype. The advantage ofmake_pair( )is that the types of the objects beingMemberDescriptionmapped_type&operator[](constkey_type&
i)Returns a reference to the element
specified byi. If this element doesnot exist, it is inserted.size_type size( ) const;Returns the number of elements
currently in the list.
Table24-4.
Several Commonly UsedmapMember Functions (continued)stored are determined automatically by the compiler rather than being explicitly
specified by you.The following program illustrates the basics of using a map. It stores key/value
pairs that show the mapping between the uppercase letters and their ASCII character

codes. Thus, the key is a character and the value is an integer. The key/value pairs

stored are
A         65
B         66
C         67and so on. Once the pairs have been stored, you are prompted for a key (i.e., a letter

between Aand Z), and the ASCII code for that letter is displayed.
// A simple map demonstration.#include <iostream>
#include <map>
using namespace std;int main(){map<char, int> m;
int i;// put pairs into mapfor(i=0; i<26; i++) {m.insert(pair<char, int>('A'+i, 65+i));}char ch;cout << "Enter key: ";
cin >> ch;map<char, int>::iterator p;
// find value given keyp = m.find(ch);
if(p != m.end())cout << "Its ASCII value is  " << p->second;elsecout << "Key not in map.\n";Chapter24:IntroducingtheStandardTemplateLibrary
661C++return 0;}Notice the use of thepairtemplate class to construct the key/value pairs. The data
types specified bypairmust match those of themapinto which the pairs are being
inserted.Once the map has been initialized with keys and values, you can search for a value
given its key by using thefind( )function.find( )returns an iterator to the matching
element or to the end of the map if the key is not found. When a match is found, thevalue associated with the key is contained in thesecondmember ofpair.Intheprecedingexample,key/valuepairswereconstructedexplicitly,using
pair<char, int>
. While there is nothing wrong with this approach, it is often easier to

usemake_pair( ), which constructs a pair object based upon the types of the data used
as parameters. For example, assuming the previous program, this line of code will also

insert key/value pairs intom.m.insert(make_pair((char)('A'+i), 65+i));Here, the cast to
charis needed to override the automatic conversion tointwheniisadded to 'A.' Otherwise, the type determination is automatic.Storing Class Objects in a MapAswithallofthecontainers,youcanuseamaptostoreobjectsoftypesthatyou

create.Forexample,thenextprogramcreatesasimplephonedirectory.Thatis,it

createsamapofnameswiththeirnumbers.Todothis,itcreatestwoclassescalled

nameandnumber.Sinceamapmaintainsasortedlistofkeys,theprogramalso
definesthe
<operatorforobjectsoftype
name.Ingeneral,youmustdefinethe
<operatorforanyclassesthatyouwilluseasthekey.(Somecompilersmayrequire

thatadditionalcomparisonoperatorsbedefined.)
// Use a map to create a phone directory.#include <iostream>
#include <map>
#include <cstring>
using namespace std;class name {char str[40];public:name() { strcpy(str, ""); }662C++:TheCompleteReference
name(char *s) { strcpy(str, s); }char *get() { return str; }};// Must define less than relative to name objects.bool operator<(name a, name b)
{return strcmp(a.get(), b.get()) < 0;}class phoneNum {char str[80];public:phoneNum() { strcmp(str, ""); }phoneNum(char *s) { strcpy(str, s); }
char *get() { return str; }};int main(){map<name, phoneNum> directory;// put names and numbers into mapdirectory.insert(pair<name, phoneNum>(name("Tom"),phoneNum("555-4533")));directory.insert(pair<name, phoneNum>(name("Chris"),phoneNum("555-9678")));directory.insert(pair<name, phoneNum>(name("John"),phoneNum("555-8195")));directory.insert(pair<name, phoneNum>(name("Rachel"),phoneNum("555-0809")));// given a name, find number
char str[80];
cout << "Enter name: ";
cin >> str;map<name, phoneNum>::iterator p;
p = directory.find(name(str));Chapter24:IntroducingtheStandardTemplateLibrary
663C++664C++:TheCompleteReference
if(p != directory.end())cout << "Phone number: " <<  p->second.get();elsecout << "Name not in directory.\n";return 0;}Here is a sample run:
Enter name: RachelPhone number: 555-0809.Intheprogram,eachentryinthemapisacharacterarraythatholdsanull-terminated
string. Later in this chapter, you will see an easier way to write this program that uses
the standard
stringtype.AlgorithmsAs explained, algorithms act on containers. Although each container provides support

foritsownbasicoperations,thestandardalgorithmsprovidemoreextendedor

complex actions. They also allow you to work with two different types of containers

at the same time. To have access to the STLalgorithms, you must include
<algorithm>in your program.
The STLdefines a large number of algorithms, which are summarized in Table 24-5.
Allofthealgorithmsaretemplatefunctions.Thismeansthattheycanbeappliedto

anytypeofcontainer.AllofthealgorithmsintheSTLarecoveredinPartFour.The

followingsectionsdemonstratearepresentativesample.
CountingOne of the most basic operations that you can perform on a sequence is to count its
contents. To do this, you can use either
count( )orcount_if( ). Their general forms are
shown here:
template <class InIter, class T>ptrdiff_t count(InIterstart, InIterend, const T &val);template <class InIter, class UnPred>ptrdiff_t count_if(InIterstart, InIterend, UnPredpfn);The typeptrdiff_t
is defined as some form of integer.
Chapter24:IntroducingtheStandardTemplateLibrary
665C++AlgorithmPurposeadjacent_findSearches for adjacent matching elements within a
sequence and returns an iterator to the first match.
binary_search
Performs a binary search on an ordered sequence.
copyCopies a sequence.copy_backward
Same ascopy( )except that it moves the elements from
the end of the sequence first.countReturns the number of elements in the sequence.count_ifReturns the number of elements in the sequence thatsatisfy some predicate.
equalDetermines if two ranges are the same.
equal_rangeReturns a range in which an element can be insertedinto a sequence without disrupting the ordering of
the sequence.fill and fill_nFills a range with the specified value.findSearches a range for a value and returns an iterator to
the first occurrence of the element.
find_endSearches a range for a subsequence. It returns an iterator
to the end of the subsequence within the range.find_first_ofFinds the first element within a sequence that matchesan element within a range.find_ifSearches a range for an element  for which a user-defined
unary predicate returns true.
for_eachApplies a function to a range of elements.generate and generate_nAssign elements in a range the values returned by
a generator function.includesDetermines if one sequence includes all of the elementsin another sequence.inplace_merge
Mergesa
rangewithanotherrange.Bothrangesmustbe
sortedinincr
easingorder.Theresultingsequenceissorted.
iter_swapExchanges the values pointed to by its two iteratorarguments.
lexicographical_compareAlphabetically compares one sequence with another.
Table24-5.
The STL Algorithms666C++:TheCompleteReference
AlgorithmPurposelower_boundFinds the first point in the sequence that is not less thana specified value.make_heapConstructs a heap from a sequence.
maxReturns the maximum of two values.max_elementReturnsaniteratortothemaximumelementwithinarange.
merge
Merges two ordered sequences, placing the result into
a third sequence.
minReturns the minimum of two values.min_elementReturnsan
iteratortotheminimumelementwithinarange.
mismatchFinds first mismatch between the elements in twosequences. Iterators to the two elements are returned.
next_permutationConstructs next permutation of a sequence.
nth_elementArranges a sequence such that all elements less thana specified elementEcome before that element and
all elements greater than
Ecome after it.partial_sortSorts a range.partial_sort_copySorts a rangeand then copies as many elements as will
fit into a resulting sequence.
partitionArranges a sequence such that all elements for whicha predicate returns true come before those for which the
predicate returns false.
pop_heapExchanges the first and last−1 elements and thenrebuilds the heap.
prev_permutationConstructs previous permutation of a sequence.
push_heapPushes an element onto the end of a heap.random_shuffle
Randomizes a sequence.remove, remove_if,
remove_copy, and

remove_copy_if
Removes elements from a specified range.
replace, replace_copy,

replace_if, and

replace_copy_if
Replaces elements within a range.Table24-5.
The STL Algorithms (continued)Chapter24:IntroducingtheStandardTemplateLibrary
667C++AlgorithmPurposereverse and reverse_copyReverses the order of a range.
rotate and rotate_copyLeft-rotates the elements in a range.

searchSearches for subsequence within a sequence.

search_nSearches for a sequence of a specified number of similar
elements.set_differenceProduces a sequence that contains the difference between
two ordered sets.
set_intersectionProduces a sequence that contains the intersection of the
two ordered sets.
set_symmetric_differencePr
oducesasequencethatcontainsthesymmetricdifference
between the two ordered sets.
set_unionProduces a sequence that contains the union of the two
ordered sets.
sortSorts a range.

sort_heapSorts a heap within a specified range.

stable_partitionArranges a sequence such that all elements for which a
predicate returns true come before those for which the
predicate returns false. The partitioning is stable. This

means that the relative ordering of the sequence is

preserved.
stable_sortSorts a range. The sort is stable. This means that equal
elements are not rearranged.
swapExchanges two values.
swap_rangesExchanges elements in a range.

transformApplies a function to a range of elements and stores the
outcome in a new sequence.unique and unique_copyEliminates duplicate elements from a range.

upper_boundFinds the last point in a sequence that is not greater than
some value.Table24-5.
The STL Algorithms (continued)Thecount( )algorithm returns the number of elements in the sequence beginning at
startand ending atendthat matchval. Thecount_if( )algorithm returns the number
of elements in the sequence beginning atstartand ending atendfor which the unarypredicate
pfnreturns true.
The following program demonstrates
count( ).// Demonstrate count().#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
using namespace std;int main(){vector<bool> v;
unsigned int i;for(i=0; i < 10; i++) {if(rand() % 2) v.push_back(true);else v.push_back(false);}cout << "Sequence:\n";for(i=0; i<v.size(); i++)cout << boolalpha << v[i] << " ";cout << endl;i = count(v.begin(), v.end(), true);cout << i << " elements are true.\n";return 0;}This program displays the following output:
Sequence:true true false false true false false false false false
3 elements are true.668C++:TheCompleteReference
The program begins by creating a vector comprised of randomly generated true and
false values. Next,count( )is used to count the number oftruevalues.This next program demonstrates
count_if( ). It creates a vector containing the
numbers 1 through 19. It then counts those that are evenly divisible by 3. To do this,

it creates a unary predicate called
dividesBy3( ), which returns
trueif its argument
is evenly divisible by 3.// Demonstrate count_if().#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;/* This is a unary predicate that determinesif number is divisible by 3. */bool dividesBy3(int i){if((i%3) == 0) return true;return false;}
int main(){vector<int> v;
int i;for(i=1; i < 20; i++) v.push_back(i);
cout << "Sequence:\n";for(i=0; i<v.size(); i++)cout << v[i] << " ";cout << endl;i = count_if(v.begin(), v.end(), dividesBy3);cout << i << " numbers are divisible by 3.\n";return 0;}This program produces the following output.
Chapter24:IntroducingtheStandardTemplateLibrary
669C++Sequence:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
6 numbers are divisible by 3.Notice how the unary predicate
dividesBy3( )is coded. All unary predicates receive
as a parameter an object that is of the same type as that stored in the container upon
which the predicate is operating. The predicate must then return a
trueorfalseresult
based upon this object.Removing and Replacing ElementsSometimes it is useful to generate a new sequence that consists of only certain items
from an original sequence. One algorithm that does this is
remove_copy( ). Its generalform is shown here:
template <class InIter, class OutIter, class T>OutIter remove_copy(InIterstart, InIterend,OutIterresult, const T &val);Theremove_copy( )algorithm copies elements from the specified range, removing
those that are equal to
val. It puts the result into the sequence pointed to by
result
andreturns an iterator to the end of the result. The output container must be large enough

to hold the result.
To replace one element in a sequence with another when a copy is made, use
replace_copy( ). Its general form is shown here:
template <class InIter, class OutIter, class T>OutIter replace_copy(InIterstart, InIterend,OutIterresult, const T &old,const T &new);Thereplace_copy( )algorithm copies elements from the specified range, replacing
elements equal tooldwithnew. It puts the result into the sequence pointed to by
result
andreturnsaniteratortotheendoftheresult.Theoutputcontainermustbelarge

enough to hold the result.
The following program demonstrates
remove_copy( )andreplace_copy( ). Itcreates a sequence of characters. It then removes all of the spaces from the sequence.

Next, it replaces all spaces with colons.
// Demonstrate remove_copy and replace_copy.#include <iostream>
#include <vector>
#include <algorithm>670C++:TheCompleteReference
Chapter24:IntroducingtheStandardTemplateLibrary
671C++using namespace std;int main(){char str[] = "The STL is power programming.";
vector<char> v, v2(30);
unsigned int i;for(i=0; str[i]; i++) v.push_back(str[i]);
// **** demonstrate remove_copy ****cout << "Input sequence:\n";
for(i=0; i<v.size(); i++) cout << v[i];
cout << endl;// remove all spacesremove_copy(v.begin(), v.end(), v2.begin(), ' ');cout << "Result after removing spaces:\n";for(i=0; i<v2.size(); i++) cout << v2[i];
cout << endl << endl;// **** now, demonstrate replace_copy ****cout << "Input sequence:\n";
for(i=0; i<v.size(); i++) cout << v[i];
cout << endl;// replace spaces with colonsreplace_copy(v.begin(), v.end(), v2.begin(), ' ', ':');cout << "Result after replacing spaces with colons:\n";for(i=0; i<v2.size(); i++) cout << v2[i];
cout << endl << endl;return 0;}The output produced by this program is shown here.
Input sequence:The STL is power programming.
Result after removing spaces:
TheSTLispowerprogramming.Input sequence:The STL is power programming.
Result after replacing spaces with colons:
The:STL:is:power:programming.Reversing a SequenceAn often useful algorithm isreverse( ), which reverses a sequence. Its general form is
template <class BiIter> void reverse(BiIterstart, BiIterend);Thereverse( )algorithm reverses the order of the range specified by
startandend.The following program demonstrates
reverse( ).// Demonstrate reverse.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;int main(){vector<int> v;
unsigned int i;for(i=0; i<10; i++) v.push_back(i);
cout << "Initial: ";for(i=0; i<v.size(); i++) cout << v[i] << " ";
cout << endl;reverse(v.begin(), v.end());
cout << "Reversed: ";for(i=0; i<v.size(); i++) cout << v[i] << " ";return 0;}672C++:TheCompleteReference
The output from this program is shown here:
Initial: 0 1 2 3 4 5 6 7 8 9Reversed: 9 8 7 6 5 4 3 2 1 0Transforming a Sequence
One of the more interesting algorithms is
transform( )because it modifies each elementin a range according to a function that you provide. The
transform( )algorithm hasthese two general forms:template <class InIter, class OutIter, class Func)OutIter transform(InIterstart, InIterend, OutIterresult, Funcunaryfunc);template <class InIter1, class InIter2, class OutIter, class Func)OutIter transform(InIter1start1, InIter1end1, InIter2start2,OutIterresult, Funcbinaryfunc);Thetransform( )algorithm applies a function to a range of elements and stores
theoutcomein
result
.Inthefirstform,therangeisspecifiedby
startandend.The
functiontobeappliedisspecified
unaryfunc.Thisfunctionreceivesthevalueofan
element in its parameter, and it must return its transformation. In the second form, the
transformation is applied using a binary operator function that receives the value of an

element from the sequence to be transformed in its first parameter and an element from

the second sequence as its second parameter. Both versions return an iterator to the end

of the resulting sequence.
The following program uses a simple transformation function called
reciprocal( )totransformthecontentsofalistofnumbersintotheirreciprocals.Noticethatthe

resulting sequence is stored in the same list that provided the original sequence.
// An example of the transform algorithm.#include <iostream>
#include <list>
#include <algorithm>
using namespace std;// A simple transformation function.double reciprocal(double i) {return 1.0/i; // return reciprocal}int main()Chapter24:IntroducingtheStandardTemplateLibrary
673C++{list<double> vals;int i;// put values into listfor(i=1; i<10; i++) vals.push_back((double)i);cout << "Original contents of vals:\n";list<double>::iterator p = vals.begin();
while(p != vals.end()) {cout << *p << " ";
p++;}cout << endl;
// transform valsp = transform(vals.begin(), vals.end(),vals.begin(), reciprocal);cout << "Transformed contents of vals:\n";
p = vals.begin();
while(p != vals.end()) {cout << *p << " ";
p++;}return 0;}The output produced by the program is shown here:
Original contents of vals:1 2 3 4 5 6 7 8 9
Transformed contents of vals:
1 0.5 0.333333 0.25 0.2 0.166667 0.142857 0.125 0.111111As you can see, each element invalshas been transformed into its reciprocal.
674C++:TheCompleteReference
Chapter24:IntroducingtheStandardTemplateLibrary
675C++Using Function ObjectsAs explained at the start of this chapter, the STLsupports (and extensively utilizes)
function objects. Recall that function objects are simply classes that define
operator( ).The STLprovides many built-in function objects, such as
less,minus, etc. It also allowsyoutodefineyourownfunctionobjects.Frankly,itisbeyondthescopeofthisbook

to fully describe all of the issues surrounding the creation and use of function objects.

Fortunately, as the preceding examples have shown, you can make significant use of

the STLwithout ever creating a function object. However, since function objects are

a main ingredient of the STL, it is important to have a general understanding.
Unary and Binary Function Objects
Justasthereareunaryandbinarypredicates,thereareunaryandbinaryfunctionobjects.

Aunary function object requires one argument; a binary function object requires two.

You must use the type of object required. For example, if an algorithm is expecting

a binary function object, you must pass it a binary function object.Using the Built-in Function ObjectsThe STLprovides a rich assortment of built-in function objects. The binary function

objects are shown here:
plusminusmultipliesdividesmodulus
equal_tonot_equal_togreatergreater_equalless

less_equallogical_andlogical_or
Here are the unary function objects:
logical_notnegate
The function objects perform the operations specified by their names. The only one thatmay not be self-evident isnegate( ), which reverses the sign of its argument.
The built-in function objects are template classes that overload
operator( ), whichreturns the result of the specified operation on whatever type of data you select. For

example, to invoke the binary function objectplus( )forfloatdata, use this syntax:plus<float>()The built-in function objects use the header<functional>.676C++:TheCompleteReference
Let's begin with a simple example. The following program uses the
transform( )algorithm (described in the preceding section) and the
negate( )function object toreverse the sign of a list of values.
// Use a unary function object.#include <iostream>
#include <list>
#include <functional>
#include <algorithm>
using namespace std;int main(){list<double> vals;
int i;// put values into listfor(i=1; i<10; i++) vals.push_back((double)i);cout << "Original contents of vals:\n";list<double>::iterator p = vals.begin();
while(p != vals.end()) {cout << *p << " ";
p++;}
cout << endl;// use the negate function objectp = transform(vals.begin(), vals.end(),vals.begin(),
negate<double>()); // call function objectcout << "Negated contents of vals:\n";
p = vals.begin();
while(p != vals.end()) {cout << *p << " ";
p++;}return 0;}This program produces the following output:
Original contents of vals:1 2 3 4 5 6 7 8 9
Negated contents of vals:
-1 -2 -3 -4 -5 -6 -7 -8 -9In the program, notice how
negate( )is invoked. Sincevalsis a list ofdoublevalues,negate( )is called usingnegate<double>( ). Thetransform( )algorithm automaticallycallsnegate( )for each element in the sequence. Thus, the single parameter tonegate( )receives as its argument an element from the sequence.
The next program demonstrates the use of the binary function object
divides( ). Itcreates two lists of double values and has one divide the other. This program uses the
binary form of thetransform( )algorithm.// Use a binary function object.#include <iostream>
#include <list>
#include <functional>
#include <algorithm>
using namespace std;int main(){list<double> vals;
list<double> divisors;
int i;// put values into listfor(i=10; i<100; i+=10) vals.push_back((double)i);
for(i=1; i<10; i++) divisors.push_back(3.0);cout << "Original contents of vals:\n";list<double>::iterator p = vals.begin();
while(p != vals.end()) {cout << *p << " ";
p++;}cout << endl;
// transform valsChapter24:IntroducingtheStandardTemplateLibrary
677C++p = transform(vals.begin(), vals.end(),divisors.begin(), vals.begin(),divides<double>()); // call function objectcout << "Divided contents of vals:\n";
p = vals.begin();
while(p != vals.end()) {cout << *p << " ";p++;}return 0;}The output from this program is shown here:
Original contents of vals:10 20 30 40 50 60 70 80 90
Divided contents of vals:
3.33333 6.66667 10 13.3333 16.6667 20 23.3333 26.6667 30In this case, the binary function objectdivides( )divides the elements from the first
sequence by their corresponding elements from the second sequence. Thus,
divides( )receives arguments in this order:
divides(first,second)This order can be generalized. Whenever a binary function object is used, its arguments
are ordered
first,second.Creating a Function Object
In addition to using the built-in function objects, you can create your own. To do so,

you will simply create a class that overloads the
operator( )function. However, for the
greatest flexibility, you will want to use one of the following classes defined by the STL

as a base class for your function objects.template <class Argument, class Result> struct unary_function {typedef Argument argument_type;typedef Result result_type;};678C++:TheCompleteReference
template <class Argument1, class Argument2, class Result>struct binary_function {typedef Argument1 first_argument_type;typedef Argument2 second_argument_type;
typedef Result result_type;};These template classes provide concrete type names for the generic data types used
by the function object. Although they are technically a convenience, they are almost

always used when creating function objects.
The following program demonstrates a custom function object. It converts the
reciprocal( )function (used to demonstrate thetransform( )algorithm earlier) intoa function object.// Create a reciprocal function object.#include <iostream>
#include <list>
#include <functional>
#include <algorithm>
using namespace std;// A simple function object.class reciprocal: unary_function<double, double> {
public:result_type operator()(argument_type i)
{return (result_type) 1.0/i; // return reciprocal}};int main(){list<double> vals;
int i;// put values into listfor(i=1; i<10; i++) vals.push_back((double)i);cout << "Original contents of vals:\n";list<double>::iterator p = vals.begin();
while(p != vals.end()) {Chapter24:IntroducingtheStandardTemplateLibrary
679C++cout << *p << " ";p++;}cout << endl;// use reciprocal function objectp = transform(vals.begin(), vals.end(),vals.begin(),
reciprocal()); // call function objectcout << "Transformed contents of vals:\n";
p = vals.begin();
while(p != vals.end()) {cout << *p << " ";
p++;}return 0;}Noticetwoimportantaspectsof
reciprocal()
.First,itinheritsthebaseclass
unary_function.Thisgivesitaccesstothe
argument_typeandresult_typetypes.Second,itdefines
operator()
suchthatitreturnsthereciprocalofitsargument.In
general, to create a function object, simply inherit the proper base class and overload
operator( )as required. It really is that easy.
Using BindersWhenusingabinaryfunctionobject,itispossibletobindavaluetooneofthe

arguments.Thiscanbeusefulinmanysituations.Forexample,youmaywishto

removeallelementsfromasequencethataregreaterthansomevalue,suchas8.

To do this, you need some way to bind 8to the right-hand operand of the function

objectgreater( ). That is, you wantgreater( )to perform the comparisonval > 8for each element of the sequence. The STLprovides a mechanism, called
binders, thataccomplishes this.There are two binders:
bind2nd( )andbind1st( ). They take these general forms:bind1st(binfunc_obj, value)bind2nd(binfunc_obj, value)680C++:TheCompleteReference
Chapter24:IntroducingtheStandardTemplateLibrary
681C++Here,
binfunc_objis a binary function object.bind1st( )returns a unary function object
that hasbinfunc_obj's left-hand operand bound tovalue.bind2nd( )returns a unary
function objectthathas
binfunc_obj'sright-handoperandboundto
value. Thebind2nd( )binder is by far the most commonly used. In either case, the outcome of a binder isa unary function object that is bound to the value specified.To demonstrate the use of a binder, we will use the
remove_if( )algorithm. Itremoves elements from a sequence based upon the outcome of a predicate. It has

this prototype:
template <class ForIter, class UnPred>ForIter remove_if(ForIterstart, ForIterend, UnPredfunc);Thealgorithmremoveselementsfromthesequencedefinedby
startandendifthe
unarypredicatedefinedby
funcistrue.Thealgorithmreturnsapointertothenew
endofthesequencewhichreflectsthedeletionoftheelements.
The following program removes all values from a sequence that are greater than
thevalue8.Sincethepredicaterequiredby
remove_if()
isunary,wecannotsimply
use thegreater( )function object as-is becausegreater( )is a binary object. Instead, wemust bind the value 8 to the second argument of
greater( )using thebind2nd( )binder,
as shown in the program.
// Demonstrate bind2nd().#include <iostream>
#include <list>
#include <functional>
#include <algorithm>
using namespace std;int main(){list<int> lst;
list<int>::iterator p, endp;int i;
for(i=1; i < 20; i++) lst.push_back(i);
cout << "Original sequence:\n";p = lst.begin();
while(p != lst.end()) {cout << *p << " ";
p++;}cout << endl;endp = remove_if(lst.begin(), lst.end(),bind2nd(greater<int>(), 8));cout << "Resulting sequence:\n";p = lst.begin();
while(p != endp) {cout << *p << " ";
p++;}return 0;}The output produced by the program is shown here:
Original sequence:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
Resulting sequence:
1 2 3 4 5 6 7 8You might want to experiment with this program, trying different function objects and
binding different values. As you will discover, binders expand the power of the STLin

very significant ways.One last point: There is an object related to a binder called a
negator. The negatorsare
not1( )andnot2( ). They return the negation (i.e., the complement of) whatever
predicate they modify. They have these general forms:
not1(unary_predicate)
not2(binary_predicate)For example, if you substitute the lineendp = remove_if(lst.begin(), lst.end(),not1(bind2nd(greater<int>(), 8)));into the preceding program, it will remove all elements from
lstthat are not
greater than 8.
682C++:TheCompleteReference
The string ClassAs you know, C++ does not support a built-in string type per se. It does, however,
provide for two ways of handling strings. First, you may use the traditional, null-

terminated character array with which you are already familiar. This is sometimes

referred to as a
C string. The second way is as a class object of typestring; this is theapproach examined here.
Actually, the
stringclass is a specialization of a more general template class called
basic_string.Infact,therearetwospecializationsof
basic_string:string,which
supports 8-bit character strings, andwstring, which supports wide-character strings.Since 8-bit characters are by far the most commonly used in normal programming,

stringis the version ofbasic_stringexamined here.
Before looking at the
stringclass, it is important to understand why it is part of theC++ library. Standard classes have not been casually added to C++. In fact, a significant

amount of thought and debate has accompanied each new addition. Given that C++
already contains some support for strings as null-terminated character arrays, it may

at first seem that the inclusion of thestringclass is an exception to this rule. However,
thisisactuallyfarfromthetruth.Hereiswhy:Null-terminatedstringscannotbe

manipulated by any of the standard C++ operators. Nor can they take part in normal

C++ expressions. For example, consider this fragment:
char s1[80], s2[80], s3[80];s1 = "Alpha"; // can't dos2 = "Beta"; // can't do
s3 = s1 + s2; // error, not allowedAs the comments show, in C++ it is not possible to use the assignment operator to give
a character array a new value (except during initialization), nor is it possible to use the
+ operator to concatenate two strings. These operations must be written using library
functions, as shown here:
strcpy(s1, "Alpha");strcpy(s2, "Beta");
strcpy(s3, s1);
strcat(s3, s2);Sincenull-terminatedcharacterarraysarenottechnicallydatatypesintheir
own right, the C++ operators cannot be applied to them. This makes even the mostrudimentary string operations clumsy. More than anything else, it is the inability to

operate on null-terminated strings using the standard C++ operators that has driven

the development of a standard string class. Remember, when you define a class in C++,
Chapter24:IntroducingtheStandardTemplateLibrary
683C++684C++:TheCompleteReference
youaredefininganewdatatypethatcanbefullyintegratedintotheC++environment.
This, of course, means that the operators can be overloaded relative to the new class.

Therefore, by adding a standard string class, it becomes possible to manage strings in

the same way as any other type of data: through the use of operators.
Thereis,however,oneotherreasonforthestandardstringclass:safety.Inthehands
of an inexperienced or careless programmer, it is very easy to overrun the end of an

array that holds a null-terminated string. For example, consider the standard string

copy functionstrcpy( ). This function contains no provision for checking the boundary
ofthetargetarray.Ifthesourcearraycontainsmorecharactersthanthetargetarray

can hold, then a program error or system crash is possible (likely). As you will see, the

standard
stringclass prevents such errors.
In the final analysis, there are three reasons for the inclusion of the standard
stringclass:consistency(astringnowdefinesadatatype),convenience(youmayusethe

standard C++ operators), and safety (array boundaries will not be overrun). Keep in

mind that there is no reason that you should abandon normal, null-terminated strings

altogether.Theyarestillthemostefficientwayinwhichtoimplementstrings.However,

when speed is not an overriding concern, using the newstringclass gives you access toa safe and fully integrated way to manage strings.Although not traditionally thought of as part of the STL,stringis another containerclassdefinedbyC++.Thismeansthatitsupportsthealgorithmsdescribedinthe

previoussection.However,stringshaveadditionalcapabilities.Tohaveaccessto

thestringclass, you must include<string>in your program.
Thestringclass is very large, with many constructors and member functions. Also,
manymemberfunctionshavemultipleoverloadedforms.Forthisreason,itisnot

possible to look at the entire contents of
stringin this chapter. Instead, we will examine
several of its most commonly used features. Once you have a general understanding of

howstringworks, you can easily explore the rest of it on your own.
Thestringclass supports several constructors. The prototypes for three of its most
commonly used ones are shown here:
string( );
string(const char *str);
string(const string &str);Thefirstformcreatesanempty
stringobject.Thesecondcreatesa
stringobjectfromthe
null-terminatedstringpointedtoby
str.Thisformprovidesaconversionfromnull-
terminated strings tostringobjects. The third form creates a
stringfrom another
string.Anumberofoperatorsthatapplytostringsaredefinedfor
stringobjects,including:
Chapter24:IntroducingtheStandardTemplateLibrary
685C++OperatorMeaning=Assignment+Concatenation+=Concatenation assignment==Equality!=Inequality<Less than<=Less than or equal>Greater than
>=Greater than or equal
[ ]Subscripting<<Output>>InputThese operators allow the use ofstringobjects in normal expressions and eliminate
the need for calls to functions such asstrcpy( )orstrcat( ), for example. In general, youcanmix
stringobjectswithnormal,null-terminatedstringsinexpressions.Forexample,
astringobject can be assigned a null-terminated string.The + operator can be used to concatenate a string object with another string objector a string object with a C-style string. That is, the following variations are supported:
string + stringstring + C-string
C-string + stringThe + operator can also be used to concatenate a character onto the end of a string.Thestringclass defines the constantnpos, which is−1. This constant represents
the length of the longest possible string.The C++ string classes make string handling extraordinarily easy. For example,
usingstringobjects you can use the assignment operator to assign a quoted stringto astring, the + operator to concatenate strings, and the comparison operators tocompare strings. The following program illustrates these operations.
// A short string demonstration.#include <iostream>
#include <string>
using namespace std;int main(){string str1("Alpha");
string str2("Beta");
string str3("Omega");
string str4;// assign a stringstr4 = str1;
cout << str1 << "\n" << str3 << "\n";// concatenate two stringsstr4 = str1 + str2;
cout << str4 << "\n";// concatenate a string with a C-stringstr4 = str1 + " to " + str3;
cout << str4 << "\n";// compare stringsif(str3 > str1) cout << "str3 > str1\n";
if(str3 == str1+str2)cout << "str3 == str1+str2\n";/* A string object can also beassigned a normal string. */str1 = "This is a null-terminated string.\n";
cout << str1;// create a string object using another string objectstring str5(str1);
cout << str5;// input a stringcout << "Enter a string: ";
cin >> str5;
cout << str5;686C++:TheCompleteReference
C++return 0;}This program produces the following output:
AlphaOmega
AlphaBeta
Alpha to Omega
str3 > str1
This is a null-terminated string.
This is a null-terminated string.
Enter a string: STL
STLNotice the ease with which the string handling is accomplished. For example, the+isusedtoconcatenatestringsandthe
>isusedtocomparetwostrings.Toaccomplish
theseoperationsusingC-style,null-terminatedstrings,lessconvenientcallstothe
strcat()
andstrcmp()
functionswouldberequired.BecauseC++
stringobjectscanbefreely
mixed with C-style null-terminated strings, there is no disadvantage to using them in
your program—and there are considerable benefits to be gained.
There is one other thing to notice in the preceding program: the size of the strings
is not specified.stringobjects are automatically sized to hold the string that they are
given.Thus,whenassigningorconcatenatingstrings,thetargetstringwillgrowas

neededtoaccommodatethesizeofthenewstring.Itisnotpossibletooverrunthe

end of the string. This dynamic aspect ofstringobjectsis one of the ways that they are
better than standard null-terminated strings (which
are
subject to boundary overruns).
Some string Member FunctionsAlthoughmostsimplestringoperationscanbeaccomplishedusingthestring

operators,morecomplexorsubtleonesareaccomplishedusing
stringmemberfunctions.While
stringhasfartoomanymemberfunctionstodiscussthemall,
wewillexamineseveralofthemostcommon.
Basic String ManipulationsTo assign one string to another, use the
assign( )function. Two of its forms are
shown here.
Chapter24:IntroducingtheStandardTemplateLibrary
687688C++:TheCompleteReference
string &assign(const string &strob, size_typestart, size_typenum);string &assign(const char *str, size_typenum);In the first form,numcharacters from
strob
beginning at the index specified bystartwillbeassignedtotheinvokingobject.Inthesecondform,thefirst
numcharactersofthe
null-terminated stringstrare assigned to the invoking object. In each case, a reference
to the invoking object is returned. Of course, it is much easier to use the
=to assign oneentire string to another. You will need to use the
assign( )function only when assigninga partial string.You can append part of one string to another using the
append( )member function.Two of its forms are shown here:
string &append(const string &strob, size_typestart, size_typenum);string &append(const char *str, size_typenum);Here,
numcharactersfrom
strob
beginningattheindexspecifiedby
startwillbe
appendedtotheinvokingobject.Inthesecondform,thefirst
numcharactersofthe
null-terminated stringstrare appended to the invoking object. In each case, a reference
totheinvokingobjectisreturned.Ofcourse,itismucheasiertousethe
+toappend
oneentirestringtoanother.Youwillneedtousethe
append()
functiononlywhen
appending a partial string.You can insert or replace characters within a string using
insert( )andreplace( ).The prototypes for their most common forms are shown here:
string &insert(size_typestart, const string &strob);string &insert(size_typestart, const string &strob,size_typeinsStart,size_typenum);string &replace(size_typestart, size_typenum, const string &strob);string &replace(size_typestart, size_typeorgNum, const string &strob,size_typereplaceStart, size_typereplaceNum);The first form ofinsert( )insertsstrobinto the invoking string at the index specifiedbystart.Thesecondformof
insert()
functioninserts
numcharactersfrom
strob
beginningatinsStartinto the invoking string at the index specified bystart.Beginning atstart, the first form ofreplace( )replaces
numcharacters from the
invoking string, withstrob
. The second form replaces
orgNum
characters, beginningat start, in the invoking string with thereplaceNum
characters from the string specified
bystrob
beginningat
replaceStart.
Inbothcases,areferencetotheinvokingobjectis
returned.
You can remove characters from a string using
erase( ). One of its forms isshown here:
Chapter24:IntroducingtheStandardTemplateLibrary
689C++string &erase(size_typestart= 0, size_typenum= npos);It removes
numcharacters from the invoking string beginning at
start. Areference to
the invoking string is returned.
The following program demonstrates the
insert( ),erase( ), andreplace( )functions.// Demonstrate insert(), erase(), and replace().#include <iostream>
#include <string>
using namespace std;int main(){string str1("String handling C++ style.");
string str2("STL Power");cout << "Initial strings:\n";cout << "str1: " << str1 << endl;
cout << "str2: " << str2 << "\n\n";// demonstrate insert()cout << "Insert str2 into str1:\n";
str1.insert(6, str2);
cout << str1 << "\n\n";// demonstrate erase()cout << "Remove 9 characters from str1:\n";
str1.erase(6, 9);
cout << str1 <<"\n\n";// demonstrate replacecout << "Replace 8 characters in str1 with str2:\n";
str1.replace(7, 8, str2);
cout << str1 << endl;return 0;}The output produced by this program is shown here.
Initial strings:str1: String handling C++ style.
str2: STL PowerInsert str2 into str1:StringSTL Power handling C++ style.Remove 9 characters from str1:String handling C++ style.Replace 8 characters in str1 with str2:String STL Power C++ style.Searching a String
Thestringclass provides several member functions that search a string, including
find()
andrfind()
.Herearetheprototypesforthemostcommonversionsof
these functions:size_type find(const string &strob, size_typestart=0) const;size_type rfind(const string &strob, size_typestart=npos) const;Beginning atstart,find( )searches the invoking string for the first occurrence of
the string contained instrob
. If found,find( )returns the index at which the match
occurs within the invoking string. If no match is found, thennposis returned.
rfind( )istheoppositeof
find()
.Beginningat
start,itsearchestheinvokingstringinthe
reverse direction for the first occurrence of the string contained in
strob
(i.e, it findsthe last occurrence of
strob
within the invoking string). If found,rfind( )returns the
index at which the match occurs within the invoking string. If no match is found,nposis returned.
Here is a short example that uses
find( )andrfind( ).#include <iostream>#include <string>
using namespace std;int main(){int i;
string s1 ="Quick of Mind, Strong of Body, Pure of Heart";string s2;690C++:TheCompleteReference
i = s1.find("Quick");if(i!=string::npos) {cout << "Match found at " << i << endl;cout << "Remaining string is:\n";
s2.assign(s1, i, s1.size());
cout << s2;}
cout << "\n\n";i = s1.find("Strong");if(i!=string::npos) {cout << "Match found at " << i << endl;
cout << "Remaining string is:\n";
s2.assign(s1, i, s1.size());
cout << s2;}
cout << "\n\n";i = s1.find("Pure");if(i!=string::npos) {cout << "Match found at " << i << endl;
cout << "Remaining string is:\n";
s2.assign(s1, i, s1.size());
cout << s2;}
cout << "\n\n";// find list "of"i = s1.rfind("of");
if(i!=string::npos) {cout << "Match found at " << i << endl;
cout << "Remaining string is:\n";
s2.assign(s1, i, s1.size());
cout << s2;}return 0;}The output produced by this program is shown here.
Chapter24:IntroducingtheStandardTemplateLibrary
691C++Match found at 0Remaining string is:
Quick of Mind, Strong of Body, Pure of HeartMatch found at 15Remaining string is:
Strong of Body, Pure of HeartMatch found at 31Remaining string is:
Pure of HeartMatch found at 36Remaining string is:
of HeartComparing StringsTo compare the entire contents of one string object to another, you will normally use
the overloaded relational operators described earlier. However, if you want to compare

aportionofonestringtoanother,youwillneedtousethe
compare()
memberfunction,
shown here:
int compare(size_typestart, size_typenum, const string &strob) const;Here,
numcharacters instrob
, beginning atstart, will be compared against the invoking
string. If the invoking string is less thanstrob
,compare( )will return less than zero. If
the invoking string is greater than
strob
, it will return greater than zero. If
strob
is equalto the invoking string,compare( )will return zero.
Obtaining a Null-Terminated String
Althoughstringobjects are useful in their own right, there will be times when you will
need to obtain a null-terminated character-array version of the string. For example, you

mightusea
stringobjecttoconstructafilename.However,whenopeningafile,youwill
need to specify a pointer to a standard, null-terminated string. To solve this problem,

the member functionc_str( )is provided. Its prototype is shown here:
const char *c_str( ) const;This function returns a pointer to a null-terminated version of the string contained in

the invokingstringobject. The null-terminated string must not be altered. It is also not
guaranteed to be valid after any other operations have taken place on thestringobject.692C++:TheCompleteReference
Chapter24:IntroducingtheStandardTemplateLibrary
693C++Strings Are Containers
Thestringclass meets all of the basic requirements necessary to be a container. Thus,
it supports the common container functions, such asbegin( ),end( ), andsize( ). Italso supports iterators. Therefore, a
stringobject can also be manipulated by the STLalgorithms. Here is a simple example:
// Strings as containers.#include <iostream>
#include <string>
#include <algorithm>
using namespace std;int main(){string str1("Strings handling is easy in C++");
string::iterator p;
unsigned int i;// use size()for(i=0; i<str1.size(); i++)cout << str1[i];cout << endl;// use iteratorp = str1.begin();
while(p != str1.end())cout << *p++;cout << endl;// use the count() algorithmi = count(str1.begin(), str1.end(), 'i');
cout << "There are " << i << " i's in str1\n";// use transform() to upper case the stringtransform(str1.begin(), str1.end(), str1.begin(),toupper);p = str1.begin();
while(p != str1.end())cout << *p++;cout << endl;return 0;}Output from the program is shown here:
Strings handling is easy in C++Strings handling is easy in C++
There are 4 i's in str1
STRINGS HANDLING IS EASY IN C++Putting Strings into Other ContainersEven thoughstringis a container, objects of type string are commonly held in other
STLcontainers, such as maps or lists. For example, here is a better way to write the
telephone directory program shown earlier. It uses a map of
stringobjects, ratherthan null-terminated strings, to hold the names and telephone numbers.// Use a map of strings to create a phone directory.#include <iostream>
#include <map>
#include <string>
using namespace std;int main(){map<string, string> directory;directory.insert(pair<string, string>("Tom", "555-4533"));directory.insert(pair<string, string>("Chris", "555-9678"));
directory.insert(pair<string, string>("John", "555-8195"));
directory.insert(pair<string, string>("Rachel", "555-0809"));string s;cout << "Enter name: ";
cin >> s;map<string, string>::iterator p;
p = directory.find(s);if(p != directory.end())cout << "Phone number: " << p->second;694C++:TheCompleteReference
elsecout << "Name not in directory.\n";return 0;}Final Thoughts on the STLThe STLis an important, integral part of the C++ language. Many programming tasks
can (and will) be framed in terms of it. The STLcombines power with flexibility, and

while its syntax is a bit complex, its ease of use is remarkable. No C++ programmer

can afford to neglect the STLbecause it will play an important role in the way future

programs are written.
Chapter24:IntroducingtheStandardTemplateLibrary
695C++This page intentionally left blank Part III
The Standard Function LibraryC++definestwotypesoflibraries.Thefirstisthestandardfunction
library.Thislibraryconsistsofgeneral-purpose,stand-alonefunctions

thatarenotpartofanyclass.ThefunctionlibraryisinheritedfromC.

Thesecondlibraryistheobject-orientedclasslibrary.PartThreeofthe

bookprovidesareferencetothestandardfunctionlibrary.PartFour

describes the class library.Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
The standard function library is divided into the following categories:
I/OString and character handlingMathematicalTime, date, and localization
Dynamic allocationMiscellaneousWide-character functions
The last category was added to Standard C in 1995 and was subsequently incorporated
into C++. It provides wide-character (
wchar_t) equivalents to several of the library
functions. Frankly, the use of the wide-character library has been very limited, and

C++ provides a better way of handling wide-character environments, but it is briefly

described in Chapter 31 for completeness.C99 added some new elements to the C function library. Several of these additions,
such as support for complex arithmetic and type-generic macros for the mathematical

functions,duplicatefunctionalityalreadyfoundinC++.Someprovidenewfeatures

thatmightbeincorporatedintoC++inthefuture.Inallcases,thelibraryelements

added by C99 are incompatible with C++. Thus, the additions made to the Standard

C library by C99 are not discussed in this book.
One last point: All compilers supply more functions than are defined by Standard
C/C++. These additional functions typically provide for operating-system interfacing

and other environment-dependent operations. You will want to check your compiler's

documentation.Chapter25
The C-BasedI/O Functions699Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This chapter describes the C-based I/O functions. These functions are alsosupported  by Standard C++. While you will usually want to use C++'s object-
orientedI/Osystemfornewcode,thereisnofundamentalreasonthatyou
cannotusetheCI/OfunctionsinaC++programwhenyoudeemitappropriate.

ThefunctionsinthischapterwerefirstspecifiedbytheANSICstandard,andthey

arecommonly referred to collectively as the ANSI C I/O system.
TheheaderassociatedwiththeC-basedI/Ofunctionsiscalled
<cstdio>.(ACprogram
must use the header filestdio.h.) This header defines several macros and types used by
the file system. The most important type isFILE, which is used to declare a file pointer.
Two other types are
size_tandfpos_t. Thesize_ttype (usually some form of unsignedinteger)definesanobjectthatiscapableofholdingthesizeofthelargestfileallowedby

theoperatingenvironment.The
fpos_ttypedefinesanobjectthatcanholdallinformation
neededtouniquelyspecifyeverypositionwithinafile.Themostcommonlyusedmacro

defined by the headers isEOF, which is the value that indicates end-of-file.Many of the I/O functions set the built-in global integer variableerrnowhen anerroroccurs.Yourprogramcancheckthisvariablewhenanerroroccurstoobtain

more information about the error. The values that
errnomay take are implementation
dependent.For an overview of the C-based I/O system, see Chapters 8 and 9 in Part One.This chapter describes the character-based I/O functions. These are the functions that

were originally defined for Standard C and C++ and are, by far, the most widely used.

In 1995, several wide-character (wchar_t) functions were added, and they are briefly
described in Chapter 31.clearerr
#include <cstdio>void clearerr(FILE *stream);Theclearerr( )function resets (i.e., sets to zero) the error flag associated with the
stream pointed to by
stream
. The end-of-file indicator is also reset.
The error flags for each streamare
initiallysettozerobyasuccessfulcallto
fopen( )
.Fileerrorscanoccurforawidevarietyofreasons,manyofwhicharesystem
dependent. The exact nature of the error can be determined by calling
perror( ), whichdisplays what error has occurred (see
perror( )).Related functions are
feof( ),ferror( ), andperror( ).700C++:TheCompleteReference
THESTANDARD
FUNCTIONLIBRARY
Chapter25:TheC-BasedI/OFunctions
701fclose#include <cstdio>int fclose(FILE *stream);Thefclose( )function closes the file associated withstream
and flushes its buffer.
After anfclose( ),stream
is no longer connected with the file, and any automaticallyallocated buffers are deallocated.
Iffclose( )is successful, zero is returned; otherwise
EOFis returned. Trying to close
afilethathasalreadybeenclosedisanerror.Removingthestoragemediabefore
closing a file will also generate an error, as will lack of sufficient free disk space.
Related functions are
fopen( ),freopen()
, andfflush( )
.feof#include <cstdio>int feof(FILE *stream);Thefeof( )function checks the file position indicator to determine if the end of thefileassociatedwith
stream
hasbeenreached.Anonzerovalueisreturnedifthefileposition
indicator is at end-of-file; zero is returned otherwise.
Once the end of the file has been reached, subsequent read operations will return
EOFuntil eitherrewind()
iscalledorthefilepositionindicatorismovedusing
fseek( )
.Thefeof( )function is particularly useful when working with binary files becausetheend-of-filemarkerisalsoavalidbinaryinteger.Explicitcallsmustbemadeto
feof( )rather than simply testing the return value of
getc( ), for example, to determinewhen the end of a binary file has been reached.
Related functions are
clearerr( ),ferror( ),perror( ),putc()
, andgetc( ).ferror
#include <cstdio>int ferror(FILE *stream);Theferror( )function checks for a file error on the given
stream
. Areturn value of
zero indicates that no error has occurred, while a nonzero value means an error.
702C++:TheCompleteReference
To determine the exact nature of the error, use the
perror( )function.Related functions are
clearerr(),feof( ), andperror( ).fflush
#include <cstdio>int fflush(FILE *stream);Ifstream
is associated with a file opened for writing, a call tofflush( )
causes thecontents of the output buffer to be physically written to the file. The file remains open.
Areturn value of zero indicates success;
EOFindicates that a write error has
occurred.
All buffers are automatically flushed upon normal termination of the program or
when they are full. Also, closing a file flushes its buffer.
Related functions are
fclose( ),fopen( ),fread( ),fwrite( ),getc( ), andputc( ).fgetc#include <cstdio>
int fgetc(FILE *stream);Thefgetc( )function returns the next character from the input
stream
from the
current position and increments the file position indicator. The character is read as
anunsigned charthat is converted to an integer.
If the end of the file is reached,
fgetc( )returns
EOF. However, since
EOFis a validinteger value, when working with binary files you must usefeof( )to check for the endof the file. Iffgetc( )encounters an error,
EOFis also returned. If working with binary
files, you must useferror( )to check for file errors.
Related functions are
fputc( ),getc( ),putc( ), andfopen()
.fgetpos#include <cstdio>int fgetpos(FILE *stream, fpos_t *position);Chapter25:TheC-BasedI/OFunctions
703THESTANDARD
FUNCTIONLIBRARY
Thefgetpos( )function stores the current value of the file position indicator in the
object pointed to byposition. The object pointed to bypositionmust be of typefpos_t.The value stored there is useful only in a subsequent call to
fsetpos( ).If an error occurs,
fgetpos( )returns nonzero; otherwise it returns zero.
Related functions are
fsetpos( ),fseek( ), andftell( ).fgets#include <cstdio>char *fgets(char *str, intnum, FILE *stream);Thefgets( )function reads up to
num-1 characters from
stream
and places them intothe character array pointed to bystr. Characters are read until either a newline or an
EOFis received or until the specified limit is reached. After the characters have been
read, a null is placed in the array immediately after the last character read. Anewline
character will be retained and will be part of the array pointed to by
str.If successful,fgets( )returns
str; a null pointer is returned upon failure. If a read
erroroccurs,thecontentsofthearraypointedtoby
strareindeterminate.Because
anullpointerwillbereturnedwheneitheranerrorhasoccurredorwhentheend

of the file is reached, you should use
feof( )orferror( )to determine what has actuallyhappened.Related functions are
fputs( ),fgetc( ),gets( ), andputs( ).fopen#include <cstdio>FILE *fopen(const char *fname, const char *mode);Thefopen( )function opens a file whose name is pointed to byfnameand returns
the stream that is associated with it. The type of operations that will be allowed on the
file are defined by the value of
mode. The legal values formodeare shown in Table 25-1.
Thefilenamemustbeastringofcharacterscomprisingavalidfilenameasdefinedbythe

operating system and may include a path specification if the environment supports it.
Iffopen( )is successful in opening the specified file, aFILEpointer is returned.
If the file cannot be opened, a null pointer is returned.
704C++:TheCompleteReference
Asthetableshows,afilemaybeopenedineithertextorbinarymode.Intext
mode, some character translations may occur. For example, newlines may be converted
into carriage return/linefeed sequences. No such translations occur on binary files.
The correct method of opening a file is illustrated by this code fragment:
FILE *fp;if ((fp = fopen("test", "w"))==NULL) {printf("Cannot open file.\n");exit(1);}This method detects any error in opening a file, such as a write-protected or a full disk,
before attempting to write to it.
If you usefopen( )to open a file for output, any preexisting file by that name will
be erased and a new file started. If no file by that name exists, one will be created.
ModeMeaning"r"Open text file for reading.
"w"Create a text file for writing.
"a"Append to text file."rb"Open binary file for reading.
"wb"Create binary file for writing.
"ab"Append to a binary file.

"r+"Open text file for read/write.

"w+"Create text file for read/write.

"a+"Open text file for read/write.

"rb+" or "r+b"Open binary file for read/write.

"wb+" or "w+b"Create binary file for read/write.

"ab+" or "a+b"Open binary file for read/write.
Table25-1.
The Legal Values for the modeParameter of
fopen( )THESTANDARD
FUNCTIONLIBRARY
Chapter25:TheC-BasedI/OFunctions
705Openingafileforreadoperationsrequiresthatthefileexists.Ifitdoesnotexist,an
error will be returned. If you want to add to the end of the file, you must use mode "a."

If the file does not exist, it will be created.
Whenaccessingafileopenedforread/writeoperations,youcannotfollowan
output operation with an input operation without an intervening call to eitherfflush( )
,fseek( ),fsetpos()
, orrewind( ). Also, you cannot follow an input operation with anoutputoperationwithoutaninterveningcalltooneofthepreviouslymentioned

functions, except when the end of the file is reached during input.  That is, output

can directly follow input at the end of the file.
Related functions are
fclose( ),fread( ),fwrite( ),putc( ), andgetc( ).fprintf#include <cstdio>int fprintf(FILE *stream, const char *format, ...);Thefprintf( )function outputs the values of the arguments that comprise the
argument list as specified in the
formatstring to the stream pointed to by
stream
.The return value is the number of characters actually printed. If an error occurs,
a negative number is returned.
There may be from zero to several arguments, with the maximum number being
system dependent.The operations of the format control string and commands are identical to those in
printf()
; seeprintf( )for a complete description.Related functions are
printf( )andfscanf( ).fputc#include <cstdio>int fputc(intch, FILE *stream);Thefputc( )function writes the characterchto the specified stream at the current
file position and then advances the file position indicator. Even though
chis declared
to be anintfor historical reasons, it is converted by
fputc( )into anunsignedchar
.Because all character arguments are elevated to integers at the time of the call, you
will generally see character values used as arguments. If an integer were used, the

high-order byte(s) would simply be discarded.
Thevaluereturnedby
fputc()
isthevalueofthecharacterwritten.Ifanerror
occurs,EOFis returned. For files opened for binary operations, an
EOFmay be a validcharacter, and the function
ferror( )will need to be used to determine whether an error
has actually occurred.
Related functions are
fgetc( ),fopen( ),fprintf( ),fread( ), andfwrite( ).fputs#include <cstdio>int fputs(const char *str, FILE *stream);Thefputs( )function writes the contents of the string pointed to bystrto thespecified stream. The null terminator is not written.
Thefputs( )function returns nonnegative on success and
EOFon failure.
If the stream is opened in text mode, certain character translations may take place.
Thismeansthattheremaynotbeaone-to-onemappingofthestringontothefile.
However, if the stream is opened in binary mode, no character translations will occur,

and a one-to-one mapping between the string and the file will exist.Related functions are
fgets( ),gets( ),puts( ),fprintf( ), andfscanf( ).fread
#include <cstdio>size_t fread(void *buf, size_tsize, size_tcount,FILE *stream);Thefread( )function reads
countnumber of objects, each object beingsizebytes inlength, from the stream pointed to by
stream
and places them in the array pointed to bybuf.The file position indicator is advanced by the number of characters read.
Thefread( )function returns the number of items actually read. If fewer items are
read than are requested in the call, either an error has occurred or the end of the file has
been reached. You must use
feof( )orferror( )to determine what has taken place.If the stream is opened for text operations, certain character translations, such as
carriage return/linefeed sequences being transformed into newlines, may occur.
Related functions are
fwrite( ),fopen( ),fscanf( ),fgetc( ), andgetc( ).freopen
#include <cstdio>FILE *freopen(const char *fname, const char *mode,FILE *stream);706C++:TheCompleteReference
Chapter25:TheC-BasedI/OFunctions
707THESTANDARD
FUNCTIONLIBRARY
Thefreopen( )function associates an existing stream with a different file. The new
file'snameispointedtoby
fname,theaccessmodeispointedtoby
mode,andthestream
tobereassignedispointedtoby
stream
.Thestring
modeusesthesameformatas
fopen()
;a complete discussion is found in thefopen( )description.When called,freopen( )first tries to close a file that may currently be associated
withstream
. However, if the attempt to close the file fails, the
freopen( )function stillcontinues to open the other file.Thefreopen( )function returns a pointer to
stream
on success and a null pointerotherwise.The main use offreopen( )is to redirect the system defined streams
stdin,stdout,andstderrto some other file.Related functions are
fopen( )andfclose( ).fscanf#include <cstdio>int fscanf(FILE *stream, const char *format, ...);Thefscanf( )function works exactly like thescanf( )function, except that it reads
the information from the stream specified by
stream
instead ofstdin. Seescanf( )for details.Thefscanf( )function returns the number of arguments actually assigned values.
This number does not include skipped fields. Areturn value of
EOFmeans thata failure occurred before the first assignment was made.
Related functions are
scanf( )andfprintf( ).fseek#include <cstdio>
int fseek(FILE *stream, longoffset, intorigin);Thefseek()
functionsetsthefilepositionindicatorassociatedwithstreamaccording
tothevaluesof
offsetandorigin.Itspurposeistosupportrandom-accessI/Ooperations.
Theoffsetis the number of bytes from
originto seek to. The values fororiginmust beone of these macros (defined in
<cstdio>).NameMeaningSEEK_SETSeek from start of file
SEEK_CURSeek from current location

SEEK_ENDSeek from end of file
Areturn value of zero means that
fseek( )succeeded. Anonzero value
indicates failure.
Youmayuse
fseek()
tomovethepositionindicatoranywhereinthefile,
even beyond the end. However, it is an error to attempt to set the position indicator
before the beginning of the file.
Thefseek( )function clears the end-of-file flag associated with the specified stream.
Furthermore, it nullifies any prior
ungetc( )on the same stream (see
ungetc( )).Related functions are
ftell( ),rewind( ),fopen( ),fgetpos( ), andfsetpos( ).fsetpos#include <cstdio>int fsetpos(FILE *stream, const fpos_t *position);Thefsetpos( )function moves the file position indicator to the point specified bytheobjectpointedtoby
position.Thisvaluemusthavebeenpreviouslyobtained
throughacallto
fgetpos()
.After
fsetpos()
isexecuted,theend-of-fileindicatoris
reset. Also, any previous call to
ungetc( )is nullified.Iffsetpos( )fails, it returns nonzero. If it is successful, it returns zero.
Related functions are
fgetpos( ),fseek( ), andftell( ).ftell#include <cstdio>
long ftell(FILE *stream);Theftell()
functionreturnsthecurrentvalueofthefilepositionindicatorfor
the specifiedstream
. In the case of binary streams, the value is the number of bytes the
indicator is from the beginning of the file. For text streams, the return value may not be
meaningfulexceptasanargumentto
fseek()
becauseofpossiblecharactertranslations,
such as carriage return/linefeeds being substituted for newlines, which affect the

apparent size of the file.
Theftell( )function returns
−1 when an error occurs.
708C++:TheCompleteReference
Chapter25:TheC-BasedI/OFunctions
709THESTANDARD
FUNCTIONLIBRARY
Related functions are
fseek( )andfgetpos( ).fwrite#include <cstdio>size_t fwrite(const void *buf, size_tsize,size_tcount, FILE *stream);Thefwrite( )function writescountnumber of objects, each object beingsizebytesin length, to the stream pointed to by
stream
from the character array pointed to by
buf.The file position indicator is advanced by the number of characters written.Thefwrite( )function returns the number of items actually written, which, if the
function is successful, will equal the number requested. If fewer items are written than
are requested, an error has occurred.
Related functions are
fread( ),fscanf( ),getc( ), andfgetc( ).getc#include <cstdio>int getc(FILE *stream);Thegetc()
functionreturnsthenextcharacterfromtheinputstreamandincrements
the file position indicator. The character is read as an
unsigned charthat is converted toan integer.
If the end of the file is reached,
getc( )returns
EOF. However, since
EOFis a validinteger value, when working with binary files you must usefeof( )to check for theend-of-file character. If
getc( )encounters an error,
EOFis also returned. If working
with binary files, you must useferror( )to check for file errors.
The functionsgetc( )andfgetc( )are identical, and in most implementations
getc( )is simply defined as the macro shown here.
#define getc(fp) fgetc(fp)This causes thefgetc( )function to be substituted for thegetc( )macro.
Related functions are
fputc( ),fgetc( ),putc( ), andfopen( ).getchar#include <cstdio>int getchar(void);Thegetchar( )function returns the next character from
stdin. The character is read
as anunsignedchar
that is converted to an integer.
If the end of the file is reached,
getchar( )returns
EOF. Ifgetchar( )encounters anerror,
EOFis also returned.
Thegetchar( )function is often implemented as a macro.
Related functions are
fputc( ),fgetc( ),putc( ), andfopen( ).gets#include <cstdio>
char *gets(char *str);Thegets( )function reads characters from
stdinand places them into the characterarray pointed to bystr. Characters are read until a newline or an
EOFis received. The
newline character is not made part of the string; instead, it is translated into a null toterminate the string.If successful,gets( )returns
str; a null pointer is returned upon failure. If a read
erroroccurs,thecontentsofthearraypointedtoby
strareindeterminate.Because
anullpointerwillbereturnedwheneitheranerrorhasoccurredorwhentheend

of the file is reached, you should use
feof( )orferror( )to determine what has actuallyhappened.There is no way to limit the number of characters that
gets( )will read, and
it is possible for the array pointed to bystrto be overrun. Thus,
gets( )is inherently
dangerous.
Related functions are
fputs( ),fgetc( ),fgets( ), andputs( ).perror
#include <cstdio>void perror(const char *str);710C++:TheCompleteReference
Chapter25:TheC-BasedI/OFunctions
711THESTANDARD
FUNCTIONLIBRARY
Theperror( )function maps the value of the global variableerrnoonto a string andwrites that string tostderr. If the value ofstris not null, it is written first, followed bya colon, and then the implementation-defined error message.
printf#include <cstdio>int printf(const char *format, ...);Theprintf( )function writes tostdoutthe arguments that comprise the argument
list as specified by the string pointed to byformat.The string pointed to byformatconsists of two types of items. The first type is madeupofcharactersthatwillbeprintedonthescreen.Thesecondtypecontainsformat
specifiers that define the way the arguments are displayed. Aformat specifier begins

with a percent sign and is followed by the format code. There must be exactly the same

number of arguments as there are format specifiers, and the format specifiers and the

arguments are matched in order. For example, the following
printf( )call displays"Hi c 10 there!".
printf("Hi %c %d %s", 'c', 10, "there!");If there are insufficient arguments to match the format specifiers, the output is
undefined.Iftherearemoreargumentsthanformatspecifiers,theremainingarguments

are discarded. The format specifiers are shown in Table 25-2.
Theprintf( )function returns the number of characters actually printed. Anegative
return value indicates that an error has taken place.
The format codes may have modifiers that specify the field width, precision, and
a left-justification flag. An integer placed between the%sign and the format code actsasa
minimumfield-widthspecifier
.Thispadstheoutputwithspacesor0'stoensure
that it is at least a certain minimum length. If the string or number is greater than that

minimum,itwillbeprintedinfull,evenifitoverrunstheminimum.Thedefault

paddingisdonewithspaces.Ifyouwishtopadwith0's,placea0beforethefield-width

specifier. For example,
%05dwill pad a number of less than five digits with 0's so thatits total length is 5.Theexactmeaningofthe
precisionmodifier
dependsontheformatcodebeing
modified. To add a precision modifier, place a decimal point followed by the precision

after the field-width specifier. For
e,E, andfformats, the precision modifier determines
712C++:TheCompleteReference
the number of decimal places printed. For example,%10.4fwill display a numberat least 10 characters wide with four decimal places. When the precision modifier is
applied to thegorGformat code, it determines the maximum number of significantdigitsdisplayed.Whenappliedtointegers,theprecisionmodifierspecifiesthe

minimumnumberofdigitsthatwillbedisplayed.Leadingzerosareadded,if

necessary.
When the precision modifier is applied to strings, the number following the period
specifies the maximum field length. For example,%5.7swill display a string that willCodeFormat
%cCharacter%dSigned decimal integers%iSigned decimal integers%eScientific notation (lowercase e)
%EScientific notation (uppercase E)
%fDecimal floating point%gUses %e or %f, whichever is shorter (if %e, uses lowercase e)
%GUses %E or %f, whichever is shorter (if %E, uses uppercase E)
%oUnsigned octal%sString of characters%uUnsigned decimal integers%xUnsigned hexadecimal (lowercase letters)
%XUnsigned hexadecimal (uppercase letters)

%pDisplays a pointer%nThe associated argument is a pointer to an integer into which is
placed the number of characters written so far%%Prints a % sign
Table25-2.
Theprintf( )Format Specifiers
be at least five characters long and will not exceed seven. If the string is longer than themaximum field width, the characters will be truncated off the end.
Bydefault,alloutputis
right-justified:ifthefieldwidthislargerthanthedataprinted,
thedatawillbeplacedontherightedgeofthefield.Youcanforcetheinformation

tobeleft-justifiedbyplacingaminussigndirectlyafterthe
%.Forexample,
%10.2fwill left-justify a floating-point number with two decimal places in a 10-character field.Therearetwoformatmodifiersthatallow
printf()
todisplayshortandlongintegers.
These modifiers may be applied to thed,i,o,u, andxtype specifiers. Thelmodifiertellsprintf( )that a long data type follows. For example,%ldmeans that a long integeris to be displayed. Thehmodifier tellsprintf( )to display a short integer. Therefore,
%huindicates that the data is of type short unsigned integer.
Ifyouareusingamoderncompilerthatsupportsthewide-characterfeaturesadded
in1995,thenyoumayusethe
lmodifierwiththe
cspecifiertoindicateawide-character
oftype
wchar_t.Youmayalsousethe
lmodifierwiththe
sformatcommandtoindicate
a wide-character string.AnLmodifier may prefix the floating-point commands of
e,f, andgand indicatesthat along doublefollows.The%ncommand causes the number of characters that have been written at thetimethe
%nisencounteredtobeplacedinanintegervariablewhosepointerisspecified
in the argument list. For example, this code fragment displays the number 14 after the

line "This is a test":int i;printf("This is a test%n", &i);printf("%d", i);Youcanapplythe
lorhmodifertothe
nspecifiertoindicatethatthecorresponding
argument points to a long or short integer, respectively.
The#has a special meaning when used with someprintf( )format codes. Preceding
ag,G,f,e,or
Ecodewitha
#ensuresthatthedecimalpointwillbepresent,evenifthere
are no decimal digits. If you precede the
xorXformat code with a #, the hexadecimalnumber will be printed with a0xprefix. If you precede the
oformat with a#, the octalvaluewillbeprintedwitha
0prefix.The
#cannotbeappliedtoanyotherformatspecifiers.
The minimum field-width and precision specifiers may be provided by arguments
toprintf()
instead of by constants. To accomplish this, use an * as a placeholder. When
the format string is scanned,printf( )will match each * to an argument in the order in
which they occur.
Related functions are
scanf( )andfprintf( ).Chapter25:TheC-BasedI/OFunctions
713THESTANDARD
FUNCTIONLIBRARY
714C++:TheCompleteReference
putc#include <cstdio>int putc(intch, FILE *stream);Theputc( )function writes the character contained in the least significant byte ofchto the output stream pointed to by
stream
. Because character arguments are elevated to
integer at the time of the call, you may use character values as arguments to
putc( ).Theputc( )function returns the character written on success or
EOFif an error
occurs. If the output stream has been opened in binary mode,
EOFis a valid valueforch. This means that you must useferror( )to determine if an error has occurred.
Related functions are
fgetc( ),fputc( ),getchar( ),and
putchar( ).putchar#include <cstdio>
int putchar(intch);Theputchar( )function writes the character contained in the least significant byteofchtostdout.Itisfunctionallyequivalentto
putc(ch,stdout)
.Becausecharacter
arguments are elevated to integer at the time of the call, you may use character values
as arguments to
putchar()
.Theputchar( )function returns the character written on success or
EOFif an error
occurs.Arelated function is
putc( ).puts#include <cstdio>int puts(const char *str);Theputs( )function writes the string pointed to bystrto the standard output
device. The null terminator is translated to a newline.Theputs( )function returns a nonnegative value if successful and an
EOFupon failure
.Related functions are
putc( ),gets( ),and
printf( ).remove
#include <cstdio>int remove(const char *fname);Theremove( )function erases the file specified byfname.It returns zero if the file
was successfully deleted and nonzero if an error occurred.
Arelated function is
rename( ).rename
#include <cstdio>
int rename(const char *oldfname, const char *newfname);Therename( )function changes the name of the file specified byoldfnametonewfname. Thenewfnamemust not match any existing directory entry.
Therename( )function returns zero if successful and nonzero if an error
has occurred.
Arelated function is
remove( ).rewind
#include <cstdio>
void rewind(FILE *stream);Therewind( )function moves the file position indicator to the start of the specifiedstream. It also clears the end-of-file and error flags associated with
stream.
It has noreturn value.
Arelated function is
fseek( ).scanf#include <cstdio>
int scanf(const char *format, ...);Chapter25:TheC-BasedI/OFunctions
715THESTANDARD
FUNCTIONLIBRARY
Thescanf( )function is a general-purpose input routine that reads the stream
stdinand stores the information in the variables pointed to in its argument list. It can read all
the built-in data types and automatically convert them into the proper internal format.
The control string pointed to by
formatconsists of three classifications of characters:
Format specifiers
White-space characters
Non–white-space charactersThe input format specifiers begin with a%sign and tellscanf( )what type of data isto be read next. The format specifiers are listed in Table 25-3. For example,
%sreads a
string while%dreads an integer
.The format string is read left to right and the format
specifiers are matched, in order, with the arguments that comprise the argument list.
716C++:TheCompleteReference
CodeMeaning
%cReads a single character.
%dReads a decimal integer.

%iReads an integer.

%eReads a floating-point number.

%fReads a floating-point number.

%gReads a floating-point number.

%oReads an octal number.

%sReads a string.

%xReads a hexadecimal number.

%pReads a pointer.

%nReceives an integer value equal to the number of characters read so far.

%uReads an unsigned integer.

%[ ]Scans for a set of characters.

%%Reads a percent sign.
Table25-3.
Thescanf( )Format Specifiers
To read a long integer, put an
l(ell) in front of the format specifier. To read a short
integer, put an
hin front of the format specifier. These modifiers can be used with the
d,i,o,u, andxformat codes.By default, thef,e, andgspecifiers instruct
scanf( )to assign data to afloat. If youputan
l(ell)infrontofoneofthesespecifiers,
scanf()
assignsthedatatoa
double.Using anLtellsscanf( )that the variable receiving the data is a
longdouble
.If you are using a modern compiler that supports wide-character features added in
1995, you may use thelmodifier with thecformat code to indicate a pointer to a widecharacter of typewchar_t. You may also use the
lmodifier with thesformat code toindicate a pointer to a wide-character string. Thelmay also be used to modify a scansetto indicate wide characters.Awhite-space character in the format string causes
scanf( )to skip over one ormore white-space characters in the input stream. Awhite-space character is either a
space, a tab character, or a newline. In essence, one white-space character in the control

string will causescanf( )to read, but not store, any number (including zero) of white-
space characters up to the first non–white-space character.
Anon–white-space character in the format string causes
scanf( )to read and discard
a matching character. For example,
%d,%dcausesscanf( )to first read an integer, then
read and discard a comma, and finally read another integer. If the specified character is

not found,scanf( )will terminate.All the variables used to receive values through
scanf( )must be passed by theiraddresses. This means that all arguments must be pointers.
The input data items must be separated by spaces, tabs, or newlines. Punctuationsuch as commas, semicolons, and the like do not count as separators. This means thatscanf("%d%d", &r, &c);will accept an input of10 20but fail with10,20.An*placed after the%and before the format code will read data of the specified
type but suppress its assignment. Thus, the command
scanf("%d%*c%d", &x, &y);given the input10/20, will place the value 10 intox, discard the divide sign, and give
ythe value 20.The format commands can specify a maximum field-length modifier. This is an
integer number placed between the % and the format code that limits the number of
charactersreadforanyfield.Forexample,ifyouwishtoreadnomorethan20characters

intoaddress,you would write the following.
Chapter25:TheC-BasedI/OFunctions
717THESTANDARD
FUNCTIONLIBRARY
scanf("%20s", address);If the input stream were greater than 20 characters, a subsequent call to input would
begin where this call left off. Input for a field may terminate before the maximum field

length is reached if a white space is encountered. In this case,
scanf( )moves on to thenext field.Although spaces, tabs, and newlines are used as field separators, when reading
a single character, these are read like any other character. For example, with an input

stream of
x y,scanf("%c%c%c", &a, &b, &c);will return with the character x in
a,a space in
band the charactery in
c.Beware: Any other characters in the control string—including spaces, tabs, and
newlines—will be used to match and discard characters from the input stream. Any

character that matches is discarded. For example, given the input stream
10t20,scanf("%dt%d", &x, &y);will place 10 intoxand 20 intoy.The
tis discarded because of the
tin thecontrol string.
Another feature of
scanf( )is called ascanset. Ascanset defines a set of characters
thatwillbereadby
scanf()
andassignedtothecorrespondingcharacterarray.A
scanset is defined by putting the characters you want to scan for inside square brackets.

The beginning square bracket must be prefixed by a percent sign. For example, this

scanset tellsscanf( )to read only the characters A, B, and C:
%[ABC]When a scanset is used,scanf( )continues to read characters and put them into the
corresponding character array until a character that is not in the scanset is encountered.

The corresponding variable must be a pointer to a character array. Upon return from

scanf()
,thearraywillcontainanull-terminatedstringcomprisedofthecharactersread.
You can specify an inverted set if the first character in the set is a
^. When the^ispresent, it instructs
scanf( )to accept any character thatisnot
defined by the scanset.For many implementations, you can specify a range using a hyphen. For example,this tellsscanf( )to accept the characters Athrough Z.
718C++:TheCompleteReference
Chapter25:TheC-BasedI/OFunctions
719THESTANDARD
FUNCTIONLIBRARY
%[A-Z]One important point to remember is that the scanset is case sensitive. Therefore,
if you want to scan for both upper- and lowercase letters, they must be specified
individually.
Thescanf( )function returns a number equal to the number of fields that were
successfully assigned values. This number will not include fields that were read but

not assigned because the * modifier was used to suppress the assignment.
EOFisreturned if an error occurs before the first field is assigned.
Related functions are
printf( )andfscanf( ).setbuf#include <cstdio>void setbuf(FILE *stream, char *buf);Thesetbuf( )function is used either to specify the buffer that
stream
will useor,if
called withbufset to null, to turn off buffering. If a programmer-defined buffer is to be
specified, it must beBUFSIZcharacters long.BUFSIZis defined in<cstdio>.Thesetbuf( )function returns no value
.Related functions are
fopen( ),fclose( ),and
setvbuf( ).setvbuf#include <cstdio>
int setvbuf(FILE *stream, char *buf, intmode, size_tsize);Thesetvbuf( )function allows the programmer to specify the buffer, its size, and
itsmodeforthespecifiedstream.Thecharacterarraypointedtoby
bufisusedas
thestreambufferforI/Ooperations.Thesizeofthebufferissetby
size,and
modedetermines how buffering will be handled. If
bufis null,setvbuf( )will allocate itsown buffer.
The legal values ofmodeare
_IOFBF, _IONBF
, and_IOLBF.
These are defined in
<cstdio>.When
modeis set to_IOFBF, full buffering will take place. If
modeis_IOLBF,the stream will be line buffered, which means that the buffer will be flushed each time
a newline character is written for output streams; for input streams, input is buffered

until a newline character is read. If mode is
_IONBF, no buffering takes place.
720C++:TheCompleteReference
Thesetvbuf( )function returns zero on success, nonzero on failure.
Arelated function is
setbuf( ).sprintf#include <cstdio>int sprintf(char *buf, const char *format, ...);Thesprintf( )function is identical toprintf( )except that the output is put into thearray pointed to bybufinstead of being written to the console. Seeprintf( )for details.The return value is equal to the number of characters actually placed into the array.
Related functions are
printf( )andfsprintf( ).sscanf#include <cstdio>int sscanf(const char *buf, const char *format, ...);Thesscanf( )function is identical toscanf( )except that data is read from the array
pointed to bybufrather thanstdin. Seescanf( )for details.The return value is equal to the number of variables that were actually assigned
values. This number does not include fields that were skipped through the use of the
* format command modifier. Avalue of zero means that no fields were assigned, and

EOFindicates that an error occurred prior to the first assignment.
Related functions are
scanf( )andfscanf( ).tmpfile#include <cstdio>FILE *tmpfile(void);Thetmpfile( )function opens a temporary file for update and returns a pointer to
the stream. The function automatically uses a unique filename to avoid conflicts with
existing files.Thetmpfile( )function returns a null pointer on failure; otherwise it returns
a pointer to the stream.
Chapter25:TheC-BasedI/OFunctions
721THESTANDARD
FUNCTIONLIBRARY
The temporary file created by
tmpfile( )is automatically removed when the file is
closed or when the program terminates.
Arelated function is
tmpnam( ).tmpnam#include <cstdio>char *tmpnam(char *name);Thetmpnam()
functiongeneratesauniquefilenameandstoresitinthearraypointed
toby
name.Thisarraymustbeatleast
L_tmpnamcharacterslong.
(L_tmpnamisdefined
in<cstdio>.) The main purpose oftmpnam( )is to generate a temporary filename thatis different from any other file in the current disk directory.
The function may be called up toTMP_MAXtimes.TMP_MAXis defined in<cstdio>, and it will be at least 25. Each timetmpnam( )is called, it will generatea new temporary filename.Apointer to
nameis returned on success; otherwise a null pointer is returned. If
nameisnull,thetemporaryfilenameisheldinastaticarrayownedby
tmpnam()
,and a pointer to this array is returned.  This array is overwritten by a subsequent call.
Arelated function is
tmpfile( ).ungetc#include <cstdio>
int ungetc(int ch, FILE *stream);Theungetc( )function returns the character specified by the low-order byte of
chtothe input stream
stream.
This character will then be obtained by the next read operation
onstream
. Acall to
fflush( )
,fseek( ),or
rewind( )undoes anungetc( )operation anddiscards the character.
Aone-character pushback is guaranteed; however, some implementations will
accept more.
You may not unget an
EOF.Acallto
ungetc()
clearstheend-of-fileflagassociatedwiththespecifiedstream.The
value of the file position indicator for a text stream is undefined until all pushed- back
characters are read, in which case it will be the same as it was prior to the first
ungetc( )call. For binary streams, each
ungetc( )call decrements the file position indicator.
The return value is equal to
chon success andEOFon failure.
Arelated function is
getc( ).vprintf, vfprintf, and vsprintf#include <cstdarg>#include <cstdio>
int vprintf(char *format, va_listarg_ptr);int vfprintf(FILE *stream, const char *format,va_listarg_ptr);int vsprintf(char *buf, const char *format,va_listarg_ptr);The functionsvprintf(),vfprintf( ), andvsprintf( )are functionally equivalent to
printf()
,fprintf( ), andsprintf( ), respectively, except that the argument list has been
replaced by a pointer to a list of arguments. This pointer must be of type
va_list, whichis defined in the header<cstdarg>(or the C header filestdarg.h).Related functions are
va_arg( ),va_start()
, andva_end()
.722C++:TheCompleteReference
Chapter26
The String andCharacter Functions723Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
The standard function library has a rich and varied set of string and characterhandling functions. The string functions operate on null-terminated arrays of
characters and require the header<cstring>. The character functions use theheader<cctype>. C programs must use the header filesstring.handctype.h.Because C/C++ has no bounds checking on array operations, it is the programmer's
responsibilitytopreventanarrayoverflow.Neglectingtodosomaycauseyourprogram

to crash.In C/C++, aprintable characteris one that can be displayed on a terminal. These are
usually the characters between a space (0x20) and tilde (0xFE).Control characters
havevalues between (0) and (0x1F) as well as DEL(0x7F).
For historical reasons, the parameters to the character functions are integers, but
only the low-order byte is used; the character functions automatically convert their

arguments to
unsigned char. However, you are free to call these functions with
character arguments because characters are automatically elevated to integers at

the time of the call.The header<cstring>defines thesize_ttype, which is essentially the same asunsigned.This chapter describes only those functions that operate on characters of typechar.These are the functions originally defined by Standard C and C++, and they are by far

themostwidelyusedandsupported.Wide-characterfunctionsthatoperateoncharacters

of type
wchar_tare discussed in Chapter 31.
isalnum#include <cctype>int isalnum(intch);Theisalnum( )function returns nonzero if its argument is either a letter of the
alphabet or a digit. If the character is not alphanumeric, zero is returned.
Related functions are
isalpha()
,iscntrl()
,isdigit( ),isgraph()
,isprint()
,ispunct()
,andisspace( ).isalpha#include <cctype>
int isalpha(intch);Theisalpha( )function returns nonzero if
chis a letter of the alphabet; otherwisezero is returned. What constitutes a letter of the alphabet may vary from language to
language. For English, these are the upper- and lowercase letters Athrough Z.
724C++:TheCompleteReference
Chapter26:TheStringandCharacterFunctions
725THESTANDARD
FUNCTIONLIBRARY
Relatedfunctionsare
isalnum()
,iscntrl()
,isdigit()
,isgraph()
,isprint()
,ispunct()
,andisspace( ).iscntrl#include <cctype>int iscntrl(intch);Theiscntrl( )function returns nonzero if
chis between zero and 0x1F or is equal to
0x7F (DEL); otherwise zero is returned.
Relatedfunctionsare
isalnum()
,isalpha()
,isdigit()
,isgraph()
,isprint()
,ispunct()
,andisspace()
.isdigit#include <cctype>
int isdigit(intch);Theisdigit( )function returns nonzero if
chis a digit, that is, 0 through 9. Otherwise
zero is returned.
Relatedfunctionsare
isalnum()
,isalpha()
,iscntrl()
,isgraph()
,isprint()
,ispunct()
,andisspace( ).isgraph#include <cctype>
int isgraph(intch);Theisgraph( )function returns nonzero if
chis any printable character other thana space; otherwise zero is returned. These are characters generally in the range 0x21
through 0x7E.
Relatedfunctionsare
isalnum()
,isalpha()
,iscntrl()
,isdigit()
,isprint()
,ispunct()
,andisspace( ).islower#include <cctype>int islower(intch);Theislower( )function returns nonzero if
chis a lowercase letter; otherwise zero
is returned.
Arelated function is
isupper( ).isprint#include <cctype>int isprint(intch);Theisprint( )function returns nonzero if
chis a printable character, including
a space; otherwise zero is returned. Printable characters are often in the range 0x20
through 0x7E.
Relatedfunctionsare
isalnum()
,isalpha()
,iscntrl()
,isdigit()
,isgraph()
,ispunct()
,andisspace( ).ispunct#include <cctype>int ispunct(intch);Theispunct( )function returns nonzero if
chis a punctuation character; otherwisezero is returned. The term "punctuation," as defined by this function, includes all
printing characters that are neither alphanumeric nor a space.
Relatedfunctionsare
isalnum()
,isalpha()
,iscntrl()
,isdigit()
,isgraph()
,and
isspace()
.isspace#include <cctype>int isspace(intch);Theisspace( )function returns nonzero if
chis either a space, horizontal tab, verticaltab, formfeed, carriage return, or newline character; otherwise zero is returned.
Related functions are
isalnum()
,isalpha( ),iscntrl( ),isdigit( ),isgraph( ), andispunct()
.726C++:TheCompleteReference
Chapter26:TheStringandCharacterFunctions
727THESTANDARD
FUNCTIONLIBRARY
isupper#include <cctype>int isupper(intch);Theisupper( )function returns nonzero if
chis an uppercase letter; otherwise zero
is returned.
Arelated function is
islower()
.isxdigit#include <cctype>
int isxdigit(intch);Theisxdigit( )function returns nonzero if
chis a hexadecimal digit; otherwise zero
is returned. Ahexadecimal digit will be in one of these ranges: A–F, a–f, or 0–9.
Relatedfunctionsare
isalnum()
,isalpha()
,iscntrl()
,isdigit()
,isgraph()
,ispunct()
,andisspace( ).memchr#include <cstring>
void *memchr(const void *buffer, intch, size_tcount);Thememchr( )function searches the array pointed to by
bufferfor the firstoccurrence of
chin the firstcountcharacters.Thememchr( )function returns a pointer to the first occurrence of
chinbuffer, or itreturns a null pointer if
chis not found.Related functions are
memcpy( )andisspace( ).memcmp#include <cstring>
int memcmp(const void *buf1, const void *buf2, size_tcount);Thememcmp( )function compares the first
countcharacters of the arrays pointed tobybuf1andbuf2.Thememcmp( )function returns an integer that is interpreted as indicated here:
Value
MeaningLess than zero
buf1is less thanbuf2.Zero
buf1is equal tobuf2.Greater than zero
buf1is greater than
buf2.Related functions are
memchr( ),memcpy( ), andstrcmp( ).memcpy#include <cstring>void *memcpy(void *to, const void *from, size_tcount);Thememcpy( )function copiescountcharacters from the array pointed to by
from
into the array pointed to byto. If the arrays overlap, the behavior ofmemcopy( )is undefined.Thememcpy( )function returns a pointer to
to.Arelated function is
memmove( ).memmove#include <cstring>
void *memmove(void *to, const void *from, size_tcount);Thememmove( )function copiescountcharacters from the array pointed to by
from
into the array pointed to byto. If the arrays overlap, the copy will take place correctly,
placing the correct contents into
tobut leavingfrom
modified.Thememmove( )function returns a pointer to
to.Arelated function is
memcpy()
.728C++:TheCompleteReference
memset#include <cstring>void *memset(void *buf, intch, size_tcount);Thememset( )function copies the low-order byte of
chinto the firstcountcharactersof the array pointed to bybuf.It returns
buf.The most common use ofmemset( )is to initialize a region of memory to some
known value.Related functions are
memcmp( ),memcpy( ), andmemmove( ).strcat
#include <cstring>
char *strcat(char *str1, const char *str2);Thestrcat( )function concatenates a copy ofstr2tostr1and terminatesstr1with anull. The null terminator originally endingstr1is overwritten by the first character ofstr2. The stringstr2is untouched by the operation. If the arrays overlap, the behaviorofstrcat( )is undefined.Thestrcat( )function returns
str1.Remember, no bounds checking takes place, so it is the programmer's responsibility
toensurethat
str1islargeenoughtoholdbothitsoriginalcontentsandalsothoseof
str2.Related functions are
strchr( ),strcmp( ), andstrcpy()
.strchr
#include <cstring>
char *strchr(const char *str, intch);Thestrchr( )function returns a pointer to the first occurrence of the low-order byte
ofchin the string pointed to bystr. If no match is found, a null pointer is returned.
Related functions are
strpbrk( ),strspn()
,strstr()
, andstrtok()
.Chapter26:TheStringandCharacterFunctions
729THESTANDARD
FUNCTIONLIBRARY
strcmp
#include <cstring>int strcmp(const char *str1, const char *str2);Thestrcmp( )function lexicographically compares two strings and returns an
integer based on the outcome as shown here:
Value
MeaningLess than zero
str1is less thanstr2.Zero
str1is equal tostr2.Greater than zero
str1is greater than
str2.Related functions are
strchr( ),strcpy( ), andstrcmp( ).strcoll
#include <cstring>
int strcoll(const char *str1, const char *str2);Thestrcoll( )function compares the string pointed to by
str1with the one pointedto bystr2. The comparison is performed in accordance to the locale specified using the
setlocale( )function (seesetlocalefor details).Thestrcoll( )function returns an integer that is interpreted as indicated here:
Value
MeaningLess than zero
str1is less thanstr2.Zero
str1is equal tostr2.Greater than zero
str1is greater than
str2.Related functions are
memcmp( )andstrcmp( ).730C++:TheCompleteReference
strcpy
#include <cstring>char *strcpy(char *str1, const char *str2);Thestrcpy( )function copies the contents ofstr2intostr1.str2must be a pointer toa null-terminated string. Thestrcpy( )function returns a pointer to
str1.Ifstr1andstr2overlap, the behavior ofstrcpy( )is undefined.Related functions are
memcpy( ),strchr( ),strcmp()
, andstrncmp( ).strcspn
#include <cstring>
size_t strcspn(const char *str1, const char *str2);Thestrcspn()
functionreturnsthelengthoftheinitialsubstringofthestringpointed
to bystr1that is made up of only those characters not contained in the string pointed tobystr2. Stated differently,
strcspn( )returns the index of the first character in the string
pointed to bystr1that matches any of the characters in the string pointed to bystr2.Related functions are
strrchr( ),strpbrk( ),strstr()
, andstrtok( ).strerror
#include <cstring>
char *strerror(interrnum);Thestrerror( )function returns a pointer to an implementation-defined string
associated with the value oferrnum. Under no circumstances should you modify
the string.strlen#include <cstring>
size_t strlen(const char *str);Thestrlen( )function returns the length of the null-terminated string pointed to
bystr. The null terminator is not counted.Chapter26:TheStringandCharacterFunctions
731THESTANDARD
FUNCTIONLIBRARY
Related functions are
memcpy( ),strchr( ),strcmp( ), andstrncmp( ).strncat#include <cstring>char *strncat(char *str1, const char *str2, size_tcount);Thestrncat( )function concatenates not more than
countcharacters of the stringpointed to bystr2to the string pointed to bystr1and terminatesstr1with a null. Thenullterminatororiginallyending
str1isoverwrittenbythefirstcharacterof
str2.Thestring
str2isuntouchedbytheoperation.Ifthestringsoverlap,thebehavior
is undefined.Thestrncat( )function returns
str1.Remember that no bounds checking takes place, so it is the programmer's
responsibility to ensure that
str1is large enough to hold both its original contents
and also those ofstr2.Related functions are
strcat( ),strnchr( ),strncmp()
, andstrncpy( ).strncmp#include <cstring>
int strncmp(const char *str1, const char *str2, size_tcount);Thestrncmp( )function lexicographically compares not more than
countcharactersfrom the two null-terminated strings and returns an integer based on the outcome, as
shown here:
Value
MeaningLess than zero
str1is less thanstr2.Zero
str1is equal tostr2.Greater than zero
str1is greater than
str2.If there are less than
countcharacters in either string, the comparison ends when thefirst null is encountered.
Related functions are
strcmp()
,strnchr( ), andstrncpy()
.732C++:TheCompleteReference
strncpy#include <cstring>char *strncpy(char *str1, const char *str2, size_tcount);Thestrncpy( )function copies up tocountcharacters from the string pointed to by
str2into the string pointed to bystr1.str2must be a pointer to a null-terminated string.Ifstr1andstr2overlap, the behavior ofstrncpy( )is undefined.If the string pointed to bystr2has less thancountcharacters, nulls will be appendedto the end ofstr1untilcountcharacters have been copied.Alternatively, if the string pointed to by
str2is longer thancountcharacters, theresultant string pointed to by
str1will not be null terminated.Thestrncpy( )function returns a pointer to
str1.Related functions are
memcpy()
,strchr( ),strncat()
, andstrncmp( ).strpbrk#include <cstring>
char *strpbrk(const char *str1, const char *str2);Thestrpbrk( )function returns a pointer to the first character in the string pointed
toby
str1thatmatchesanycharacterinthestringpointedtoby
str2.Thenullterminators
are not included. If there are no matches, a null pointer is returned.
Related functions are
strspn( ),strrchr()
,strstr( ), andstrtok()
.strrchr
#include <cstring>
char *strrchr(const char *str, intch);Thestrrchr( )function returns a pointer to the last occurrence of the low-order byte
ofchin the string pointed to bystr. If no match is found, a null pointer is returned.
Related functions are
strpbrk( ),strspn( ),strstr( ), andstrtok( ).Chapter26:TheStringandCharacterFunctions
733THESTANDARD
FUNCTIONLIBRARY
strspn#include <cstring>size_t strspn(const char *str1, const char *str2);Thestrspn( )function returns the length of the initial substring of the string pointed
to bystr1that is made up of only those characters contained in the string pointed tobystr2. Stated differently,
strspn( )returns the index of the first character in the string
pointed to bystr1that does not match any of the characters in the string pointed tobystr2.Related functions are
strpbrk( ),strrchr( ),strstr()
, andstrtok()
.strstr#include <cstring>
char *strstr(const char *str1, const char *str2);Thestrstr( )function returns a pointer to the first occurrence in the string pointed
to bystr1of the string pointed to bystr2. It returns a null pointer if no match is found.
Relatedfunctionsare
strchr()
,strcspn()
,strpbrk()
,strspn()
,strtok()
,and
strrchr()
.strtok
#include <cstring>
char *strtok(char *str1, const char *str2);Thestrtok( )function returns a pointer to the next token in the string pointed to
bystr1. The characters making up the string pointed to bystr2are the delimiters that
determine the token. Anull pointer is returned when there is no token to return.
To tokenize a string, the first call to
strtok( )must havestr1point to the string beingtokenized.Subsequentcallsmustuseanullpointerfor
str1.Inthisway,theentirestring
can be reduced to its tokens.
It is possible to use a different set of delimiters for each call to
strtok( ).Related functions are
strchr( ),strcspn( ),strpbrk( ),strrchr( ), andstrspn( ).734C++:TheCompleteReference
strxfrm
#include <cstring>size_t strxfrm(char *str1, const char *str2, size_tcount);Thestrxfrm( )function transforms the string pointed to bystr2so that it can beused by thestrcmp( )function and puts the result into the string pointed to by
str1.After the transformation, the outcome of astrcmp( )usingstr1and astrcoll( )usingthe original string pointed to bystr2will be the same. Not more than
countcharactersare written to the array pointed to by
str1.Thestrxfrm( )function returns the length of the transformed string.
Arelated function is
strcoll( ).tolower#include <cctype>
int tolower(intch);Thetolower( )function returns the lowercase equivalent of
chifchis a letter;otherwisechis returned unchanged.
Arelated function is
toupper().toupper#include <cctype>
int toupper(intch);Thetoupper( )function returns the uppercase equivalent of
chifchis a letter;otherwisechis returned unchanged.
Arelated function is
tolower( ).Chapter26:TheStringandCharacterFunctions
735THESTANDARD
FUNCTIONLIBRARY
This page intentionally left blank Chapter27
The MathematicalFunctions737Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
The standard function library contains several mathematical functions, which fallinto the following categories:Trigonometric functions
Hyperbolic functionsExponential and logarithmic functionsMiscellaneous functionsAll the math functions require the header
<cmath>.(C programs must use the
header filemath.h.) In addition to declaring the math functions, this header definesthe macro called
HUGE_VAL
. The macros
EDOMandERANGEare also used by the
math functions. These macros are defined in the header
<cerrno>(or the fileerrno.h).Ifanargumenttoamathfunctionisnotinthedomainforwhichitisdefined,an

implementation-definedvalueisreturned,andthebuilt-inglobalintegervariable

errnoissetequalto
EDOM.Ifaroutineproducesaresultthatistoolargetobe
represented, an overflow occurs. This causes the routine to return
HUGE_VAL
, anderrnoissetto
ERANGE,indicatingarangeerror.Ifanunderflowhappens,thefunction
returns zero and sets
errnotoERANGE.All angles are in radians.

Originally,themathematicalfunctionswerespecifiedasoperatingonvaluesoftype
double,butStandardC++addedoverloadedversionstoexplicitlyaccommodatevalues

oftype
floatandlongdouble
.Theoperationofthefunctionsisotherwiseunchanged.
acos#include <cmath>float acos(floatarg);double acos(doublearg);long double acos(long double arg);Theacos( )function returns the arc cosine of
arg
. The argument to
acos( )must bein the range –1 to 1; otherwise a domain error will occur.
Related functions are
asin( ),atan( ),atan2( ),sin( ),cos( ),tan( ),sinh( ),cosh( ),andtanh( ).asin#include <cmath>
float asin(floatarg);738C++:TheCompleteReference
double asin(doublearg);long double asin(long doublearg);Theasin( )function returns the arc sine of
arg
. The argument to
asin( )must be inthe range –1 to 1; otherwise a domain error will occur.
Related functions are
acos( ),atan( ),atan2( ),sin( ),cos( ),tan( ),sinh( ),cosh( ),andtanh( ).atan#include <cmath>float atan(floatarg);double atan(doublearg);long double atan(long doublearg);Theatan( )function returns the arc tangent of
arg
.Related functions are
asin( ),acos( ),atan2( ),tan( ),cos( ),sin( ),sinh( ),cosh( ),andtanh( ).atan2#include <cmath>
float atan2(floaty, floatx);double atan2(doubley, doublex);long double atan2(long doubley, long doublex);Theatan2( )function returns the arc tangent of
y/x. It uses the signs of its arguments
to compute the quadrant of the return value.
Related functions are
asin( ),acos( ),atan( ),tan( ),cos( ),sin( ),sinh( ),cosh( ),andtanh( ).ceil#include <cmath>
float ceil(floatnum);double ceil(doublenum);long double ceil(long doublenum);Chapter27:TheMathematicalFunctions
739THESTANDARD
FUNCTIONLIBRARY
Theceil()
functionreturnsthesmallestinteger(representedasafloating-point
value) not less thannum. For example, given 1.02,ceil( )would return 2.0. Given –1.02,
ceil( )would return –1.
Related functions are
floor( )andfmod( ).cos#include <cmath>float cos(floatarg);double cos(doublearg);long double cos(long doublearg);Thecos( )function returns the cosine of
arg
. The value ofarg
must be in radians.Related functions are
asin( ),acos( ),atan2( ),atan( ),tan( ),sin( ),sinh( ),cos( ),andtanh( ).cosh#include <cmath>
float cosh(floatarg);double cosh(doublearg);long double cosh(long doublearg);Thecosh( )function returns the hyperbolic cosine of
arg
.Related functions are
asin( ),acos( ),atan2( ),atan( ),tan( ),sin( ),cosh( ), andtanh( ).exp#include <cmath>
float exp(floatarg);double exp(doublearg);long double exp(long doublearg);Theexp( )function returns the natural logarithm base
eraised to thearg
power.
Arelated function is
log( ).740C++:TheCompleteReference
fabs#include <cmath>float fabs(floatnum);double fabs(doublenum);long double fabs(long doublenum);Thefabs( )function returns the absolute value of
num.Arelated function is
abs( ).floor#include <cmath>
float floor(floatnum);double floor(doublenum);long double floor(long doublenum);Thefloor( )function returns the largest integer (represented as a floating-point
value) not greater than
num. For example, given 1.02,floor( )would return 1.0. Given
–1.02,floor( )would return –2.0.
Related functions are
fceil( )andfmod( ).fmod#include <cmath>
float fmod(floatx, floaty);double fmod(doublex, doubley);long double fmod(long doublex, long doubley);Thefmod( )function returns the remainder of
x/y.
Related functions are
ceil( ),floor( ), andfabs( ).frexp
#include <cmath>
float frexp(floatnum, int *exp);Chapter27:TheMathematicalFunctions
741THESTANDARD
FUNCTIONLIBRARY
double frexp(doublenum, int *exp);long double frexp(long doublenum, int *exp);Thefrexp( )function decomposes the numbernuminto a mantissa in the range 0.5to less than 1, and an integer exponent such thatnum = mantissa * 2exp.The mantissa isreturned by the function, and the exponent is stored in the variable pointed to by
exp.Arelated function is
ldexp( ).ldexp#include <cmath>float ldexp(floatnum, intexp);double ldexp(doublenum, intexp);long double ldexp(long doublenum, intexp);Theldexp( )returns the value of
num *2exp. If overflow occurs,HUGE_VAL
is returned.
Related functions are
frexp( )andmodf( ).log#include <cmath>
float log(floatnum);double log(doublenum);long double log(long doublenum);Thelog( )function returns the natural logarithm for
num. Adomain error occurs if
numis negative, and a range error occurs if the argument is zero.
Arelated function is
log10( ).log10#include <cmath>
float log10(floatnum);double log10(doublenum);long double log10(long doublenum);742C++:TheCompleteReference
Thelog10( )function returns the base 10 logarithm for
num. Adomain error occurs
ifnumis negative, and a range error occurs if the argument is zero.
Arelated function is
log( ).modf#include <cmath>float modf(floatnum, float *i);double modf(doublenum, double *i);long double modf(long doublenum, long double *i);Themodf()
functiondecomposes
numintoitsintegerandfractionalparts.Itreturns
the fractional portion and places the integer part in the variable pointed to byi.Related functions are
frexp( )andldexp( ).pow#include <cmath>
float pow(floatbase, floatexp);float pow(floatbase, intexp);double pow(doublebase, doubleexp);double pow(doublebase, intexp);long double pow(long doublebase, long doubleexp);long double pow(long doublebase, intexp);Thepow( )function returns
baseraised to theexppower(baseexp). Adomain error
mayoccurif
baseiszeroand
expislessthanorequaltozero.Itwillalsohappenif
baseis negative andexpis not an integer. An overflow produces a range error.
Related functions are
exp( ),log( ), andsqrt( ).sin#include <cmath>
float sin(floatarg);double sin(doublearg);long double sin(long doublearg);Thesin( )function returns the sine of
arg
. The value ofarg
must be in radians.Chapter27:TheMathematicalFunctions
743THESTANDARD
FUNCTIONLIBRARY
Related functions are
asin( ),acos( ),atan2( ),atan( ),tan( ),cos( ),sinh( ),cosh( ),andtanh( ).sinh#include <cmath>float sinh(floatarg);double sinh(doublearg);long double sinh(long doublearg);Thesinh( )function returns the hyperbolic sine of
arg.
Related functions are
asin( ),acos( ),atan2( ),atan( ),tan( ),cos( ),tanh( ),cosh( ),andsin( ).sqrt
#include <cmath>
float sqrt(floatnum);double sqrt(doublenum);long double sqrt(long doublenum);Thesqrt( )function returns the square root of
num. If it is called with a negativeargument, a domain error will occur.
Related functions are
exp( ),log( ), andpow( ).tan#include <cmath>
float tan(floatarg);double tan(doublearg);long double tan(long doublearg);Thetan( )function returns the tangent of
arg
. The value ofarg
must be in radians.Related functions are
acos( ),asin( ),atan( ),atan2( ),cos( ),sin( ),sinh( ),cosh( ),andtanh( ).744C++:TheCompleteReference
tanh#include <cmath>float tanh(floatarg);double tanh(doublearg);long double tanh(long doublearg);Thetanh( )function returns the hyperbolic tangent of
arg
.Related functions are
acos( ),asin( ),atan( ),atan2( ),cos( ),sin( ),cosh( ),sinh( ),andtan( ).Chapter27:TheMathematicalFunctions
745THESTANDARD
FUNCTIONLIBRARY
This page intentionally left blank Chapter28
Time, Date, and
Localization Functions747Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
748C++:TheCompleteReference
The standard function library defines several functions that deal with the date andtime. It also defines functions that handle the geopolitical information associated
with a program. These functions are described here.Thetimeanddatefunctionsrequiretheheader
<ctime>.(ACprogrammustusethe
headerfile
time.h.)Thisheaderdefinesthreetime-relatedtypes:
clock_t,time_t,and
tm.Thetypes
clock_tandtime_tarecapableofrepresentingthesystemtimeanddateassome
sortofinteger.Thisiscalledthe
calendartime.
Thestructuretype
tmholdsthedateandtime
brokendownintoitselements.The
tmstructureisdefinedasshownhere:
struct tm {int tm_sec;  /* seconds, 0-61 */int tm_min;  /* minutes, 0-59 */
int tm_hour; /* hours, 0-23 */
int tm_mday; /* day of the month, 1-31 */
int tm_mon;  /* months since Jan, 0-11 */
int tm_year; /* years from 1900 */
int tm_wday; /* days since Sunday, 0-6 */
int tm_yday; /* days since Jan 1, 0-365 */
int tm_isdst /* Daylight Saving Timeindicator */}The value oftm_isdstwill be positive if daylight saving time is in effect, zero if it is
not in effect, and negative if there is no information available. This form of the time and
date is called thebroken-downtime.
In addition,<ctime>defines the macro
CLOCKS_PER_SEC, which is the numberof system clock ticks per second.Thegeopoliticalenvironmentalfunctionsrequiretheheader
<clocale>.(ACprogram
must use the header filelocale.h.)asctime#include <ctime>char *asctime(const struct tm *ptr);Theasctime( )function returns a pointer to a string that contains the information
stored in the structure pointed to by
ptrconverted into the following form:day month date hours:minutes:seconds year\n\0For example:Fri Apr 15 12:05:34 2005Thestructurepointerpassedto
asctime()
isusuallyobtainedfromeither
localtime()
orgmtime( ).The buffer used by
asctime( )to hold the formatted output string is a staticallyallocated character array and is overwritten each time the function is called. If youwish to save the contents of the string, you must copy it elsewhere.
Related functions are
localtime( ),gmtime( ),time( ), andctime( ).clock#include <ctime>clock_t clock(void);Theclock( )function returns a value that approximates the amount of time the
calling program has been running. To transform this value into seconds, divide it by
CLOCKS_PER_SEC. Avalue of –1 is returned if the time is not available.
Related functions are
time( ),asctime( ), andctime( ).ctime#include <ctime>char *ctime(const time_t *time);Thectime( )function returns a pointer to a string of the form
day month year hours:minutes:seconds year\n\0given a pointer to the calendar time. The calendar time is often obtained through a call
totime( ).Thebufferusedby
ctime()
toholdtheformattedoutputstringisastaticallyallocated
character array and is overwritten each time the function is called. If you wish to save

the contents of the string, it is necessary to copy it elsewhere.
Related functions are
localtime( ),gmtime( ),time( ), andasctime( ).THESTANDARD
FUNCTIONLIBRARY
Chapter28:Time,Date,andLocalizationFunctions
749difftime
#include <ctime>double difftime(time_ttime2, time_ttime1);Thedifftime( )
function returns the difference, in seconds, between
time1andtime2.That is,time2 –time1.Related functions are
localtime( ),gmtime( ),time( ),asctime( ).gmtime#include <ctime>
structtm *gmtime(const time_t *
time);Thegmtime( )function returns a pointer to the broken-down form of
timein theform of atmstructure. The time is represented in Coordinated Universal Time (UTC),
which is essentially Greenwich mean time. The
timevalue is usually obtained through
a call totime( ). If the system does not support UTC,NULLis returned.
Thestructureusedby
gmtime()
toholdthebroken-downtimeisstaticallyallocated
and is overwritten each time the function is called. If you wish to save the contents ofthe structure, you must copy it elsewhere.
Related functions are
localtime( ),time( ), andasctime( ).localeconv#include <clocale>struct lconv *localeconv(void);Thelocaleconv( )function returns a pointer to a structure of type
lconv, whichcontains various geopolitical environmental information relating to the way numbers
are formatted. The
lconvstructure is organized as shown here:
struct lconv {char *decimal_point;     /* decimal point characterfor nonmonetary values */char *thousands_sep;     /* thousands separatorfor nonmonetary values */char *grouping;          /* specifies grouping for750C++:TheCompleteReference
Chapter28:Time,Date,andLocalizationFunctions
751THESTANDARD
FUNCTIONLIBRARY
nonmonetary values */char *int_curr_symbol;   /* international currency symbol */char *currency_symbol;   /* local currency symbol */
char *mon_decimal_point; /* decimal point character formonetary values */char *mon_thousands_sep; /* thousands separator formonetary values */char *mon_grouping;      /* specifies grouping formonetary values */char *positive_sign;     /* positive value indicator formonetary values */char *negative_sign;     /* negative value indicator formonetary values */char int_frac_digits;    /* number of digits displayed to theright of the decimal point formonetary values displayed using
international format */char frac_digits;        /* number of digits displayed to theright of the decimal point for
monetary values displayed using
local format */char p_cs_precedes;      /* 1 if currency symbol precedespositive value, 0 if currency
symbol follows value */char p_sep_by_space;     /* 1 if currency symbol isseparated from value by a space,
0 otherwise */char n_cs_precedes;      /* 1 if currency symbol precedesa negative value, 0 if currency
symbol follows value */char n_sep_by_space;     /* 1 if currency symbol isseparated from a negative
value by a space, 0 if
currency symbol follows value */char p_sign_posn;        /* indicates position ofpositive value symbol */char n_sign_posn;        /* indicates position ofnegative value symbol */}Thelocaleconv( )function returns a pointer to the
lconvstructure. You must
not alter the contents of this structure. Refer to your compiler's documentation for
implementation-specific information relating to the
lconvstructure.
Arelated function is
setlocale( ).localtime#include <ctime>struct tm *localtime(const time_t *time);Thelocaltime( )function returns a pointer to the broken-down form of
timein theform of atmstructure. The time is represented in local time. The
timevalue is usuallyobtained through a call to
time( ).Thestructureusedby
localtime()
toholdthebroken-downtimeisstaticallyallocated
and is overwritten each time the function is called. If you wish to save the contents ofthe structure, you must copy it elsewhere.
Related functions are
gmtime( ),time( ), andasctime( ).mktime#include <ctime>time_t mktime(struct tm *time);Themktime( )function returns the calendar-time equivalent of the broken-down
time found in the structure pointed to by
time.The elementstm_wdayandtm_ydayare set by the function, so they need not be defined at the time of the call.
Ifmktime()
cannotrepresenttheinformationasavalidcalendartime,–1isreturned.
Related functions are
time( ),gmtime( ),asctime( ), andctime( ).setlocale#include <clocale>
char *setlocale(inttype, const char *locale);Thesetlocale()
functionallowscertainparametersthataresensitivetothegeopolitical
environment of a program's execution to be queried or set. If
localeis null,setlocale( )returns a pointer to the current localization string. Otherwise,
setlocale( )attempts touse the string specified bylocaleto set the locale parameters as specified bytype.Referto your compiler's documentation for the localization strings that it supports.At the time of the call,typemust be one of the following macros:
752C++:TheCompleteReference
Chapter28:Time,Date,andLocalizationFunctions
753THESTANDARD
FUNCTIONLIBRARY
LC_ALLLC_COLLATE
LC_CTYPE
LC_MONETARY
LC_NUMERIC
LC_TIMELC_ALLrefers to all localization categories.
LC_COLLATE
affects the operation
of thestrcoll( )function.LC_CTYPEalters the way the character functions work.LC_MONETARY
determines the monetary format.LC_NUMERICchanges thedecimal-point character for formatted input/output functions. Finally,
LC_TIMEdetermines the behavior of thestrftime( )function.Thesetlocale( )function returns a pointer to a string associated with the
typeparameter.
Related functions are
localeconv( ),time( ),strcoll( ), andstrftime( ).strftime
#include <ctime>size_t strftime(char *str, size_tmaxsize, const char *fmt,const struct tm *time);Thestrftime()
functionplacestimeanddateinformation,alongwithother
information, into the string pointed to bystraccording to the format commands found
in the string pointed to byfmtand using the broken-down time
time.Amaximum of
maxsizecharacters will be placed intostr.
Thestrftime( )function works a little likesprintf( )in that it recognizes a set of
format commands that begin with the percent sign (%) and places its formatted output
into a string. The format commands are used to specify the exact way various time and

date information is represented in
str.
Any other characters found in the format stringareplacedinto
strunchanged.Thetimeanddatedisplayedareinlocaltime.Theformat
commands are shown in the table below. Notice that many of the commands are case

sensitive.Thestrftime( )function returns the number of characters placed in the string
pointed to bystror zero if an error occurs.
CommandReplacedBy
%aAbbreviated weekday name
%AFull weekday nameCommandReplacedBy
%bAbbreviated month name
%BFull month name%cStandard date and time string
%dDay of month as a decimal (1-31)%HHour (0-23)%IHour (1-12)%jDay of year as a decimal (1-366)%mMonth as decimal (1-12)%MMinute as decimal (0-59)%pLocale's equivalent of AM or PM%SSecond as decimal (0-60)%UWeek of year, Sunday being first day (0-53)
%wWeekday as a decimal (0-6, Sunday being 0)
%WWeek of year, Monday being first day (0-53)
%xStandard date string
%XStandard time string
%yYear in decimal without century (0-99)
%YYear including century as decimal
%ZTime zone name
%%The percent sign
Related functions are
time( ),localtime( ), andgmtime( ).time#include <ctime>time_t time(time_t *time);Thetime( )function returns the current calendar time of the system. If the system
has no time, –1 is returned.
754C++:TheCompleteReference
Thetime( )function can be called either with a null pointer or with a pointer toa variable of typetime_t. If the latter is used, the variable will also be assigned thecalendar time.Related functions are
localtime( ),gmtime( ),strftime( ), andctime( ).Chapter28:Time,Date,andLocalizationFunctions
755THESTANDARD
FUNCTIONLIBRARY
This page intentionally left blank Chapter29
The DynamicAllocation Functions757Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
Thischapterdescribesthedynamicallocationfunctions,whichwereinheritedfrom
the C language. At their core are the functionsmalloc( )andfree( ). Each timemalloc( )is called, a portion of the remaining free memory is allocated. Eachtimefree( )is called, memory is returned to the system. The region of free memoryfrom which memory is allocated is called theheap. The prototypes for the dynamicallocation functions are in<cstdlib>. A C program must use the header filestdlib.h.All C++ compilers will include at least these four dynamic allocation functions:calloc( ),malloc( ),free( ),realloc( ). However, your compiler will almost certainly
contain several variants on these functions to accommodate various options and
environmental differences. You will want to refer to your compiler's documentation.
WhileC++supportsthedynamicallocationfunctionsdescribedhere,youwill
typically not use them in a C++ program. The reason for this is that C++ provides the

dynamic allocation operatorsnewanddelete. There are several advantages to using
the dynamic allocation operators. First,newautomatically allocates the correct amount
of memory for the type of data being allocated. Second, it returns the correct type of

pointer to that memory. Third, both
newanddeletecan be overloaded. SincenewanddeletehaveadvantagesovertheC-baseddynamicallocationfunctions,theiruseis
recommended for C++ programs.
calloc#include <cstdlib>void*calloc(size_t
num, size_tsize);Thecalloc( )function allocates memory the size of which is equal tonum * size.That is,calloc( )allocates sufficient memory for an array of
numobjects of sizesize.Thecalloc()
functionreturnsapointertothefirstbyteoftheallocatedregion.
Ifthereisnotenoughmemorytosatisfytherequest,anullpointerisreturned.Itis
always important to verify that the return value is not null before attempting to use it.
Related functions are
free( ),malloc( ), andrealloc( ).free
#include <cstdlib>void free(void *ptr);Thefree( )function returns the memory pointed to by
ptrto the heap. This makesthe memory available for future allocation.
Itisimperativethat
free()
onlybecalledwithapointerthatwaspreviouslyallocated
using one of the dynamic allocation system's functions (eithermalloc( )orcalloc( )).758C++:TheCompleteReference
Using an invalid pointer in the call most likely will destroy the memory management
mechanism and cause a system crash.Related functions are
calloc( ),malloc( ), andrealloc( ).malloc#include <cstdlib>void *malloc(size_tsize);Themalloc( )function returns a pointer to the first byte of a region of memory of
sizesizethat has been allocated from the heap. If there is insufficient memory in the
heap to satisfy the request,
malloc( )returns a null pointer. It is always important to
verify that the return value is not null before attempting to use it. Attempting to use
a null pointer will usually result in a system crash.
Related functions are
free( ),realloc( ), andcalloc( ).realloc
#include <cstdlib>void *realloc(void *ptr, size_tsize);Therealloc( )function changes the size of the previously allocated memory pointed
toby
ptrtothatspecifiedby
size.Thevalueof
sizemaybegreaterorlessthantheoriginal.
Apointer to the memory block is returned because it may be necessary for
realloc( )tomove the block in order to increase its size. If this occurs, the contents of the old block
are copied into the new block—no information is lost.
Ifptris null,realloc( )simply allocatessizebytes of memory and returns a pointer
to it. Ifsizeis zero, the memory pointed to by
ptris freed.
If there is not enough free memory in the heap to allocate
sizebytes, a null pointeris returned, and the original block is left unchanged.
Related functions are
free( ),malloc( ), andcalloc( ).Chapter29:TheDynamicAllocationFunctions
759THESTANDARD
FUNCTIONLIBRARY
This page intentionally left blank Chapter30
Utility Functions761Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
762C++:TheCompleteReference
The standard function library defines several utility functions that provide variouscommonly used services. They include a number of conversions, variable-length
argument processing, sorting and searching, and random number generation.Manyofthefunctionscoveredhererequiretheuseoftheheader
<cstdlib>.(ACprogram
must use the header filestdlib.h.) In this header are defineddiv_tandldiv_t, whichare the types of values returned bydiv( )andldiv( ), respectively. Also defined is thetypesize_t,whichistheunsignedvaluereturnedby
sizeof.Thefollowingmacros
are defined:Macro
MeaningMB_CUR_MAXMaximun length (in bytes) of a multibyte character.
NULLAnull pointer.

RAND_MAXThe maximum value that can be returned by the
rand( )function.EXIT_FAILUREThe value returned to the calling process if program
termination is unsuccessful.EXIT_SUCCESSThe value returned to the calling process if program
termination is successful.If a function requires a different header than
<cstdlib>, that function descriptionwill discuss it.abort
#include <cstdlib>void abort(void);Theabort()
functioncausesimmediateabnormalterminationofaprogram.Generally,
nofilesareflushed.Inenvironmentsthatsupportit,
abort()
willreturnanimplementation-
defined value to the calling process (usually the operating system) indicating failure.
Related functions are
exit( )andatexit( ).abs#include <cstdlib>
int abs(intnum);long abs(longnum);double abs(doublenum);Theabs( )function returns the absolute value of
num. Thelongversion ofabs( )isthe same aslabs( ). Thedoubleversion ofabs( )is the same asfabs( ).Arelated function is
labs( ).assert
#include <cassert>void assert(intexp);Theassert( )macro, defined in its header
<cassert>, writes error information to
stderrandthenabortsprogramexecutioniftheexpression
expevaluatestozero.
Otherwise,assert()
doesnothing.Althoughtheexactoutputisimplementation
defined, many compilers use a message similar to this:Assertion failed: <expression>, file <file>, line <linenum>Theassert()
macroisgenerallyusedtohelpverifythataprogramisoperating
correctly,withtheexpressionbeingdevisedinsuchawaythatitevaluatestotrue
onlywhennoerrorshavetakenplace.
It is not necessary to remove the
assert( )statements from the source code once
a program is debugged because if the macro
NDEBUGis defined (as anything), theassert( )macros will be ignored.
Arelated function is
abort( ).atexit#include <cstdlib>int atexit(void (*func)(void));Theatexit()
functioncausesthefunctionpointedtoby
functobecalleduponnormal
program termination. The
atexit( )function returns zero if the function is successfully
registered as a termination function, nonzero otherwise.
At least 32 termination functions may be established, and they will be called in thereverse order of their establishment.
Related functions are
exit( )andabort( ).atof#include <cstdlib>
double atof(const char *str);Chapter30:UtilityFunctions
763THESTANDARD
FUNCTIONLIBRARY
764C++:TheCompleteReference
Theatof( )function converts the string pointed to bystrinto adoublevalue. Thestring must contain a valid floating-point number. If this is not the case, the returned
value is undefined.Thenumbermaybeterminatedbyanycharacterthatcannotbepartofavalidfloating-
pointnumber.Thisincludeswhitespace,punctuation(otherthanperiods),andcharacters

otherthanEore.Thismeansthatif
atof()
iscalledwith"100.00HELLO",thevalue100.00
willbereturned.
Related functions are
atoi( )andatol( ).atoi#include <cstdlib>int atoi(const char *str);Theatoi( )function converts the string pointed to bystrinto anintvalue. Thestring must contain a valid integer number. If this is not the case, the returned value
is undefined; however, most implementations will return zero.
Thenumbermaybeterminatedbyanycharacterthatcannotbepartofaninteger
number.Thisincludeswhitespace,punctuation,andcharacters.Thismeansthatif
atoi()
iscalledwith"123.23",theintegervalue123willbereturned,andthe".23"isignored.
Related functions are
atof( )andatol( ).atol#include <cstdlib>long atol(const char *str);Theatol( )function converts the string pointed to bystrinto alongvalue. Thestring must contain a valid long integer number. If this is not the case, the returned
value is undefined; however, most implementations will return zero.
The number may be terminated by any character that cannot be part of an integernumber.Thisincludeswhitespace,punctuation,andcharacters.Thismeansthatif

atol( )is called with "123.23", the long integer value 123Lwill be returned, and the ".23"
is ignored.
Related functions are
atof( )andatoi( ).bsearch
#include <cstdlib>void *bsearch(const void *key, const void *buf,size_tnum, size_tsize,int (*compare)(const void *, const void *));Thebsearch( )function performs a binary search on the sorted array pointed to by
bufandreturnsapointertothefirstmemberthatmatchesthekeypointedtoby
key.
The number of elements in the array is specified bynum, and the size (in bytes) of eachelement is described bysize.The function pointed to bycompare
is used to compare an element of the array with
the key. The form of the
compare
function must be as follows:intfunc_name(const void *arg1, const  void *arg2);It must return values as described in the following table:
ComparisonValueReturned
arg1
is less thanarg2
Less than zero
arg1
is equal toarg2
Zero
arg1
is greater than
arg2
Greater than zero
The array must be sorted in ascending order with the lowest address containing the
lowest element.If the array does not contain the key, a null pointer is returned.

Arelated function is
qsort( ).div#include <cstdlib>div_t div(intnumerator, intdenominator);ldiv_t div(longnumerator, longdenominator);Theintversion ofdiv( )returns the quotient and the remainder of the operation
numerator / denominatorin a structure of type
div_t. Thelongversion ofdiv( )returns
the quotient and remainder in a structure of type
ldiv_t. Thelongversion ofdiv( )provides the same capabilities as the
ldiv( )function.The structure type
div_twill have at least these two fields:int quot; /* quotient */
int rem;  /* remainder */Chapter30:UtilityFunctions
765THESTANDARD
FUNCTIONLIBRARY
The structure type
ldiv_twill have at least these two fields:long quot; /* quotient */long rem;  /* remainder */Arelated function is
ldiv( ).exit#include <cstdlib>
void exit(intexit_code);Theexit( )function causes immediate, normal termination of a program.
The value ofexit_codeis passed to the calling process, usually the operating
system, if the environment supports it. By convention, if the value of
exit_codeiszero, or
EXIT_SUCCESS, normal program termination is assumed. Anonzero
value, orEXIT_FAILURE
, is used to indicate an implementation-defined error.
Related functions are
atexit( )andabort( ).getenv#include <cstdlib>
char *getenv(const char *name);Thegetenv( )function returns a pointer to environmental information associated
withthestringpointedtoby
nameintheimplementation-definedenvironmental
information table. The string returned must never be changed by the program.
The environment of a program may include such things as path names and devices
online. The exact nature of this data is implementation defined. You will need to refer
to your compiler's documentation for details.If a call is made togetenv( )with an argument that does not match any of the
environment data, a null pointer is returned.
Arelated function is
system( ).labs#include <cstdlib>long labs(longnum);Thelabs( )function returns the absolute value of
num.Arelated function is
abs( ).766C++:TheCompleteReference
Chapter30:UtilityFunctions
767THESTANDARD
FUNCTIONLIBRARY
ldiv#include <cstdlib>ldiv_t ldiv(longnumerator, longdenominator);Theldiv( )function returns the quotient and the remainder of the operation
numerator / denominator.
The structure type
ldiv_twill have at least these two fields:long quot; /* quotient */
long rem;  /* remainder */Arelated function is
div( ).longjmp#include <csetjmp>
void longjmp(jmp_bufenvbuf, intstatus);Thelongjmp( )function causes program execution to resume at the point of the last
call tosetjmp( ). These two functions provide a means of jumping between functions.
Notice that the header<csetjmp>is required.
Thelongjmp( )function operates by resetting the stack to the state as described
inenvbuf,which must have been set by a prior call tosetjmp( ). This causes program
execution to resume at the statement following the
setjmp( )invocation. That is, thecomputer is "tricked" into thinking that it never left the function that calledsetjmp( ).(As a somewhat graphic explanation, thelongjmp( )function "warps" across time and
(memory) space to a previous point in your program without having to perform the
normal function return process.)
The buffer
evnbufis of typejmp_buf, which is defined in the header<csetjmp>.The buffer must have been set through a call to
setjmp( )prior to callinglongjmp( ).Thevalueof
statusbecomesthereturnvalueof
setjmp()
andmaybeinterrogatedto
determinewherethelongjumpcamefrom.Theonlyvaluethatisnotallowediszero.
By far the most common use oflongjmp( )is to return from a deeply nested set
of routines when an error occurs.
Arelated function is
setjmp( ).mblen#include <cstdlib>int mblen(const char *str, size_tsize);Themblen( )function returns the length (in bytes) of a multibyte character pointed
to bystr. Only the firstsizenumber of characters are examined. It returns –1 on error.
Ifstris null, thenmblen( )returns non-zero if multibyte characters have state-
dependent encodings. If they do not, zero is returned.
Related functions are
mbtowc( ) and wctomb( ).mbstowcs#include <cstdlib>size_t mbstowcs(wchar_t *out, const char *in, size_tsize);Thembstowcs( )function converts the multibyte string pointed to byininto a widecharacter string and puts that result in the array pointed to by
out.Onlysizenumber ofbytes will be stored in
out.Thembstowcs( )function returns the number of multibyte characters that are
converted. If an error occurs, the function returns –1.
Related functions are
wcstombs( ),mbtowc( ).mbtowc#include <cstdlib>
int mbtowc(wchar_t *out, const char *in, size_tsize);Thembtowc( )function converts the multibyte character in the array pointed to byininto its wide character equivalent and puts that result in the object pointed to by
out.Onlysizenumber of characters will be examined.This function returns the number of bytes that are put into
out.–1 is returned if an
error occurs. If
inis null, thenmbtowc( )returns non-zero if multibyte characters have
state-dependent encodings. If they do not, zero is returned.
Related functions are
mblen( ),wctomb( ).qsort
#include <cstdlib>
void qsort(void *buf, size_tnum, size_tsize,int (*compare) (const void *, const void *));768C++:TheCompleteReference
Chapter30:UtilityFunctions
769THESTANDARD
FUNCTIONLIBRARY
Theqsort( )function sorts the array pointed to bybufusing a Quicksort (developedby C.A.R. Hoare). The Quicksort is the best general-purpose sorting algorithm. Upon
termination, the array will be sorted. The number of elements in the array is specified
bynum, and the size (in bytes) of each element is described bysize.Thefunctionpointedtoby
compare
isusedtocompareanelementofthearray
withthekey.Theformofthe
compare
functionmustbeasfollows:
intfunc_name(const void *arg1,const void *arg2);It must return values as described here:
ComparisonValueReturned
arg1
is less thanarg2
Less than zero
arg1
is equal toarg2
Zero
arg1
is greater than
arg2
Greater than zero
The array is sorted into ascending order with the lowest address containing the
lowest element.Arelated function is
bsearch( ).raise#include <csignal>int raise(intsignal);Theraise( )function sends the signal specified bysignalto the executing program.
It returns zero if successful, and nonzero otherwise. It uses the header
<csignal>.The following signals are defined by Standard C++. Of course, your compiler is free
to provide additional signals.
Macro
MeaningSIGABRT
Termination error
SIGFPEFloating-point error
SIGILLBad instruction
Macro
MeaningSIGINTUser pressed
CTRL-CSIGSEGVIllegal memory accessSIGTERMTerminate program
Arelated function is
signal( ).rand#include <cstdlib>int rand(void);Therand( )function generates a sequence of pseudorandom numbers. Each time itis called, an integer between zero and
RAND_MAXis returned.
Arelated function is
srand( ).setjmp#include <csetjmp>
int setjmp(jmp_bufenvbuf);Thesetjmp( )function saves the contents of the system stack in the buffer
envbufforlater use bylongjmp( ). It uses the header<csetjmp>.Thesetjmp( )function returns zero upon invocation. However,
longjmp( )passesan argument to
setjmp( )when it executes, and it is this value (always nonzero) that
will appear to be the value ofsetjmp( )after a call tolongjmp( )has occurred.
Seelongjmpfor additional information.Arelated function is
longjmp( ).signal#include <csignal>
void (*signal(intsignal, void (*func)(int))) (int);770C++:TheCompleteReference
Chapter30:UtilityFunctions
771THESTANDARD
FUNCTIONLIBRARY
Thesignal( )function registers the function pointed to by
funcas a handler for thesignal specified bysignal. That is, the function pointed to byfuncwill be called whensignalis received by your program.
The value offuncmay be the address of a signal handler function or one of the
following macros, defined in
<csignal>:Macro
MeaningSIG_DFLUse default signal handlingSIG_IGNIgnore the signal
If a function address is used, the specified handler will be executed when its signal
is received.
On success,signal( )returns the address of the previously defined function for the
specified signal. On error,
SIG_ERR(defined in<csignal>) is returned.
Arelated function is
raise( ).srand#include <cstdlib>void srand(unsignedseed);Thesrand( )function is used to set a starting point for the sequence generated byrand( ). (Therand( )function returns pseudorandom numbers.)
srand( )is generally used to allow multiple program runs to use different sequences
of pseudorandom numbers by specifying different starting points. Conversely, you can
also usesrand( )to generate the same pseudorandom sequence over and over again bycalling it with the same seed before obtaining each sequence.
Arelated function is
rand( ).strtod
#include <cstdlib>double strtod(const char *start, char **end);Thestrtod( )function converts the string representation of a number stored in the
string pointed to bystartinto adoubleand returns the result.
Thestrtod( )function works as follows. First, any white space in the string pointedto bystartis stripped. Next, each character that comprises the number is read. Any
character that cannot be part of a floating-point number will cause this process to stop.
This includes white space, punctuation (other than periods), and characters other than
E or e. Finally,
endis set to point to the remainder, if any, of the original string. This
means that ifstrtod( )is called with "100.00 Pliers", the value 100.00 will be returned,
andendwill point to the space that precedes "Pliers".
If no conversion takes place, zero is returned. If overflow occurs,
strtod( )returns
eitherHUGE_VAL
or –HUGE_VAL
(indicating positive or negative overflow), and theglobal variableerrnois set toERANGE, indicating a range error. If underflow occurs,
then zero is returned and the global variable
errnois set toERANGE.Arelated function is
atof( ).strtol
#include <cstdlib>long strtol(const char *start, char **end,intradix);Thestrtol( )function converts the string representation of a number stored in the
string pointed to bystartintoa
longand returns the result. The base of the number is
determinedby
radix.Ifradixiszero,thebaseisdeterminedbyrulesthatgovernconstant
specification. If
radixis other than zero, it must be in the range 2 through 36.
Thestrtol( )function works as follows. First, any white space in the string pointedto bystartis stripped. Next, each character that comprises the number is read. Any
character that cannot be part of a long integer number will cause this process to stop.
This includes white space, punctuation, and characters. Finally,
endis set to point tothe remainder, if any, of the original string. This means that if
strtol( )is called with"100Pliers",thevalue100Lwillbereturned,and
endwillpointtothespacethat
precedes "Pliers".
Iftheresultcannotberepresentedbyalonginteger,
strtol()
returnseither
LONG_MAXorLONG_MINandtheglobal
errnoissetto
ERANGE,indicating
arangeerror.Ifnoconversiontakesplace,zeroisreturned.
Arelated function is
atol( ).strtoul
#include <cstdlib>unsigned long strtoul(const char *start, char **end,intradix);772C++:TheCompleteReference
Thestrtoul()
functionconvertsthestringrepresentationofanumberstoredin
thestringpointedtoby
startintoan
unsignedlong
andreturnstheresult.Thebase
ofthenumberisdeterminedby
radix.Ifradixiszero,thebaseisdeterminedbyrules
thatgovernconstantspecification.Iftheradixisspecified,itmustbeintherange2
through36.
Thestrtoul( )function works as follows. First, any white space in the string pointedtoby
startisstripped.Next,eachcharacterthatcomprisesthenumberisread.Any
characterthatcannotbepartofanunsignedlongintegernumberwillcausethis

process to stop. This includes white space, punctuation, and characters. Finally,
endisset to point to the remainder, if any, of the original string. This means that if
strtoul( )is called with " 100 Pliers", the value 100Lwill be returned, and
endwill point to thespace that precedes "Pliers".
If the result cannot be represented by an unsigned long integer,
strtoul( )returns
ULONG_MAXand the global variableerrnois set toERANGE, indicating a rangeerror. If no conversion takes place, zero is returned.
Arelated function is
strtol( ).system#include <cstdlib>int system(const char *str);Thesystem( )function passes the string pointed to bystras a command to thecommand processor of the operating system.
Ifsystem()
iscalledwithanullpointer,itwillreturnnonzeroifacommand
processor is present, and zero otherwise. (Some C++ code will be executed in dedicated
systems that do not have operating systems and command processors, so you may not

be able to assume that a command processor is present.) The return value of
system( )is implementation defined. However, generally it will return zero if the command was

successfully executed, and nonzero otherwise.
Arelated function is
exit( ).va_arg, va_start, and va_end
#include <cstdarg>typeva_arg(va_listargptr,type);void va_end(va_listargptr);void va_start(va_listargptr,last_parm);Theva_arg( ),va_start( ), andva_end( )macros work together to allow a variable
numberofargumentstobepassedtoafunction.Themostcommonexampleof
Chapter30:UtilityFunctions
773THESTANDARD
FUNCTIONLIBRARY
a function that takes a variable number of arguments is
printf( ). The typeva_listisdefined by <cstdarg>.Thegeneralprocedureforcreatingafunctionthatcantakeavariablenumberof
argumentsisasfollows.Thefunctionmusthaveatleastoneknownparameter,but
may have more, prior to the variable parameter list. The rightmost known parameter is

called thelast_parm.The name oflast_parmis used as the second parameter in a call tova_start( ). Before any of the variable-length parameters can be accessed, the argument

pointerargptr
must be initialized through a call to
va_start( ). After that, parameters are
returned via calls to
va_arg( ), withtypebeing the type of the next parameter. Finally,
once all the parameters have been read and prior to returning from the function, a call

tova_end( )must be made to ensure that the stack is properly restored. If
va_end( )isnot called, a program crash is very likely.
Arelated function is
vprintf( ).wcstombs#include <cstdlib>size_t wcstombs(char *out, const wchar_t *in, size_tsize);Thewcstombs()
convertsthewide-characterarraypointedtoby
inintoits
multibyte equivalent and puts the result in the array pointed to by
out. Only the firstsizebytes ofinare converted. Conversion stops before that if the null terminator is
encountered.
If successful,wcstombs( )returns the number of bytes converted. On failure, –1
is returned.
Related functions are
wctomb( )andmbstowcs( ).wctomb#include <cstdlib>
int wctomb(char *out,  wchar_tin);Thewctomb( )converts the wide character inininto its multibyte equivalent andputs the result in the object pointed to by
out. The array pointed to byoutmust be atleastMB_CUR_MAXcharacters long.If successful,wctomb( )returns the number of bytes contained in the multibyte
character. On failure, –1 is returned.
Ifoutis null, thenwctomb( )returns nonzero if the multibyte character has state-
dependent encodings and zero if it does not.
Related functions are
wcstombs( )andmbtowc( ).774C++:TheCompleteReference
Chapter31
The Wide-Character
Functions775Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
In 1995, a number of wide-character functions were added to Standard C andsubsequently adopted by Standard C++. The wide-character functions operate
on characters of typewchar_t, which are 16 bits. For the most part these functionsparalleltheir
charequivalents.Forexample,thefunction
iswspace()
isthewide-
character version ofisspace( ). In general, the wide-character functions use the samenames as theircharequivalents, except that a "w" is added.The wide-character functions use two headers:<cwchar>and<cwctype>. The Cheader fileswchar.h
andwctype.hare also supported.
The header<cwctype>defines the typeswint_t,wctrans_t, andwctype_t. Many ofthewide-characterfunctionsreceiveawidecharacterasaparameter.Thetypeofthis

parameteris
wint_t.Itiscapableofholdingawidecharacter.Theuseofthe
wint_ttype in the wide-character functions parallels the use ofintin thechar-based functions.wctrans_tandwctype_tare the types of objects used to represent a character mapping
(i.e., character translation) and the classification of a character, respectively. The wide-

character EOF mark is defined asWEOF.In addition to definingwin_t, the header<cwchar>defines the typeswchar_t,size_t,and
mbstate_t.The
wchar_ttypecreatesawidecharacterobject,and
size_tisthetypeofvaluereturnedby
sizeof.The
mbstate_ttypedescribesanobjectthat
holds the state of a multibyte-to-wide-character conversion. The<cwchar>header alsodefines the macros
NULL,WEOF,WCHAR_MAX, andWCHAR_MIN. The last twodefine the maximum and minimum value that can be held in an object of typewchar_t.Althoughthestandardfunctionlibrary'ssupportforwidecharactersisquiteextensive,
these functions are not frequently used. One reason for this is that the Standard C++

I/Osystemandclasslibrariesprovidebothnormalandwide-charactersupportthrough

the use of template classes. Also, interest in wide-character-compliant programs has

been less than expected. Of course, this situation may change.Since most of the wide-character functions simply parallel theircharequivalentsand are not frequently used by most C++ programmers, only a brief description of

these functions is provided.
The Wide-Character Classification Functions
The header<cwctype>provides the prototypes for the wide-character functions that
supportcharacterclassification.Thesefunctionscategorizewidecharactersastotheirtype

or convert the case of a character. Table 31-1 lists these functions along with their
charequivalents, which are described in Chapter 26.
In addition to the functions shown in Table 31-1,
<cwctype>defines the followingones, which provide an open-ended means of classifying characters.
wctype_t wctype(const char *attr);
int iswctype(wint_tch, wctype_tattr_ob);776C++:TheCompleteReference
Chapter31:TheWide-CharacterFunctions
777THESTANDARD
FUNCTIONLIBRARY
The functionwctype( )returns a value that can be passed to the
attr_obparametertoiswctype( ). The string pointed to byattrspecifies a property that a character must
have. The value inattr_obis used to determine ifchis a character that has that property.
Ifitdoes,
iswctype()
returnsnonzero.Otherwise,itreturnszero.Thefollowing
property strings are defined for all execution environments.
alnumalphacntrl
digitgraphlowerprint
punctspaceupperxdigit
The following program demonstrates the
wctype( )andiswctype( )functions.#include <iostream>#include <cwctype>
using namespace std;Functionchar Equivalentint iswalnum(wint_tch)isalnum( )int iswalpha(wint_tch)isalpha( )int iswcntrl(wint_tch)iscntrl( )int iswdigit(wint_tch)isdigit( )int iswgraph(wint_tch)isgraph( )int iswlower(wint_tch)islower( )int iswprint(wint_tch)isprint( )int iswpunct(wint_tc)ispunct( )int iswspace(wint_tch)isspace( )int iswupper(wint_tch)isupper( )int iswxdigit(wint_tch)isxdigit( )wint_t tolower(wint_tch)tolower( )wint_t toupper(wint_tch)toupper( )Table31-1.
The Wide-Character Classification Functions778C++:TheCompleteReference
int main(){wctype_t x;x = wctype("space");
if(iswctype(L' ', x))cout << "Is a space.\n";return 0;}This program displays "Is a space."
The functionswctrans( )andtowctrans( )are also defined in
<cwctype>. They are
shown here:
wctrans_t wctrans(const char *mapping);wint_t towctrans(wint_tch, wctrans_tmapping_ob);The functionwctrans( )returns a value that can be passed to the
mapping_obparametertotowctrans()
.Here,thestringpointedtoby
mappingspecifiesamappingofonecharacter
to another. This value can then be used by
iswctrans( )to mapch. The mapped value isreturned. The following mapping strings are supported in all execution environments.
tolowertoupperHere is a short example that demonstrates
wctrans( )andtowctrans( ).#include <iostream>#include <cwctype>
using namespace std;int main(){wctrans_t x;x = wctrans("tolower");wchar_t ch = towctrans(L'W', x);cout << (char) ch;return 0;}This program displays a lowercase "w".
The Wide-Character I/O Functions
SeveraloftheI/OfunctionsdescribedinChapter25havewide-characterimplementations.
ThesefunctionsareshowninTable31-2.Thewide-characterI/Ofunctionsusetheheader

<cwchar>. Notice thatswprintf( )andvswprintf( )require an additional parameter not
needed by theircharequivalents.In addition to those shown in the table, the following wide-character I/O functionhas been added:int fwide(FILE *stream, inthow);Ifhowis positive,fwide( )makesstream
a wide-character stream. If
howis negative,fwide( )makes stream into a
charstream. If
howis zero, the stream is unaffected. If the
streamhasalreadybeenorientedtoeitherwideornormalcharacters,itwillnotbe

changed. The function returns positive if the stream uses wide characters, negative if

thestreamuses
chars,andzeroifthestreamhasnotyetbeenoriented.Astream's
orientation is also determined by its first use.The Wide-Character String Functions
There are wide-character versions of the string manipulation functions described in

Chapter 26. These are shown in Table 31-3. They use the header
<cwchar>. Note thatwcstok( )requires an additional parameter not used by its
charequivalent.Wide-Character String Conversion Functions
The functions shown in Table 31-4 provide wide-character versions of the standard

numeric and time conversion functions. These functions use the header<cwchar>.THESTANDARD
FUNCTIONLIBRARY
Chapter31:TheWide-CharacterFunctions
779780C++:TheCompleteReference
Functionchar Equivalentwin_t fgetwc(FILE *stream
)fgetc( )wchar_t *fgetws(wchar_t *str, intnum,FILE *stream
)fgets( )wint_t fputwc(wchar_tch, FILE *stream
)fputc( )int fputws(const wchar_t *str, FILE *stream
)fputs( )
int fwprintf(FILE *stream
, const wchar_tfmt, ...)fprintf( )
int fwscanf(FILE *stream
, const wchar_tfmt, ...)fscanf( )
wint_t getwc(FILE *stream
)getc( )wint_t getwchar( )getchar( )wint_t putwc(wchar_tch, FILE *stream
)putc( )wint_t putwchar(wchar_tch)putchar( )int swprintf(wchar_t *str, size_tnum,const wchar_t *fmt, ...)sprintf( )Note the addition of the
parameternum, which limitsthe number of characters
written tostr.int swscanf(const wchar_t *str,const wchar_t *fmt, ...)sscanf( )wint_t ungetwc(wint_tch, FILE *stream
)ungetc( )int vfwprintf(FILE *stream
,const wchar_tfmt, va_listarg
)vfprintf( )int vswprintf(wchar_t *str, size_tnum,const wchar_t *fmt, va_listarg
)vsprintf( )
Note the addition of the
parameternum, which limitsthe number of characters
written tostr.int vwprintf(const wchar_t *fmt, va_listarg
)vprintf( )
int wprintf(const wchar_t *fmt, ...)printf( )int wscanf(const wchar_t *fmt, ...)scanf( )Table31-2.
The Wide-Character I/O FunctionsChapter31:TheWide-CharacterFunctions
781THESTANDARD
FUNCTIONLIBRARY
Functionchar Equivalentwchar_t *wcscat(wchar_t *str1, const wchar_t *str2)strcat( )
wchar_t *wcschr(const wchar_t *str, wchar_tch)strchr( )
int wcscmp(const wchar_t *str1, const wchar_t *str2)strcmp( )
int wcscoll(const wchar_t *str1, const wchar_t *str2)strcoll( )

size_t wcscspn(const wchar_t *str1,const wchar_t *str2)strcspn( )
wchar_t *wcscpy(wchar_t *str1, const wchar_t *str2)strcpy( )
size_t wcslen(const wchar_t *str)strlen( )wchar_t *wcsncpy(wchar_t *str1, const wchar_tstr2,size_tnum)strncpy( )wchar_t *wcsncat(wchar_t *str1, const wchar_tstr2,size_tnum)strncat( )int wcsncmp(const wchar_t *str1,const wchar_t *str2, size_tnum)strncmp( )wchar_t *wcspbrk(const wchar_t *str1,const wchar_t *str2)strpbrk( )wchar_t *wcsrchr(const wchar_t *
str, wchar_tch)strrchr( )
size_t wcsspn(const wchar_t *str1,const wchar_tstr2)strspn( )wchar_t *wcstok(wchar_t *str1, const wchar_t *str2,wchar_t **endptr)strtok( )Here,
endptris a pointerthat holds information
necessary to continue
the tokenizing process.
wchar_t *wcsstr(const wchar_t *str1,const wchar_t *str2)strstr( )size_t wcsxfrm(wchar_t *str1, const wchar_t *str2,size_tnum)strxfrm( )Table31-3.
The Wide-Character String FunctionsWide-Character Array Functions
The standard character array-manipulation functions, such as
memcpy( ), also havewide-character equivalents. They are shown in Table 31-5. These functions use the
header<cwchar>.782C++:TheCompleteReference
Functionchar Equivalentsize_t wcsftime(wchar_t *str, size_tmax,const wchar_t *fmt,
const struct tm *
ptr)strftime( )double wcstod(const wchar_t *start,wchar_t **end);strtod( )long wcstol(const wchar_t *start,  wchar_t **end,intradix)strtol( )unsigned long wcstoul(const wchar_t *start,wchar_t **end, intradix)strtoul( )Table31-4.
The Wide-Character Conversion FunctionsFunctionchar Equivalentwchar_t *wmemchr(const wchar_t *str,wchar_tch, size_tnum)memchr( )int wmemcmp(const wchar_t *str1,const wchar_t *str2, size_tnum)memcmp( )wchar_t *wmemcpy(wchar_t *str1,const wchar_t *str2,
size_tnum)memcpy( )wchar_t *wmemmove(wchar_t *str1,const wchar_t *str2,size_tnum)memmove( )wchar_t *wmemset(wchar_t *str, wchar_tch,size_tnum)memset( )Table31-5.
The Wide-Character Array Functions
Multibyte/Wide-Character
Conversion FunctionsThe Standard C++ function library supplies various functions that support conversions
between multibyte and wide characters. These functions, shown in Table 31-6, use the

header<cwchar>.Manyofthemare
restartable
versionsofthenormalmultibytefunctions.
The restartable version utilizes the state information passed to it in a parameter of type

mbstate_t. If this parameter is null, the function will provide its own
mbstate_tobject.Chapter31:TheWide-CharacterFunctions
783THESTANDARD
FUNCTIONLIBRARY
FunctionDescriptionwin_t btowc(intch)Convertschinto its wide-characterequivalent and returns the result.

ReturnsWEOFon error or if
chisnot a one-byte, multibyte character.
size_t mbrlen(const char *str, size_tnum,mbstate_t *state)Restartable version ofmblen( )asdescribed bystate. Returns a positivevalue that indicates the length of the
next multibyte character. Zero is

returned if the next character is null.

Anegative value is returned if an

error occurs.
size_t mbrtowc(wchar_t *out,const char *in, size_tnum,mbstate_t *state)Restartable version ofmbtowc( )asdescribed bystate. Returns a positivevalue that indicates the length of the
nextmultibytecharacter.Zerois

returned if the next character is null.

Anegative value is returned if an

error occurs. If an error occurs, the

macro
EILSEQis assigned toerrno.int mbsinit(const mbstate_t *state)Returns true if
staterepresents an
initial conversion state.size_t mbsrtowcs(wchar_t *out,const char **in,
size_tnum,mbstate_tstate)Restartable version ofmbstowcs( )asdescribed bystate. Also,mbsrtowcs( )differs from
mbstowcs( )in thatinisan indirect pointer to the source array.

If an error occurs, the macro
EILSEQis assigned toerrno.Table31-6.
Wide-Character/Multibyte Conversion Functions784C++:TheCompleteReference
FunctionDescriptionsize_t wcrtomb(char *out, wchar_tch,mbstate_t *state)Restartable version ofwctomb( )as described bystate. If an error
occurs, the macro
EILSEQisassigned toerrno.size_t wcsrtombs(char *out,const wchar_t **in,size_tnum,mbstate_t *state)Restartable version ofwcstombs( )asdescribed bystate. Also,wcsrtombs( )differs from
wcstombs( )in thatinisan indirect pointer to the source array.

If an error occurs, the macro
EILSEQis assigned toerrno.int wctob(wint_tch)Convertschinto its one-byte,multibyte equivalent. It returns

EOFon failure.
Table31-6.
Wide-Character/Multibyte Conversion Functions (continued)Part IV
The Standard C++ Class LibraryStandardC++definesanextensivesetofclassesthatprovidesupport
foranumberofcommonactivities,includingI/O,strings,andnumeric

processing.Theclasslibraryisinadditiontothefunctionlibrary

describedinPartThree.Theclasslibraryformsamajorportionofthe

C++languageanddefinesmuchofitscharacter.Despiteitssize,the

classlibraryiseasytomasterbecauseitisorganizedaround

object-oriented principles.Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
TheStandardC++libraryisquitelargeandanin-depthdescriptionofallofits
classes,features,attributes,andimplementationdetailsisbeyondthescopeofthis
book.(Afulldescriptionoftheclasslibrarywouldeasilyfillalargebook!)However,

whilemostoftheclasslibraryisforgeneraluse,someofitisintendedmostlyfor

compilerdevelopers,orthoseprogrammersimplementingextensionsorenhancements.

Therefore, this section describes only those parts of the class library that are typically

used in anapplication.Ifyouwillbeusingthelibraryforspecializedwork,youwill
needtoacquirea
 copy of the C++ standard, which contains the technical description
of the class library.
Chapter32
The Standard C++I/O Classes787Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This chapter describes the Standard C++ I/O class library. As explained in PartTwo, there are currently two versions of C++'s I/O library in common use. The
firstistheold-stylelibrary,whichisnotdefinedbyStandardC++.Thesecond
is the modern, templatized Standard C++ I/O system. Since the modern I/O library is
essentially a superset of the old-style one, its is the only one described here. However,
much of the information still applies to the older version.For an overview of C++ I/O, see Chapters 20 and 21.The I/O ClassesThe Standard C++ I/O system is constructed from a rather complex system of template

classes. These classes are shown here.
ClassPurposebasic_iosProvides general-purpose I/O operations
basic_streambufLow-level support for I/O
basic_istream
Support for input operationsbasic_ostream
Support for output operationsbasic_iostreamSupport for input/output operations
basic_filebufLow-level support for file I/Obasic_ifstream
Support for file inputbasic_ofstreamSupport for file output
basic_fstream
Support for file input/outputbasic_stringbufLow-level support for string-based I/O

basic_istringstreamSupport for string-based input

basic_ostringstreamSupport for string-based output

basic_stringstreamSupport for string-based input/output
Also part of the I/O class hierarchy is the non-template class
ios_base.Itprovides
definitions for various elements of the I/O system.788C++:TheCompleteReference
TheC++I/Osystemisbuiltupontworelatedbutdifferenttemplateclasshierarchies.
Thefirstisderivedfromthelow-levelI/Oclasscalled
basic_streambuf.Thisclasssupplies
the basic, low-level input and output operations, and provides the underlying support
fortheentireC++I/Osystem.Theclasses
basic_filebufandbasic_stringbufarederived
from
basic_streambuf. Unless you are doing advanced I/O programming, you will not
need to usebasic_streambufor its subclasses directly.
The class hierarchy that you will most commonly be working with is derived from
basic_ios. This is a high-level I/O class that provides formatting, error-checking, and

status information related to stream I/O.
basic_iosis used as a base for several derivedclasses, includingbasic_istream,basic_ostream, andbasic_iostream. These classes are
usedtocreatestreamscapableofinput,output,andinput/output,respectively.Specifically,

from
basic_istreamarederivedtheclasses
basic_ifstreamandbasic_istringstream,from
basic_ostreamarederived
basic_ofstreamandbasic_ostringstream,andfrom
basic_iostreamarederived
basic_fstreamandbasic_stringstream.Abaseclass
forbasic_iosisios_base. Thus, any class derived from
basic_ioshas access to themembers ofios_base.The I/O classes are parameterized for the type of characters that they act upon
andforthetraitsassociatedwiththosecharacters.Forexample,hereisthetemplate

specification forbasic_ios:template <class CharType, class Attr = char_traits<CharType> >class basic_ios: public ios_baseHere,
CharType
specifiesthetypeofcharacter(suchas
charorwchar_t)and
Attrspecifiesatypethatdescribesitsattributes.Thegenerictype
char_traitsisautilityclassthatdefines
theattributesassociatedwithacharacter.
AsexplainedinChapter20,theI/Olibrarycreatestwospecializationsofthetemplate
classhierarchiesjustdescribed:onefor8-bitcharactersandoneforwidecharacters.Here

isa complete list of the mapping of template class names to their character and wide-

characterversions.
Template

ClassCharacter-Based
ClassWide-Character-Based

Classbasic_iosioswiosbasic_istreamistream
wistream
basic_ostreamostream
wostream
basic_iostreamiostream
wiostream
THESTANDARDC++
CLASSLIBRARY
Chapter32:TheStandardC++I/OClasses
789Template
ClassCharacter-Based
ClassWide-Character-Based

Classbasic_ifstreamifstream
wifstream
basic_ofstreamofstream
wofstream
basic_fstreamfstream
wfstream
basic_istringstreamistringstream
wistringstream
basic_ostringstreamostringstream
wostringstream
basic_stringstreamstringstream
wstringstream
basic_streambufstreambuf
wstreambuf
basic_filebuffilebuf
wfilebufbasic_stringbufstringbuf
wstringbufSince the vast majority of programmers will be using character-based I/O, those are
the names used by this chapter. Thus, when referring to the I/O classes, we will simply

usetheircharacter-basednamesratherthantheirinternal,templatenames.Forinstance,

thischapterwillusethename
iosratherthan
basic_ios,istreamratherthan
basic_istream,andfstreamratherthan
basic_fstream.Remember,parallelclassesexistforwide-
character streams and they work in the same way as those described here.
The I/O HeadersThe Standard C++ I/O system relies upon several headers. They are shown here.
HeaderFor<fstream>File I/O
<iomanip>Parameterized I/O manipulators

<ios>Basic I/O support

<iosfwd>Forward declarations used by the I/O system

<iostream>General I/O

<istream>Basic input support

<ostream>Basic output support
790C++:TheCompleteReference
HeaderFor<sstream>String-based streams
<streambuf>Low-level I/O support
Several of these headers are used internally by the I/O system. In general, your
program will only include
<iostream>,<fstream>,<sstream>, or<iomanip>.The Format Flags and I/O Manipulators
Each stream has associated with it a set of format flags that control the way information
isformatted.The
ios_baseclassdeclaresabitmaskenumerationcalled
fmtflagsinwhich the following values are defined.
adjustfieldbasefield
boolalphadec
fixedfloatfieldhexinternalleftoctrightscientificshowbaseshowpointshowpos
skipwsunitbufuppercase
These values are used to set or clear the format flags, using functions such as
setf( )andunsetf( ). Adetailed description of these flags is found in Chapter 20.
In addition to setting or clearing the format flags directly, you may alter the format
parameters of a stream through the use of special functions called manipulators, which

can be included in an I/O expression. The standard manipulators are shown in the

following table:ManipulatorPurposeInput/OutputboolalphaTurns on
boolaphaflag.Input/OutputdecTurns on
decflag.Input/OutputendlOutput a newline character
and flush the stream.
OutputendsOutput a null.OutputfixedTurns on
fixedflag.OutputflushFlush a stream.
OutputhexTurns on
hexflag.Input/OutputChapter32:TheStandardC++I/OClasses
791THESTANDARDC++
CLASSLIBRARY
ManipulatorPurposeInput/OutputinternalTurns on
internalflag.OutputleftTurns on
leftflag.OutputnoboolalphaTurns off
boolalphaflag.Input/Output
noshowbaseTurns off
showbaseflag.OutputnoshowpointTurns off
showpointflag.Output
noshowposTurns off
showposflag.OutputnoskipwsTurns off
skipwsflag.InputnounitbufTurns off
unitbufflag.Outputnouppercase
Turns off
uppercaseflag.Output
octTurns on
octflag.Input/Outputresetiosflags (fmtflags
f)Turn off the flags
specified inf.Input/OutputrightTurns on
rightflag.OutputscientificTurns on
scientificflag.Outputsetbase(intbase)Set the number base tobase.Input/Outputsetfill(intch)Set the fill character toch.Output
setiosflags(fmtflagsf)Turn on the flags specified in
f.Input/outputsetprecision (int
p)Set the number of digits of
precision.
Outputsetw(intw)Set the field width tow.OutputshowbaseTurns on
showbaseflag.OutputshowpointTurns on
showpointflag.Output
showposTurns on
showposflag.OutputskipwsTurns on
skipwsflag.InputunitbufTurns on
unitbufflag.Outputuppercase
Turns on
uppercaseflag.OutputwsSkip leading white space.Input
To use a manipulator that takes a parameter, you must include
<iomanip>.792C++:TheCompleteReference
Several Data Types
In addition to thefmtflagstype just described, the Standard C++ I/O system defines
several other types.The streamsize and streamoff Types
An object of typestreamsizeis capable of holding the largest number of bytes that will
be transferred in any one I/O operation. It is typically some form of integer. An object
of typestreamoff
is capable of holding a value that indicates an offset position within a
stream. It is typically some form of integer. These types are defined in the header
<ios>,which is automatically included by the I/O system.The streampos and wstreampos Types
An object of typestreamposis capable of holding a value that represents a position
withina
charstream.The
wstreampostypeiscapableofholdingavaluethatrepresents
apositionwitha
wchar_tstream.Thesearedefinedin
<iosfwd>,whichisautomatically
included by the I/O system.The pos_type and off_type Types
The typespos_typeandoff_type
create objects (typically integers) that are capable of
holding a value that represents the position and an offset, respectively, within a stream.

Thesetypesaredefinedby
ios(andotherclasses)andareessentiallythesameas
streamoff
andstreampos(or their wide-character equivalents).The openmode Type
The typeopenmodeis defined byios_baseand describes how a file will be opened.It will be one or more of these values.
appAppend to end of file.
ateSeek to end of file on creation.

binaryOpen file for binary operations.

inOpen file for input.outOpen file for output.

truncErase previously existing file.
You can combine two or more of these values by ORing them together.
THESTANDARDC++
CLASSLIBRARY
Chapter32:TheStandardC++I/OClasses
793The iostate Type
The current status of an I/O stream is described by an object of type
iostate, which isan enumeration defined byios_basethat includes these members.NameMeaning
goodbitNo errors occurred.
eofbitEnd-of-file is encountered.

failbitAnonfatal I/O error has occurred.

badbitAfatal I/O error has occurred.
The seekdir Type
Theseekdirtype describes how a random-access file operation will take place. It isdefined withinios_base. Its valid values are shown here.
begBeginning-of-file

curCurrent location

endEnd-of-file
The failure Class
Inios_baseis defined the exception typefailure. It serves as a base class for the typesof exceptions that can be thrown by the I/O system. It inherits
exception(the standard
exception class). Thefailureclass has the following constructor:
explicit failure(const string &str);Here,
strisamessagethatdescribestheerror.Thismessagecanbeobtainedfroma
failureobject by calling itswhat( )function, shown here:
virtual const char *what( ) const throw( );Overload << and >> OperatorsThe following classes overload the<<and/or>>operators relative to all of the built-in
data types.794C++:TheCompleteReference
basic_istreambasic_ostream
basic_iostreamAny classes derived from these classes inherit these operators.
The General-Purpose I/O FunctionsThe remainder of this chapter describes the general-purpose I/O functions supplied by

StandardC++.Asexplained,theStandardC++I/Osystemisbuiltuponanintricate

hierarchyoftemplateclasses.Manyofthemembersofthelow-levelclassesarenot

used for application programming. Thus, they are not described here.
bad#include <iostream>bool bad() const;Thebad( )function is a member ofios.Thebad( )function returns
trueif a fatal I/O error has occurred in the associated
stream; otherwise,
falseis returned.
Arelated function is
good( ).clear#include <iostream>
void clear(iostateflags= goodbit);Theclear( )function is a member ofios.Theclear()
functionclearsthestatusflagsassociatedwithastream.If
flagsisgoodbit(as it is by default), then all error flags are cleared (reset to zero). Otherwise, the status
flags will be set to whatever value is specified inflags.Arelated function is
rdstate( ).eof#include <iostream>bool eof() const;Chapter32:TheStandardC++I/OClasses
795THESTANDARDC++
CLASSLIBRARY
Theeof( )function is a member ofios.Theeof( )function returns
truewhen the end of the associated input file has beenencountered; otherwise it returns
false.Related functions are
bad( ),fail( ),good( ),rdstate( ), andclear( ).exceptions#include <iostream>iostate exceptions() const;
void exceptions(iostateflags);Theexceptions( )function is a member ofios.Thefirstformreturnsan
iostateobjectthatindicateswhichflagscauseanexception.
Thesecondformsetsthesevalues.
Arelated function is
rdstate( ).fail#include <iostream>
bool fail() const;Thefail( )function is a member ofios.Thefail()
functionreturns
trueifanI/Oerrorhasoccurredintheassociatedstream.
Otherwise,itreturns
false.Related functions are
good( ),eof( ),bad( ),clear( ), andrdstate( ).fill#include <iostream>
char fill() const;
char fill(charch);Thefill( )function is a member ofios.By default, when a field needs to be filled, it is filled with spaces. However, you can
specify the fill character using thefill( )function and specifying the new fill characterinch. The old fill character is returned.
To obtain the current fill character, use the first form of
fill( ), which returns the
current fill character.
796C++:TheCompleteReference
THESTANDARDC++
CLASSLIBRARY
Chapter32:TheStandardC++I/OClasses
797Related functions are
precision( )andwidth( ).flags#include <iostream>fmtflags flags() const;
fmtflags flags(fmtflagsf);Theflags( )function is a member ofios(inherited from
ios_base).The first form offlags( )simply returns the current format flags settings of the
associated stream.
Thesecondformof
flags()
setsallformatflagsassociatedwithastreamasspecified
byf.Whenyouusethisversion,thebitpatternfoundin
fiscopiedintotheformatflags
associatedwiththestream.Thisversionalsoreturnstheprevioussettings.
Related functions are
unsetf( )andsetf( ).flush#include <iostream>
ostream &flush();Theflush( )function is a member ofostream.Theflush()
functioncausesthebufferconnectedtotheassociatedoutput
stream to be physically written to the device. The function returns a reference to
its associated stream.
Related functions are
put( )andwrite( ).fstream, ifstream, and ofstream
#include <fstream>fstream();
explicit fstream(const char *filename,ios::openmodemode =ios::in | ios::out);ifstream();
explicitifstream(constchar*
filename,ios::openmode
mode=ios::in);ofstream();
explicit ofstream(const char *filename,ios::openmode mode=ios::out);Thefstream( ),ifstream( ), andofstream( )functions are the constructors of the
fstream,ifstream, andofstreamclasses, respectively.
The versions offstream( ),ifstream( ), andofstream( )that take no parameterscreate a stream that is not associated with any file. This stream can then be linked
to a file usingopen( ).The versions offstream( ),ifstream( ), andofstream( )that take a filename for theirfirst parameters are the most commonly used in application programs. Although it is

entirely proper to open a file using the
open( )function, most of the time you will notdo so because theseifstream,ofstream, andfstreamconstructors automatically open
thefilewhenthestreamiscreated.Theconstructorshavethesameparametersand

defaultsasthe
open()
function.(See
openfordetails.)Forinstance,thisisthemost
common way you will see a file opened:ifstream mystream("myfile");Ifforsomereasonthefilecannotbeopened,thevalueoftheassociatedstream
variable will befalse. Therefore, whether you use a constructor to open the file or an
explicit call toopen( ), you will want to confirm that the file has actually been openedby testing the value of the stream.
Related functions are
close( )andopen( ).gcount#include <iostream>streamsize gcount() const;Thegcount( )function is a member ofistream.Thegcount( )function returns the number of characters read by the last
input operation.Related functions are
get( ),getline( ), andread( ).get#include <iostream>
int get();
istream &get(char &ch):istream &get(char *buf, streamsizenum);istream &get(char *buf, streamsizenum, chardelim);istream &get(streambuf &buf);istream &get(streambuf &buf,chardelim
);798C++:TheCompleteReference
Theget( )function is a member ofistream.In general,get( )reads characters from an input stream. The parameterless form
ofget( )reads a single character from the associated stream and returns that value.
get(char &ch)reads a character from the associated stream and puts that value
inch. It returns a reference to the stream.
get(char *buf, streamsizenum)reads characters into the array pointed to by
bufuntil eithernum1 characters have been read, a newline is found, or the end of the file
has been encountered. The array pointed to by
bufwill be null terminated byget( ). Ifthe newline character is encountered in the input stream, it is
notextracted. Instead, itremains in the stream until the next input operation. This function returns a reference
to the stream.
get(char *buf, streamsizenum, chardelim)reads characters into the array pointed
to bybufuntil eithernum1 characters have been read, the character specified by
delimhas been found, or the end of the file has been encountered. The array pointed to by
bufwill be null terminated byget( ). If the delimiter character is encountered in the input
stream,itis
notextracted.Instead,itremainsinthestreamuntilthenextinputoperation.
This function returns a reference to the stream.
get(streambuf &buf)reads characters from the input stream into the
streambufobject. Characters are read until a newline is found or the end of the file is encountered.

It returns a reference to the stream. If the newline character is encountered in the input

stream, it is not extracted.
get(streambuf &buf, chardelim)reads characters from the input stream into the
streambufobject. Characters are read until the character specified by
delimis found ortheendofthefileisencountered.Itreturnsareferencetothestream.Ifthedelimiter

character is encountered in the input stream, it is not extracted.
Related functions are
put( ),read( ), andgetline( ).getline#include <iostream>istream &getline(char *buf, streamsizenum);istream &getline(char *buf, streamsizenum, chardelim);Thegetline( )function is a member ofistream.getline(char*
buf,streamsize
num)readscharactersintothearraypointedtoby
bufuntileither
num−1charactershavebeenread,anewlinecharacterhasbeenfound,orthe
endofthefilehasbeenencountered.Thearraypointedtoby
bufwillbenullterminated
bygetline()
.Ifthenewlinecharacterisencounteredintheinputstream,itisextracted
butisnotputinto
buf.Thisfunctionreturnsareferencetothestream.
getline(char *buf, streamsizenum, chardelim)reads characters into the array
pointed to bybufuntil eithernum−1 characters have been read, the character specified
bydelimhas been found, or the end of the file has been encountered. The array pointed
Chapter32:TheStandardC++I/OClasses
799THESTANDARDC++
CLASSLIBRARY
to bybufwill be null terminated bygetline( ). If the delimiter character is encountered
intheinputstream,itisextractedbutisnotputinto
buf.Thisfunctionreturnsareference
to the stream.
Related functions are
get( )andread( ).good#include <iostream>bool good() const;Thegood( )function is a member ofios.Thegood( )function returns
trueif no I/O errors have occurred in the associated
stream; otherwise, it returns
false.Related functions are
bad( ),fail( ),eof( ),clear( ), andrdstate( ).ignore
#include <iostream>
istream &ignore(streamsizenum= 1, intdelim= EOF);Theignore( )function is a member ofistream.You can use the
ignore( )member function to read and discard characters from the
inputstream.Itreadsanddiscardscharactersuntileither
numcharactershavebeen
ignored (1 by default) or until the character specified by
delimis encountered (
EOFbydefault). If the delimiting character is encountered, it is removed from the input stream.
The function returns a reference to the stream.
Related functions are
get( )andgetline( ).open#include <fstream>void fstream::open(const char *filename,ios::openmodemode= ios::in | ios::out);void ifstream::open(const char *filename,ios::openmodemode= ios::in);void ofstream::open(const char *filename,ios::openmodemode =ios:: out | ios::trunc);800C++:TheCompleteReference
Theopen( )function is a member offstream,ifstream, andofstream.Afile is associated with a stream by using the
open( )function. Here,
filenameis thename of the file, which may include a path specifier. The value of
modedetermines howthe file is opened. It must be one (or more) of these values:
ios::appios::ate
ios::binary
ios::in
ios::out
ios::truncYou can combine two or more of these values by ORing them together.
Includingios::appcauses all output to that file to be appended to the end. Thisvalue can only be used with files capable of output. Includingios::atecauses a seek totheendofthefiletooccurwhenthefileisopened.Although
ios::atecausesaseek
to the end-of-file, I/O operations can still occur anywhere within the file.
Theios::binaryvalue causes the file to be opened for binary I/O operations. Bydefault, files are opened in text mode.
Theios::invaluespecifiesthatthefileiscapableofinput.The
ios::outvaluespecifies
that the file is capable of output. However, creating an
ifstreamstream implies input,
andcreatingan
ofstreamstreamimpliesoutput,andopeningafileusing
fstreamimplies both input and output.Theios::truncvalue causes the contents of a preexisting file by the same name to be
destroyed, and the file is truncated to zero length.
In all cases, ifopen( )fails, the stream will be
false. Therefore, before using a file,
you should test to make sure that the open operation succeeded.
Related functions are
close( ),fstream( ),ifstream( ), andofstream( ).peek#include <iostream>int peek();Thepeek( )function is a member ofistream.Thepeek( )function returns the next character in the stream or
EOFif the end ofthefileisencountered.Itdoesnot,underanycircumstances,removethecharacter
from the stream.
Arelated function is
get( ).Chapter32:TheStandardC++I/OClasses
801THESTANDARDC++
CLASSLIBRARY
precision
#include <iostream>streamsize precision() const;
streamsize precision(streamsizep);Theprecision( )function is a member ofios(inherited from
ios_base).Bydefault,sixdigitsofprecisionaredisplayedwhenfloating-pointvaluesareoutput.
However, using the second form of
precision( ), you can set this number to the valuespecified inp. The original value is returned.
The first version ofprecision( )returns the current value.
Related functions are
width( )andfill( ).put#include <iostream>
ostream &put(charch);Theput( )function is a member ofostream.Theput( )function writeschto the associated output stream. It returns a reference
to the stream.
Related functions are
write( )andget( ).putback#include <iostream>
istream &putback(charch);Theputback( )function is a member ofistream.Theputback( )function returns
chto the associated input stream.
Arelated function is
peek( ).rdstate
#include <iostream>
iostate rdstate() const;802C++:TheCompleteReference
Therdstate( )function is a member ofios.Therdstate( )function returns the status of the associated stream. The C++ I/O
system maintains status information about the outcome of each I/O operation relative
to each active stream. The current state of a stream is held in an object of type
iostate,in which the following flags are defined:
NameMeaning
goodbitNo errors occurred.
eofbitEnd-of-file is encountered.

failbitAnonfatal I/O error has occurred.

badbitAfatal I/O error has occurred.
These flags are enumerated inside
ios(viaios_base).rdstate( )returns
goodbitwhen no error has occurred; otherwise, an error bit has
been set.Related functions are
eof( ),good( ),bad( ),clear( ),setstate( ), andfail( ).read
#include <iostream>istream &read(char *buf, streamsizenum);Theread( )function is a member ofistream.Theread()
functionreads
numbytesfromtheassociatedinputstreamandputs
theminthebufferpointedtoby
buf.Iftheendofthefileisreachedbefore
numcharactershavebeenread,
read()
simplystops,sets
failbit,andthebuffercontains
asmanycharactersaswereavailable.(See
gcount()
.)read()
returnsareferenceto
the stream.
Related functions are
gcount( ),readsome( ),get( ),getline( ), andwrite( ).readsome
#include <iostream>
streamsize readsome(char *buf, streamsizenum);Thereadsome( )function is a member ofistream.Thereadsome( )function reads
numbytes from the associated input stream
and puts them in the buffer pointed to by
buf. If the stream contains less than
numChapter32:TheStandardC++I/OClasses
803THESTANDARDC++
CLASSLIBRARY
characters, that number of characters are read.
readsome( )returns the number of
characters read. The difference between
read( )andreadsome( )is thatreadsome( )does not set thefailbitif there are less than
numcharacters available.Related functions are
gcount( ),read( ), andwrite( ).seekg and seekp#include <iostream>istream &seekg(off_typeoffset, ios::seekdirorigin)istream &seekg(pos_typeposition);ostream &seekp(off_typeoffset, ios::seekdirorigin);ostream &seekp(pos_typeposition);Theseekg( )function is a member ofistream, and theseekp( )function is a memberofostream.In C++'s I/O system, you perform random access using theseekg( )andseekp( )functions. To this end, the C++ I/O system manages two pointers associated with a file.
Oneisthe
getpointer
,whichspecifieswhereinthefilethenextinputoperationwilloccur.
The other is theput pointer, which specifies where in the file the next output operation
willoccur.Eachtimeaninputoranoutputoperationtakesplace,theappropriate

pointeris
automaticallysequentiallyadvanced.However,usingthe
seekg( ) andseekp( )functions, it is possible to access the file in a nonsequential fashion.The two-parameter version ofseekg( )moves the get pointeroffsetnumber of bytesfrom the location specified by
origin. The two-parameter version ofseekp( )moves theputpointer
offsetnumberofbytesfromthelocationspecifiedby
origin.The
offsetparameterisoftype
off_type
,whichiscapableofcontainingthelargestvalidvaluethat
offsetcan have.Theoriginparameteris of type
seekdirand is an enumeration that has these values:ios::begSeek from beginning
ios::curSeek from current position

ios::endSeek from end
Thesingle-parameterversionsof
seekg()
andseekp()
movethefilepointerstothe
locationspecifiedby
position.Thisvaluemusthavebeenpreviouslyobtainedusingacall
toeither
tellg()
ortellp()
,respectively.
pos_typeisatypethatiscapableofcontaining
thelargestvalidvaluethat
positioncanhave.Thesefunctionsreturnareferencetothe
associatedstream.
Related functions are
tellg( )andtellp( ).804C++:TheCompleteReference
setf#include <iostream>fmtflags setf(fmtflagsflags);fmtflags setf(fmtflagsflags1, fmtflagsflags2);Thesetf( )function is a member ofios(inherited from
ios_base).Thesetf()
functionsetstheformatflagsassociatedwithastream.Seethediscussion
offormatflagsearlierinthissection.
The first version ofsetf( )turns on the format flags specified byflags. (All otherflags are unaffected.) For example, to turn on the
showposflag forcout, you can usethis statement:cout.setf(ios::showpos);When you want to set more than one flag, you can OR together the values of the flags
you want set.Itisimportanttounderstandthatacallto
setf()
isdonerelativetoaspecificstream.
Thereisnoconceptofcalling
setf()
byitself.Putdifferently,thereisnoconceptinC++
ofglobalformatstatus.Eachstreammaintainsitsownformatstatusinformation

individually.
Thesecondversionof
setf()
affectsonlytheflagsthataresetin
flags2.The
corresponding flags are first reset and then set according to the flags specified by
flags1.Evenif
flags1containsothersetflags,onlythosespecifiedby
flags2willbeaffected.
Both versions ofsetf( )return the previous settings of the format flags associated
with the stream.
Related functions are
unsetf( )andflags( ).setstate#include <iostream>void setstate(iostateflags) const;Thesetstate( )function is a member ofios.Thesetstate( )function sets the status of the associated stream as described by
flags.Seerdstate( )for further details.Related functions are
clear( )andrdstate( ).Chapter32:TheStandardC++I/OClasses
805THESTANDARDC++
CLASSLIBRARY
806C++:TheCompleteReference
str#include <sstream>string str() const;
void str(string &s)Thestr( )function is a member ofstringstream,istringstream, andostringstream.The first form of thestr( )function returns a
stringobject that contains the current
contents of the string-based stream.
The second form frees the string currently contained in the string stream and
substitutes the string referred to by
s.Related functions are
get( )andput( ).stringstream, istringstream, ostringstream
#include <sstream>
explicit stringstream(ios::openmodemode= ios::in | ios::out);explicit stringstream(const string &str,ios::openmodemode= ios::in | ios::out);explicit istringstream(ios::openmodemode=ios::in);explicitistringstream(conststring
str,ios::openmode
mode=ios::in);explicitostringstream(ios::openmode
mode=ios::out);explicit ostringstream(const stringstr, ios::openmodemode=ios::out);Thestringstream()
,istringstream()
,and
ostringstream()
functionsarethe
constructors of the
stringstream,istringstream, andostringstreamclasses, respectively.
These construct streams that are tied to strings.
The versions ofstringstream( ),istringstream( ), andostringstream( )that specifyonly theopenmodeparameter create empty streams. The versions that take a
stringparameter initialize the string stream.
Here is an example that demonstrates the use of a string stream.
// Demonstrate string streams.
#include <iostream>
#include <sstream>
using namespace std;int main(){stringstream s("This is initial string.");// get stringstring str = s.str();
cout << str << endl;// output to string streams << "Numbers: " << 10 << " " << 123.2;int i;double d;
s >> str >> i >> d;
cout << str << " " << i << " " << d;return 0;}The output produced by this program is shown here:
This is initial string.Numbers: 10 123.2Arelated function is
str( ).sync_with_stdio#include <iostream>
bool sync_with_stdio(boolsync= true );Thesync_with_stdio( )function is a member ofios(inherited from
ios_base).Callingsync_with_stdio( )allows the standard C-like I/O system to be safely used
concurrently with the C++ class-based I/O system. To turn off
stdiosynchronization,
passfalsetosync_with_stdio()
.Theprevioussettingisreturned:
trueforsynchronized;
falsefor no synchronization. By default, the standard streams are synchronized. This
function is reliable only if called prior to any other I/O operations.
Chapter32:TheStandardC++I/OClasses
807THESTANDARDC++
CLASSLIBRARY
tellg and tellp#include <iostream>pos_type tellg();
pos_type tellp():Thetellg( )function is a member ofistream, andtellp( )is a member ofostream.The C++ I/O system manages two pointers associated with a file. One is thegetpointer, which specifies where in the file the next input operation will occur. The other
is theput pointer, which specifies where in the file the next output operation will occur.
Eachtimeaninputoranoutputoperationtakesplace,theappropriatepointeris
automatically sequentially advanced. You can determine the current position of the get

pointer usingtellg( )and of the put pointer usingtellp( ).pos_typeis a type that is capable of holding the largest value that either function
can return.
Thevaluesreturnedby
tellg()
andtellp()
canbeusedasparametersto
seekg()
andseekp( ), respectively.
Related functions are
seekg( )andseekp( ).unsetf#include <iostream>void unsetf(fmtflagsflags);Theunsetf( )function is a member ofios(inherited from
ios_base).Theunsetf( )function is used to clear one or more format flags.
The flags specified byflagsare cleared. (All other flags are unaffected.)
Related functions are
setf( )andflags( ).width#include <iostream>
streamsize width() const;
streamsize width(streamsizew);Thewidth( )function is a member ofios(inherited from
ios_base).808C++:TheCompleteReference
Toobtainthecurrentfieldwidth,usethefirstformof
width()
.Itreturnsthecurrent
fieldwidth.Tosetthefieldwidth,usethesecondform.Here,
wbecomesthefieldwidth,
andthepreviousfieldwidthisreturned.
Related functions are
precision( )andfill( ).write#include <iostream>ostream &write(const char *buf, streamsizenum);Thewrite( )function is a member ofostream.Thewrite()
functionwrites
numbytestotheassociatedoutputstreamfromthebuffer
pointedtoby
buf.Itreturnsareferencetothestream.
Related functions are
read( )andput( ).Chapter32:TheStandardC++I/OClasses
809THESTANDARDC++
CLASSLIBRARY
This page intentionally left blank Chapter33
The STL ContainerClasses811Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This chapter describes the classes that implement the containers defined by thestandard template library (STL). Containers are the part of the STL that provide
storage for other objects. In addition to supplying the memory necessary to storeobjects,theydefinethemechanismsbywhichtheobjectsinthecontainermaybeaccessed.

Thus, containers are high-level storage devices.For an overview and tutorial to the STL, refer to Chapter 24.
In the container descriptions, the following conventions will be observed. Whenreferringtothevariousiteratortypesgenerically,thisbookwillusethetermslistedhere.
Term
Represents
BiIterBidirectional iterator
ForIterForward iterator
InIterInput iteratorOutIterOutput iteratorRandIterRandom access iteratorWhen a unary predicate function is required, it will be notated using the type
UnPred. When a binary predicate is required, the type
BinPredwill be used. In abinary predicate, the arguments are always in the order of
first,secondrelative to the
function that calls the predicate. For both unary and binary predicates, the arguments

will contain values of the type of objects being stored by the container.
Comparison functions will be notated using the typeComp.One other point: In the descriptions that follow, when an iterator is said to point
to the end of a container, this means that the iterator points just beyond the last object

in the container.
The Container ClassesThe containers defined by the STLare shown here.
ContainerDescriptionRequired Header
bitsetAset of bits.
<bitset>dequeAdouble-ended queue.
<deque>listAlinear list.
<list>812C++:TheCompleteReference
ContainerDescriptionRequired Header
mapStores key/value pairs in
which each key is associated
with only one value.<map>multimapStores key/value pairs in which
one key may be associated with
two or more values.
<map>multisetAset in which each element is
not necessarily unique.<set>priority_queueApriority queue.
<queue>queueAqueue.
<queue>setAset in which each element

is unique.<set>stackAstack.
<stack>vectorAdynamic array.
<vector>Each of the containers is summarized in the following sections. Since the containersare implemented using template classes, various placeholder data types are used. In

the descriptions, the generic typeTrepresents the type of data stored by a container.
Sincethenamesoftheplaceholdertypesinatemplateclassarearbitrary,thecontainer
classes declare
typedefed versions of these types. This makes the type names concrete.
Here are the
typedefnames used by the container classes.size_typeSome integral type roughly equivalent to
size_t.referenceAreference to an element.
const_referenceAconstreference to an element.
difference_type
Can represent the difference between two addresses.
iteratorAn iterator.
const_iteratorAconstiterator.
reverse_iteratorAreverse iterator.
const_reverse_iteratorAconstreverse iterator.
Chapter33:TheSTLContainerClasses
813THESTANDARDC++
CLASSLIBRARY
814C++:TheCompleteReference
value_typeThe type of a value stored in a container. (Often the
same as the generic type T.)
allocator_typeThe type of the allocator.
key_typeThe type of a key.
key_compareThe type of a function that compares two keys.
mapped_typeThe type of value stored in a map. (Same as the

generic type T.)
value_compareThe type of a function that compares two values.
pointerThe type of a pointer.
const_pointerThe type of aconstpointer.
container_typeThe type of a container.
bitsetThebitsetclass supports operations on a set of bits. Its template specification istemplate <size_tN> class bitset;Here,
Nspecifies the length of the bitset, in bits. It has the following constructors:
bitset( );bitset(unsigned longbits);explicit bitset(const string &s, size_ti= 0, size_tnum= npos);The first form constructs an empty bitset. The second form constructs a bitset that has
its bits set according to those specified in
bits. The third form constructs a bitset using
thestring
s,beginningat
i.Thestringmustcontainonly1'sand0's.Only
numors.size()-
ivaluesareused,whicheverisless.Theconstant
nposisavaluethatis
sufficiently large to describe the maximum length of
s.The output operators<<and>>are defined forbitset.bitsetcontains the following member functions.Chapter33:TheSTLContainerClasses
815THESTANDARDC++
CLASSLIBRARY
MemberDescriptionbool any( ) const;Returns true if any bit in the invoking
bitset is 1; otherwise returns false.
size_t count( ) const;Returns the number of 1 bits.bitset<N> &flip( );Reverses the state of all bits in theinvoking bitset and returns
*this.bitset<N> &flip(size_ti);Reverses the bit in positioniin theinvoking bitset and returns
*this.bool none( ) const;Returns true if no bits are set in the
invoking bitset.bool operator !=(const bitset<N> &op2)const;Returns true if the invoking bitset
differs from the one specified by

right-hand operator,
op2.bool operator ==(const bitset<N> &op2)const;Returns true if the invoking bitset is the

same as the one specified by right-hand
operator,
op2.bitset<N>&operator &=(const bitset<N> &op2);ANDs each bit in the invoking bitset
with the corresponding bit in
op2andleaves the result in the invoking bitset.

It returns
*this.bitset<N>&operator ^=(const bitset<N> &op2);XORs each bit in the invoking bitset
with the corresponding bit in
op2andleaves the result in the invoking bitset.

It returns
*this.bitset<N>&operator |=(const bitset<N> &op2);ORs each bit in the invoking bitset
with the corresponding bit in
op2andleaves the result in the invoking bitset.

It returns
*this.bitset<N> &operator ~( ) const;Reverses the state of all bits in theinvoking bitset and returns the result.
bitset<N>  &operator <<=(size_tnum);Left-shifts each bit in the invoking
bitsetnumpositions and leavesthe result in the invoking bitset.

It returns
*this.bitset<N> &operator >>=(size_tnum);Right-shifts each bit in the invoking
bitsetnumpositions and leavesthe result in the invoking bitset.

It returns
*this.816C++:TheCompleteReference
MemberDescriptionreference operator [ ](size_t
i);Returns a reference to bit
iin theinvoking bitset.bitset<N> &reset( );Clears all bits in the invoking bitset
and returns
*this.bitset<N> &reset(size_t
i);Clears the bit in positioniin theinvoking bitset and returns
*this.bitset<N> &set( );Sets all bits in the invoking bitset andreturns
*this.bitset<N> &set(size_ti, intval= 1);Sets the bit in position
ito the valuespecified byvalin the invoking bitsetand returns
*this. Any nonzero value
forvalis assumed to be 1.size_t size( ) const;Returns the number of bits that thebitset can hold.bool test(size_ti) const;Returns the state of the bit in positioni.string to_string( ) const;Returns a string that contains arepresentation of the bit pattern
in the invoking bitset.unsigned long to_ulong( ) const;Converts the invoking bitset into
an unsigned long integer.
dequeThedequeclass supports a double-ended queue. Its template specification istemplate <class T, class Allocator = allocator<T> > class dequeHere,
Tis the type of data stored in the
deque. It has the following constructors:
explicit deque(const Allocator &a= Allocator( ) );explicit deque(size_typenum, const T &val= T ( ),const Allocator &a= Allocator( ));deque(const deque<T, Allocator> &ob);THESTANDARDC++
CLASSLIBRARY
Chapter33:TheSTLContainerClasses
817template <class InIter> deque(InIterstart, InIterend,const Allocator &a= Allocator( ));The first form constructs an empty deque. The second form constructs a deque that has
numelements with the valueval. The third form constructs a deque that contains the
same elements asob. The fourth form constructs a deque that contains the elements in
the range specified bystartandend.The following comparison operators are defined for
deque:==, <, <=, !=, >, >=dequecontains the following member functions.MemberDescriptiontemplate <class InIter>void assign(InIterstart, InIterend);Assigns the deque the sequencedefined bystartandend.void assign(size_typenum, const T &val);Assigns the deque
numelements ofvalueval.reference at(size_type
i);const_reference at(size_type
i) const;Returns a reference to the element

specified byi.reference back( );

const_reference back( ) const;
Returns a reference to the last element

in the deque.iterator begin( );
const_iterator begin( ) const;Returns an iterator to the first element
in the deque.void clear( );Removes all elements from the deque.
bool empty( ) const;Returns true if the invoking deque is

empty and false otherwise.const_iterator end( ) const;
iterator end( );Returns an iterator to the end of
the deque.iterator erase(iteratori);Removes the element pointed to byi.Returns an iterator to the element after
the one removed.
iterator erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend. Returns an iterator to theelement after the last element removed.
reference front( );

const_reference front( ) const;
Returns a reference to the first element

in the deque.MemberDescriptionallocator_type get_allocator( ) const;Returns deque's allocator.
iterator insert(iteratori,const T &val);Insertsvalimmediately before the
element specified byi.An iteratorto the element is returned.
void insert(iteratori, size_typenum,const T &val);Insertsnumcopies ofvalimmediatelybefore the element specified by
i.template <class InIter>void insert(iteratori,InIterstart, InIterend);Inserts the sequence defined bystartandendimmediately before the
element specified byi.size_type max_size( ) const;Returns the maximum number of
elements that the deque can hold.reference operator[ ](size_type
i);const_reference
operator[ ](size_typei) const;Returns a reference to the
ith element.void pop_back( );Removes the last element in the deque.

void pop_front( );Removes the first element in the deque.

void push_back(const T &val);Adds an element with the valuespecified byvalto the end of the deque.void push_front(const T &
val);Adds an element with the value
specified byvalto the front of the
deque.reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the deque.reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the start

of the deque.void resize(size_type
num, Tval= T ( ));Changesthesizeofthedequetothat
specifiedby
num.Ifthedequemustbe
lengthened,thenelementswiththevalue

specifiedby
valareaddedtotheend.
size_type size( ) const;Returns the number of elements
currently in the deque.
void swap(deque<T, Allocator> &
ob);Exchanges the elements stored in the
invoking deque with those inob.818C++:TheCompleteReference
Chapter33:TheSTLContainerClasses
819THESTANDARDC++
CLASSLIBRARY
listThelistclass supports a list. Its template specification istemplate <class T, class Allocator = allocator<T> > class listHere,
Tis the type of data stored in the list. It has the following constructors:
explicit list(const Allocator &a= Allocator( ) );explicit list(size_typenum, const T &val= T ( ),const Allocator &a= Allocator( ));list(const list<T, Allocator> &ob);template <class InIter>list(InIterstart, InIterend,const Allocator &a= Allocator( ));The first form constructs an empty list. The second form constructs a list that has
numelementswiththevalue
val.Thethirdformconstructsalistthatcontainsthesameelements
asob.Thefourthformconstructsalistthatcontainstheelementsintherangespecifiedby
startandend.The following comparison operators are defined for
list:==, <, <=, !=, >, >=
listcontains the following member functions.MemberDescriptiontemplate <class InIter>void assign(InIterstart, InIterend);Assigns the list the sequence definedbystartandend.void assign(size_typenum, const T &val);Assigns the list
numelements ofvalueval.reference back( );

const_reference back( ) const;
Returns a reference to the last

element in the list.iterator begin( );
const_iterator begin( ) const;Returns an iterator to the first
element in the list.820C++:TheCompleteReference
MemberDescriptionvoid clear( );Removes all elements from the list.
bool empty( ) const;Returns true if the invoking list is
empty and false otherwise.iterator end( );const_iterator end( ) const;Returns an iterator to the end of
the list.iterator erase(iteratori);Removes the element pointed to
byi. Returns an iterator to theelement after the one removed.
iterator erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend. Returns an iterator tothe element after the last element
removed.
reference front( );

const_reference front( ) const;
Returns a reference to the first

element in the list.allocator_type get_allocator( ) const;Returns list's allocator.
iterator insert(iteratori,const T &val= T( ));Insertsvalimmediately before the
element specified byi.An iteratorto the element is returned.
void insert(iteratori, size_typenum,const T &val);Insertsnumcopies ofvalimmediatelybefore the element specified by
i.template <class InIter>void insert(iteratori,InIterstart, InIterend);Inserts the sequence defined bystartandendimmediately before
the element specified byi.size_type max_size( ) const;Returns the maximum number ofelements that the list can hold.void merge(list<T, Allocator> &
ob);
template <class Comp>void merge(<list<T,  Allocator> &
ob,Compcmpfn);Merges the ordered list contained

inobwith the ordered invoking list.
The result is ordered. After the merge,

the list contained inobis empty.
In the second form, a comparison
function can be specified that
determines when one element
is less than another.
void pop_back( );Removes the last element in the list.void pop_front( );
Removes the first element in the list.MemberDescriptionvoid push_back(const T &val);Adds an element with the valuespecified byvalto the end of the list.void push_front(const T &
val);Adds an element with the value
specified byvalto the front of the list.
reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the list.void remove(const T &
val);Removes elements with the valuevalfrom the list.
template <class UnPred>
void remove_if(UnPred
pr);Removes elements for which the
unary predicate
pris true.
reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the

start of the list.void resize(size_type
num, Tval= T ( ));Changes the size of the list to that
specified bynum. If the list must belengthened, then elements with the
value specified byvalare added to
the end.void reverse( );
Reverses the invoking list.size_type size( ) const;Returns the number of elementscurrently in the list.
void sort( );
template <class Comp>void sort(Compcmpfn);Sorts the list. The second form sorts
the list using the comparison function
cmpfnto determine when one elementis less than another.
void splice(iteratori,list<T, Allocator> &
ob);The contents ofobare inserted
into the invoking list at the location
pointed to byi. After the operation,obis empty.
void splice(iteratori,list<T, Allocator> &
ob,
iteratorel);The element pointed to byelisremoved from the list
oband stored
in the invoking list at the location
pointed to byi.void splice(iteratori,list<T, Allocator> &ob,

iteratorstart, iteratorend);The range defined bystartandendis removed from
oband stored in the
invoking list beginning at the location
pointed to byi.Chapter33:TheSTLContainerClasses
821THESTANDARDC++
CLASSLIBRARY
822C++:TheCompleteReference
MemberDescriptionvoid swap(list<T, Allocator> &
ob);Exchanges the elements stored in the
invoking list with those inob.void unique( );template <class BinPred>
void unique(BinPred
pr);Removes duplicate elements from the

invoking list. The second form usesprto determine uniqueness.mapThemapclass supports an associative container in which unique keys are mapped
with values. Its template specification is shown here:
template <class Key, class T, class Comp = less<Key>,class Allocator = allocator<pair<const Key, T > > > class mapHere,
Keyis the data type of the keys,Tis the data type of the values being stored
(mapped), andCompis a function that compares two keys. It has the following
constructors:
explicit map(const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ) );map(const map<Key, T, Comp, Allocator> &ob);template <class InIter> map(InIterstart, InIterend,const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ));Thefirstformconstructsanemptymap.Thesecondformconstructsamapthat
contains the same elements asob. The third form constructs a map that contains the
elements in the range specified bystartandend. The function specified bycmpfn,ifpresent, determines the ordering of the map.
The following comparison operators are defined for
map.==, <, <=, !=, >, >=The member functions contained bymapare shown here. In the descriptions,
key_typeis the type of the key, and
value_typerepresents
pair<Key, T>
.MemberDescriptioniterator begin( );const_iterator begin( ) const;Returns an iterator to the first
element in the map.void clear( );Removes all elements from the map.
size_type count(const key_type &k) const;Returns the number of times
koccurs in the map (1 or zero).
bool empty( ) const;Returns true if the invoking map is
empty and false otherwise.iterator end( );const_iterator end( ) const;Returns an iterator to the end of
the map.pair<iterator, iterator>
equal_range(const key_type &k);pair<const_iterator, const_iterator>
equal_range(const key_type &k) const;Returns a pair of iterators that point
to the first and last elements in the
map that contain the specified key.
void erase(iteratori);
Removestheelementpointedtoby
i.void erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend.size_type erase(const key_type &k);Removes from the map elements
that have keys with the valuek.iterator find(const key_type &k);
const_iterator find(const key_type &k)const;Returns an iterator to the specified
key. If the key is not found, then

an iterator to the end of the map
is returned.
allocator_type get_allocator( ) const;Returns map's allocator.
iterator insert(iteratori,const value_type &val);Insertsvalat or after the elementspecified byi.An iterator to theelement is returned.
template <class InIter>void insert(InIterstart, InIterend);Inserts a range of elements.pair<iterator, bool>
insert(const value_type &val);Insertsvalinto the invoking map.An iterator to the element isreturned. The element is only

inserted if it does not already

exist. If the element was inserted,
pair<iterator, true>
is returned.
Otherwise,pair<iterator,false>
is returned.
Chapter33:TheSTLContainerClasses
823THESTANDARDC++
CLASSLIBRARY
824C++:TheCompleteReference
MemberDescriptionkey_compare key_comp( ) const;
Returns the function object thatcompares  keys.
iterator lower_bound(const key_type  &k);const_iteratorlower_bound(const key_type &k) const;Returns an iterator to the first
element in the map with the key
equal to or greater than
k.size_type max_size( ) const;Returns the maximum number of
elements that the map can hold.mapped_type&operator[]
(constkey_type&
i);Returns a reference to the element

specified byi. If this element doesnot exist, it is inserted.reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the map.reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the start

of the map.size_type size( ) const;Returns the number of elementscurrently in the map.
void swap(map<Key, T, Comp,
Allocator> &ob);Exchanges the elements stored in

the invoking map with those inob.iterator upper_bound(const key_type  &k);
const_iteratorupper_bound(const key_type &k) const;Returns an iterator to the first
element in the map with the key
greater than
k.value_compare value_comp( ) const;Returns the function object that
compares  values.
multimapThemultimapclass supports an associative container in which possibly nonuniquekeys are mapped with values. Its template specification is shown here:
template <class Key, class T, class Comp = less<Key>,class Allocator = allocator<pair<const Key, T > > > class multimapHere,
Keyis the data type of the keys,Tis the data type of the values being stored
(mapped), andCompis a function that compares two keys. It has the following
constructors:
explicit multimap(const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ) );multimap(const multimap<Key, T, Comp, Allocator> &ob);template <class InIter> multimap(InIterstart, InIterend,const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ));The first form constructs an empty multimap. The second form constructs a multimap
thatcontainsthesameelementsas
ob.Thethirdformconstructsamultimapthatcontains
the elements in the range specified bystartandend. The function specified bycmpfn,ifpresent, determines the ordering of the multimap.
The following comparison operators are defined by
multimap:==, <, <=, !=, >, >=Thememberfunctionscontainedby
multimapareshownhere.Inthedescriptions,
key_typeisthetypeofthekey,
Tisthevalue,and
value_typerepresents
pair<Key,T>
.MemberDescriptioniterator begin( );const_iterator begin( ) const;Returns an iterator to the first
element in the multimap.void clear( );Removes all elements from the
multimap.size_type count(const key_type &k) const;Returns the number of times
koccursin the multimap.bool empty( ) const;Returnstrueiftheinvokingmultimap

is empty and false otherwise.iterator end( );
const_iterator end( ) const;Returns an iterator to the end of
the list.pair<iterator, iterator>
equal_range(const key_type &k);pair<const_iterator, const_iterator>
equal_range(const key_type &k) const;Returns a pair of iterators that
point to the first and last elements
in themultimap that contain the

specified key.
void erase(iteratori);Removes the element pointed to byi.void  erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend.Chapter33:TheSTLContainerClasses
825THESTANDARDC++
CLASSLIBRARY
MemberDescriptionsize_type erase(const key_type &k);Removes from the multimap
elements that have keys withthe valuek.iterator find(const key_type &k);
const_iterator find(const key_type &k)const;Returns an iterator to the specified
key. If the key is not found, then an

iterator to the end of the multimap
is returned.
allocator_type get_allocator( ) const;Returns multimap's allocator.
iterator insert(iteratori,const value_type &val);Insertsvalat or after the elementspecified byi.An iterator to theelement is returned.
template <class InIter>void insert(InIterstart, InIterend);Inserts a range of elements.iterator insert(const value_type &val);Inserts
valinto the invokingmultimap.key_compare key_comp( ) const;
Returns the function object thatcompares  keys.
iterator lower_bound(const key_type  &k);const_iteratorlower_bound(const key_type &k) const;Returns an iterator to the first
element in the multimap with
the key equal to or greater than
k.size_type max_size( ) const;Returns the maximum number ofelements that the multimap can hold.reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the multimap.reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the start

of the multimap.size_type size( ) const;Returns the number of elementscurrently in the multimap.
void swap(multimap<Key, T, Comp,
Allocator> &ob);Exchanges the elements stored in the

invoking multimap with those inob.iterator upper_bound(const key_type  &k);
const_iteratorupper_bound(const key_type &k) const;Returnsaniteratortothefirstelement

inthemultimapwiththekeygreater

thank.value_compare value_comp( ) const;Returns the function object that
compares  values.
826C++:TheCompleteReference
Chapter33:TheSTLContainerClasses
827THESTANDARDC++
CLASSLIBRARY
multisetThemultisetclass supports a set containing possibly nonunique keys.  Its templatespecification is shown here:
template <class Key, class Comp = less<Key>,class Allocator = allocator<Key> > class multisetHere,
Keyis the data of the keys andCompis a function that compares two keys. It has
the following constructors:
explicit multiset(const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ) );multiset(const multiset<Key, Comp, Allocator> &ob);template <class InIter> multiset(InIterstart, InIterend,const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ));The first form constructs an empty multiset. The second form constructs a multiset that
contains the same elements asob. The third form constructs a multiset that contains the
elementsintherangespecifiedby
startandend.Thefunctionspecifiedby
cmpfn,ifpresent,
determines the ordering of the set.
The following comparison operators are defined for
multiset.==, <, <=, !=, >, >=The member functions contained bymultisetare shown here. In the descriptions,
bothkey_typeandvalue_typeare
typedefs forKey.MemberDescriptioniterator begin( );const_iterator begin( ) const;Returns an iterator to the first
element in the multiset.void clear( );Removes all elements from the
multiset.size_type count(const key_type &k) const;Returns the number of times
koccursin the multiset.bool empty( ) const;Returns true if the invoking multiset
is empty and false otherwise.MemberDescriptioniterator end( );const_iterator end( ) const;Returns an iterator to the end of the
multiset.pair<iterator, iterator>
equal_range(const key_type &k) const;Returnsapairofiteratorsthatpoint

tothefirstandlastelementsinthe

multisetthatcontainthespecifiedkey.
void erase(iteratori);Removes the element pointed to byi.void  erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend.size_type erase(const key_type &k);Removes from the multiset elements
that have keys with the valuek.iterator find(const key_type &k)  const;Returns an iterator to the specified
key. If the key is not found, then an

iterator to the end of the multiset is
returned.
allocator_type get_allocator( ) const;Returns multiset's allocator.
iterator insert(iteratori,const value_type &val);Insertsvalat or after the elementspecified byi.An iterator to theelement is returned.
template <class InIter>void insert(InIterstart, InIterend);Inserts a range of elements.iterator insert(const value_type &val);Inserts
valinto the invoking multiset.Aniteratortotheelementisreturned.
key_compare key_comp( ) const;
Returns the function object thatcompares  keys.
iterator lower_bound(const key_type  &k)const;Returns an iterator to the firstelement in the multiset with the
key equal to or greater than
k.size_type max_size( ) const;Returns the maximum number ofelements that the multiset can hold.reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the multiset.reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the start

of the multiset.828C++:TheCompleteReference
Chapter33:TheSTLContainerClasses
829THESTANDARDC++
CLASSLIBRARY
MemberDescriptionsize_type size( ) const;Returns the number of elementscurrently in the multiset.
void swap(multiset<Key, Comp,
Allocator> &ob);Exchanges the elements stored in the
invoking multiset with those inob.iterator upper_bound(const key_type  &k)const;Returns an iterator to the first
element in the multiset with the
key greater than
k.value_compare value_comp( ) const;Returns the function object that
compares  values.
queueThequeueclasssupportsasingle-endedqueue.Itstemplatespecificationisshownhere:
template <class T, class Container = deque<T> > class queueHere,
Tis the type of data being stored and
Containeris the type of container used tohold the queue. It has the following constructor:
explicit queue(const Container &cnt= Container( ));Thequeue()
constructorcreatesanemptyqueue.Bydefaultitusesa
dequeasacontainer,
but aqueuecan only be accessed in a first-in, first-out manner. You can also use a
listas a container for a queue. The container is held in a protected object called
cof typeContainer.The following comparison operators are defined for
queue:==, <, <=, !=, >, >=queuecontains the following member functions.MemberDescriptionvalue_type &back( );const value_type &back( ) const;Returns a reference to the last

element in the queue.bool empty( ) const;Returns true if the invoking queue
is empty and false otherwise.830C++:TheCompleteReference
MemberDescriptionvalue_type &front( );
const value_type &front( ) const;
Returns a reference to the first

element in the queue.void pop( );Removes the first element in
the queue.void push(const value_type &val);Adds an element with the value
specified byvalto the end ofthe queue.size_type size( ) const;Returns the number of elementscurrently in the queue.
priority_queueThepriority_queueclass supports a single-ended priority queue. Its templatespecification is shown here:
template <class T, class Container = vector<T>,class Comp = less<Container::value_type> >
class priority_queueHere,
Tis the type of data being stored.
Containeris the type of container used to holdthequeue,and
Compspecifiesthecomparisonfunctionthatdetermineswhenone
memberforthepriorityqueueislowerinprioritythananother.Ithasthefollowing

constructors:
explicit priority_queue(const Comp &cmpfn= Comp( ),Container &cnt= Container( ));template <class InIter> priority_queue(InIterstart, InIterend,const Comp &cmpfn= Comp( ),Container &cnt= Container( ));The firstpriority_queue( )constructor creates an empty priority queue. The second
creates a priority queue that contains the elements specified by the range
startandend.By default it uses avectoras a container. You can also use a
dequeas a container fora priority queue. The container is held in a protected object called
cof typeContainer.priority_queuecontains the following member functions.Chapter33:TheSTLContainerClasses
831THESTANDARDC++
CLASSLIBRARY
MemberDescriptionbool empty( ) const;Returns true if the invoking priority queue is
empty and false otherwise.void pop( );Removes the first element in the priority queue.
void push(const T &val);Adds an element to the priority queue.

size_type size( ) const;Returns the number of elements current in the
priority queue.const value_type &top( ) const;Returns a reference to the element with the
highest priority. The element is not removed.
setThesetclass supports a set containing unique keys.  Its template specification isshown here:
template <class Key, class Comp = less<Key>,class Allocator = allocator<Key> > class setHere,
Keyis the data of the keys andCompis a function that compares two keys. It has
the following constructors:
explicit set(const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ) );set(const set<Key, Comp, Allocator> &
ob);template <class InIter> set(InIterstart, InIterend,const Comp &cmpfn= Comp( ),const Allocator &a= Allocator( ));Thefirstformconstructsanemptyset.Thesecondformconstructsasetthatcontainsthe
sameelementsas
ob.Thethirdformconstructsasetthatcontainstheelementsintherange
specified bystartandend. The function specified bycmpfn,if present, determines the
ordering of the set.
The following comparison operators are defined for
set:==, <, <=, !=, >, >=The member functions contained bysetare shown here.
MemberDescriptioniterator begin( );const_iterator begin( ) const;Returns an iterator to the first
element in the set.void clear( );Removes all elements from the set.
size_type count(const key_type &k) const;Returns the number of times
koccurs in the set.bool empty( ) const;Returns true if the invoking set is
empty and false otherwise.const_iterator end( ) const;iterator end( );Returns an iterator to the end of
the set.pair<iterator, iterator>
equal_range(const key_type &k) const;Returns a pair of iterators that point
to the first and last elements in the
set that contain the specified key.
void erase(iteratori);
Removestheelementpointedtoby
i.void  erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend.size_type erase(const key_type &k);Removes from the set elements that
have keys with the valuek. Thenumber of elements removed is

returned.
iterator find(const key_type &k)  const;Returns an iterator to the specified
key. If the key is not found, then

an iterator to the end of the set is
returned.
allocator_type get_allocator( ) const;Returns set's allocator.
iterator insert(iteratori,const value_type &val);Insertsvalat or after the elementspecified byi.Duplicate elementsare not inserted. An iterator to the
element is returned.
template <class InIter>void insert(InIterstart, InIterend);Inserts a range of elements.
Duplicate elements are not inserted.
832C++:TheCompleteReference
Chapter33:TheSTLContainerClasses
833THESTANDARDC++
CLASSLIBRARY
MemberDescriptionpair<iterator, bool>
insert(const value_type &val);Insertsvalinto the invoking set. Aniterator to the element is returned.
The element is inserted only if it
does not already exist. If the element

was inserted,pair<iterator, true>
isreturned. Otherwise,
pair<iterator,
false>is returned.
iterator lower_bound(const key_type  &k)const;Returns an iterator to the first
element in the set with the key
equal to or greater than
k.key_compare key_comp( ) const;Returns the function object that
compares  keys.
size_type max_size( ) const;Returns the maximum number of
elements that the set can hold.reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the set.reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the start

of the set.size_type size( ) const;Returns the number of elements
currently in the set.
void swap(set<Key, Comp,Allocator> &
ob);Exchanges the elements stored in
the invoking set with those inob.iterator upper_bound(const key_type  &k)const;Returns an iterator to the first
element in the set with the key
greater than
k.value_compare value_comp( ) const;Returns the function object that
compares  values.
stackThestackclass supports a stack. Its template specification is shown here:
template <class T, class Container = deque<T> > class stack834C++:TheCompleteReference
Here,
Tis the type of data being stored and
Containeris the type of container used tohold the stack. It has the following constructor:
explicit stack(const Container &cnt= Container( ));Thestack()
constructorcreatesanemptystack.Bydefaultitusesa
dequeasacontainer,
but astackcan only be accessed in a last-in, first-out manner. You may also use a
vectororlistas a container for a stack. The container is held in a protected member called
coftypeContainer.The following comparison operators are defined for
stack:==, <, <=, !=, >, >=stackcontains the following member functions.MemberDescriptionbool empty( ) const;Returns true if the invoking stack is
empty and false otherwise.void pop( );Removes the top of the stack, which
is technically the last element in the
container.
void push(const value_type &val);Pushes an element onto the end of the
stack. The last element in the container
represents the top of the stack.
size_type size( ) const;Returns the number of elements
currently in the stack.
value_type &top( );
cont value_type &top( ) const;Returns a reference to the top of the

stack, which is the last element in the
container. The element is not removed.
vectorThevectorclass supports a dynamic array. Its template specification is shown here.
template <class T, class Allocator = allocator<T> > class vectorHere,
Tis the type of data being stored and
Allocatorspecifies the allocator. It has the
following constructors.
Chapter33:TheSTLContainerClasses
835THESTANDARDC++
CLASSLIBRARY
explicit vector(const Allocator &a= Allocator( ) );explicit vector(size_typenum, const T &val= T ( ),const Allocator &a= Allocator( ));vector(const vector<T, Allocator> &
ob);template <class InIter> vector(InIterstart, InIterend,const Allocator &a = Allocator( ));The first form constructs an empty vector. The second form constructs a vector that has
numelements with the valueval. The third form constructs a vector that contains the
same elements asob. The fourth form constructs a vector that contains the elements in
the range specified bystartandend.The following comparison operators are defined for
vector:==, <, <=, !=, >, >=vectorcontains the following member functions.MemberDescriptiontemplate <class InIter>void assign(InIterstart, InIterend);Assigns the vector the sequencedefined bystartandend.void assign(size_typenum, const T &val);Assigns the vector
numelements ofvalueval.reference at(size_type
i);const_reference at(size_type
i) const;Returns a reference to an element

specified byi.reference back( );

const_reference back( ) const;
Returns a reference to the last

element in the vector.
iterator begin( );
const_iterator begin( ) const;Returns an iterator to the first
element in the vector.
size_type capacity( ) const;Returns the current capacity of
the vector. This is the number of

elements it can hold before it will

need to allocate more memory.
void clear( );Removesallelementsfromthevector.
bool empty( ) const;Returns true if the invoking vector is

empty and false otherwise.MemberDescriptioniterator end( );const_iterator end( ) const;Returns an iterator to the end of
the vector.
iterator erase(iteratori);Removes the element pointed to byi.Returnsaniteratortotheelementafter

the one removed.
iterator erase(iteratorstart, iteratorend);Removes the elements in the range
starttoend. Returns an iterator tothe element after the last element
removed.
reference front( );

const_reference front( ) const;
Returns a reference to the first

element in the vector.
allocator_type get_allocator( ) const;Returns vector's allocator.
iterator insert(iteratori, const T &val);Inserts
valimmediately before the
element specified byi.An iteratorto the element is returned.
void insert(iteratori, size_typenum,const T &val);Insertsnumcopies ofvalimmediatelybefore the element specified by
i.template <class InIter>void insert(iteratori, InIterstart,InIterend);Inserts the sequence defined bystartandendimmediately before
the element specified byi.size_type max_size( ) const;Returns the maximum number ofelements that the vector can hold.reference operator[ ](size_type
i) const;const_reference operator[ ](size_type
i)const;Returns a reference to the element

specified byi.void pop_back( );Removesthelastelementinthevector.
void push_back(const T &val);Adds an element with the value
specified byvalto the end ofthe vector.
reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Returns a reverse iterator to the end

of the vector.
reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to the start

of the vector.
836C++:TheCompleteReference
MemberDescriptionvoid reserve(size_type
num);Sets the capacity of the vector so thatit is equal to at leastnum.void resize(size_type
num, T val = T ( ));Changes the size of the vector to that
specified bynum. If the vector mustbe lengthened, then elements with
the value specified byvalare added
to the end.size_type size( ) const;Returns the number of elementscurrently in the vector.
void swap(vector<T, Allocator> &
ob);Exchanges the elements stored in the
invoking vector with those inob.The STLalso contains a specialization of
vectorfor Boolean values. It includes all ofthe functionality ofvectorand adds these two members.void flip( );Reverses all bits in the vector.
static void swap(reference
i, reference
j);Exchanges the bits specified by
iandj.Chapter33:TheSTLContainerClasses
837THESTANDARDC++
CLASSLIBRARY
This page intentionally left blank Chapter34
The STL Algorithms839Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
Thealgorithmsdefinedbythestandardtemplatelibraryaredescribedhere.These
algorithmsoperateoncontainersthroughiterators.Allofthealgorithmsaretemplate

functions.Herearedescriptionsofthegenerictypenamesusedbythealgorithms.
Generic NameRepresents
BiIterBidirectional iterator

ForIterForward iterator

InIterInput iterator

OutIterOutput iterator

RandIterRandom access iterator

TSome type of data

SizeSome type of integer

FuncSome type of function

GeneratorAfunction that generates objects

BinPredBinary predicate

UnPredUnary predicate

CompComparison function
adjacent_findtemplate <class ForIter>ForIter adjacent_find(ForIterstart, ForIterend);template <class ForIter, class BinPred>ForIter adjacent_find(ForIterstart, ForIterend, BinPredpfn);Theadjacent_find( )algorithm searches for adjacent matching elements within
a sequence specified bystartandendand returns an iterator to the first element. If no
adjacent pair is found,endis returned. The first version looks for equivalent elements.
Thesecondversionletsyouspecifyyourownmethodfordeterminingmatching
elements.binary_search
template <class ForIter, class T>bool binary_search(ForIterstart, ForIterend, const T &val);840C++:TheCompleteReference
Chapter34:TheSTLAlgorithms
841THESTANDARDC++
CLASSLIBRARY
template <class ForIter, class T, class Comp>bool binary_search(ForIterstart, ForIterend, const T &val,Compcmpfn);Thebinary_search( )algorithm performs a binary search on an ordered sequence
beginning atstartand ending withendfor the value specified byval. It returns true if
valisfoundandfalseotherwise.Thefirstversioncomparestheelementsinthespecified
sequence for equality. The second version allows you to specify your own comparison
function.copytemplate <class InIter, class OutIter>OutIter copy(InIterstart, InIterend, OutIterresult);Thecopy( )algorithm copies a sequence beginning atstartand ending withend,putting the result into the sequence pointed to by
result
. It returns an iterator to the
end of the resulting sequence. The range to be copied must not overlap with
result
.copy_backward
template <class BiIter1, class BiIter2>BiIter2copy_backward(BiIter1
start,BiIter1
end,BiIter2
result);Thecopy_backward( )algorithm is the same ascopy( )except that it moves theelements from the end of the sequence first.
counttemplate <class InIter, class T>ptrdiff_t count(InIterstart, InIterend, const T &val);Thecount( )algorithm returns the number of elements in the sequence beginning at
startand ending atendthat matchval.842C++:TheCompleteReference
count_iftemplate <class InIter, class UnPred>ptrdiff_t count_if(InIterstart, InIterend, UnPredpfn);Thecount_if()
algorithmreturnsthenumberofelementsinthesequencebeginningat
startandendingat
endforwhichtheunarypredicate
pfnreturnstrue.Thetype
ptrdiff_t
isdefinedassomeformofinteger.
equaltemplate <class InIter1, class InIter2>bool equal(InIter1start1, InIter1end1, InIter2start2);template <class InIter1, class InIter2, class BinPred>bool equal(InIter1start1, InIter1end1, InIter2start2,BinPredpfn);Theequal()
algorithmdeterminesiftworangesarethesame.Therangedetermined
bystart1andend1istestedagainstthesequencepointedtoby
start2.Iftherangesarethe
same,trueisreturned.Otherwise,falseisreturned.
The second form allows you to specify a binary predicate that determines when
two elements are equal.
equal_rangetemplate <class ForIter, class T>pair<ForIter, ForIter> equal_range(ForIterstart, ForIterend,const T &val);template <class ForIter, class T, class Comp>pair<ForIter, ForIter> equal_range(ForIterstart, ForIterend,const T &val, Compcmpfn);Theequal_range( )algorithm returns a range in which an element can be inserted
into a sequence without disrupting the ordering of the sequence. The region in which
to search for such a range is specified by
startandend. The value is passed inval. To
specify your own search criteria, specify the comparison function
cmpfn.The template classpairis a utility class that can hold a pair of objects in itsfirstandsecondmembers.fill and fill_ntemplate <class ForIter, class T>void fill(ForIterstart, ForIterend, const T &val);template <class OutIter, class Size, class T>void fill_n(OutIterstart, Sizenum, const T &val);Thefill( )andfill_n( )algorithms fill a range with the value specified byval. Forfill( )the range is specified bystartandend. Forfill_n( ), the range begins atstartandruns for
numelements.findtemplate <class InIter, class T>InIter find(InIterstart, InIterend, const T &val);Thefind( )algorithm searches the range
starttoendfor the value specified byval.It returns an iterator to the first occurrence of the element or to
endif the value is notin the sequence.find_endtemplate <class ForIter1, class ForIter2>ForIter1 find_end(ForIter1start1, ForIter1end1,ForIter2start2, ForIter2end2);template <class ForIter1, class ForIter2, class BinPred>ForIter1 find_end(ForIter1start1, ForIter1end1,ForIter2start2, ForIter2end2, BinPredpfn);Thefind_end( )algorithm finds the last subsequence defined bystart2andend2withintherange
start1andend1.Ifthesequenceisfound,aniteratortothefirstelement
in the sequence is returned. Otherwise, the iterator
end1is returned.
The second form allows you to specify a binary predicate that determines when
elements match.find_first_oftemplate <class ForIter1, class ForIter2>ForIter1 find_first_of(ForIter1start1, ForIter1end1,Chapter34:TheSTLAlgorithms
843THESTANDARDC++
CLASSLIBRARY
ForIter2start2, ForIter2end2);template <class ForIter1, class ForIter2, class BinPred>ForIter1 find_first_of(ForIter1start1, ForIter1end1,ForIter2start2, ForIter2end2,BinPredpfn);Thefind_first_of( )algorithm finds the first element within the sequence definedbystart1andend1that matches an element within the rangestart1andend1. If nomatching element is found, the iteratorend1is returned.
The second form allows you to specify a binary predicate that determines when
elements match.find_iftemplate <class InIter, class UnPred>InIter find_if(InIterstart, InIterend, UnPredpfn);Thefind_if()
algorithmsearchestherange
starttoendforanelementforwhichthe
unarypredicate
pfnreturnstrue.Itreturnsaniteratortothefirstoccurrenceoftheelement
orto
endifthevalueisnotinthesequence.
for_eachtemplate<class InIter, class Func>Func for_each(InIterstart, InIterend, Funcfn);Thefor_each( )algorithm applies the functionfnto the range of elements specifiedbystartandend. It returns
fn.generate and generate_ntemplate <class ForIter, class Generator>void generate(ForIterstart, ForIterend, Generatorfngen);template <class ForIter, class Size, class Generator>void generate_n(OutIterstart, Sizenum, Generatorfngen);The algorithmsgenerate( )andgenerate_n( )assign to  elements in a range thevalues returned by a generator function. For
generate( ), the range being assigned is844C++:TheCompleteReference
specified bystartandend. Forgenerate_n( ), the range begins atstartand runs for
numelements. The generator function is passed infngen. It has no parameters.includestemplate <class InIter1, class InIter2>bool includes(InIter1start1, InIter1end1,InIter2start2, InIter2end2);template <class InIter1, class InIter2, class Comp>bool includes(InIter1start1, InIter1end1,InIter2start2, InIter2end2, Compcmpfn);Theincludes( )algorithm determines if the sequence defined bystart1andend1includes all of the elements in the sequence defined bystart2andend2. It returns true
if the elements are all found and false otherwise.
The second form allows you to specify a comparison function that determines whenone element is less than another.
inplace_merge
template <class BiIter>void inplace_merge(BiIterstart, BiItermid, BiIterend);template <class BiIter, class Comp>voidinplace_merge(BiIter
start,BiIter
mid,BiIter
end,Compcmpfn);Within a single sequence, the
inplace_merge( )algorithm merges the range defined
bystartandmidwith the range defined bymidandend. Both ranges must be sorted inincreasing order. After executing, the resulting sequence is sorted in increasing order.
The second form allows you to specify a comparison function that determines whenone element is less than another.
iter_swaptemplate <class ForIter1, class ForIter2>void iter_swap(ForIter1i, ForIter2j)Theiter_swap( )algorithm exchanges the values pointed to by its two iteratorarguments.
Chapter34:TheSTLAlgorithms
845THESTANDARDC++
CLASSLIBRARY
lexicographical_compare
template <class InIter1, class InIter2>bool lexicographical_compare(InIter1start1, InIter1end1,InIter2start2, InIter2end2);template <class InIter1, class InIter2, class Comp>bool lexicographical_compare(InIter1start1, InIter1end1,InIter2start2, InIter2end2,Compcmpfn);Thelexicographical_compare( )algorithm alphabetically compares the sequence
defined bystart1andend1with the sequence defined bystart2andend2. It returns true
ifthefirstsequenceislexicographicallylessthanthesecond(thatis,ifthefirstsequence
would come before the second using dictionary order).
The second form allows you to specify a comparison function that determines whenone element is less than another.
lower_boundtemplate <class ForIter, class T>ForIter lower_bound(ForIterstart, ForIterend, const T &val);template <class ForIter, class T, class Comp>ForIter lower_bound(ForIterstart, ForIterend, const T &val,Compcmpfn);Thelower_bound( )algorithm finds the first point in the sequence defined bystartandendthat is not less thanval. It returns an iterator to this point.
The second form allows you to specify a comparison function that determines whenone element is less than another.
make_heaptemplate <class RandIter>void make_heap(RandIterstart, RandIterend);template <class RandIter, class Comp>void make_heap(RandIterstart, RandIterend, Compcmpfn);Themake_heap( )algorithm constructs a heap from the sequence defined by
startandend.846C++:TheCompleteReference
The second form allows you to specify a comparison function that determines whenone element is less than another.
maxtemplate <class T>const T &max(const T &i, const T &j);template <class T, class Comp>const T &max(const T &i, const T &j, Compcmpfn);Themax( )algorithm returns the maximum of two values.
The second form allows you to specify a comparison function that determines whenone element is less than another.
max_elementtemplate <class ForIter>ForIter max_element(ForIterstart, ForIterlast);template <class ForIter, class Comp>ForIter max_element(ForIterstart, ForIterlast, Compcmpfn);Themax_element( )algorithm returns an iterator to the maximum element within
the rangestartandlast.The second form allows you to specify a comparison function that determines whenone element is less than another.
merge
template <class InIter1, class InIter2, class OutIter>OutIter merge(InIter1start1, InIter1end1,InIter2start2, InIter2end2,OutIterresult);template <class InIter1, class InIter2, class OutIter, class Comp>OutIter merge(InIter1start1, InIter1end1,InIter2start2, InIter2end2,OutIterresult, Compcmpfn);Themerge( )algorithm merges two ordered sequences, placing the result into a
third sequence. The sequences to be merged are defined by
start1,end1andstart2,end2.Chapter34:TheSTLAlgorithms
847THESTANDARDC++
CLASSLIBRARY
The result is put into the sequence pointed to by
result
. An iterator to the end of theresulting sequence is returned.
The second form allows you to specify a comparison function that determines whenone element is less than another.
mintemplate <class T>const T &min(const T &i, const T &j);template <class T, class Comp>const T &min(const T &i, const T &j, Compcmpfn);Themin( )algorithm returns the minimum of two values.
The second form allows you to specify a comparison function that determines whenone element is less than another.
min_elementtemplate <class ForIter>ForIter min_element(ForIterstart, ForIterlast);template <class ForIter, class Comp>ForIter min_element(ForIterstart, ForIterlast, Compcmpfn);Themin_element( )algorithm returns an iterator to the minimum element within
the rangestartandlast.The second form allows you to specify a comparison function that determines whenone element is less than another.
mismatchtemplate <class InIter1, class InIter2>pair<InIter1, InIter2> mismatch(InIter1start1, InIter1end1,InIter2start2);template <class InIter1, class InIter2, class BinPred>pair<InIter1, InIter2> mismatch(InIter1start1, InIter1end1,InIter2start2, BinPredpfn);Themismatch( )algorithm finds the first mismatch between the elements in twosequences. Iterators to the two elements are returned. If no mismatch is found, iterators
to the end of the sequence are returned.
848C++:TheCompleteReference
Chapter34:TheSTLAlgorithms
849THESTANDARDC++
CLASSLIBRARY
The second form allows you to specify a binary predicate that determines when one
element is equal to another.
Thepairtemplateclasscontainstwodatamemberscalled
firstandsecondthathold
the pair of values.next_permutation
template <class BiIter>bool next_permutation(BiIterstart, BiIterend);template <class BiIter, class Comp>bool next_permutation(BiIterstart, BiIterend, Compcmfn);Thenext_permutation()
algorithmconstructsthenextpermutationofasequence.The
permutations are generated assuming a sorted sequence: from low to high represents
thefirstpermutation.Ifthenextpermutationdoesnotexist,
next_permutation()
sortsthe
sequenceasitsfirstpermutationandreturnsfalse.Otherwise,itreturnstrue.
The second form allows you to specify a comparison function that determines whenone element is less than another.
nth_elementtemplate <class RandIter>void nth_element(RandIterstart, RandIterelement, RandIterend);template <class RandIter, class Comp>void nth_element(RandIterstart, RandIterelement,RandIterend, Compcmpfn);Thenth_element( )algorithm arranges the sequence specified bystartandendsuchthatallelementslessthan
elementcomebeforethatelementandallelementsgreaterthan
elementcome after it.The second form allows you to specify a comparison function that determines whenone element is greater than another.
partial_sort
template <class RandIter>void partial_sort(RandIterstart, RandItermid, RandIterend);template <class RandIter, class Comp>void partial_sort(RandIterstart, RandItermid,RandIterend, Compcmpfn);Thepartial_sort( )algorithm sorts the rangestarttoend.However, after execution,
only elements in the rangestarttomidwill be in sorted order.
The second form allows you to specify a comparison function that determines whenone element is less than another.
partial_sort_copy
template <class InIter, class RandIter>RandIter partial_sort_copy(InIterstart, InIterend,RandIterres_start,RandIterres_end);template <class InIter, class RandIter, class Comp>RandIter partial_sort_copy(InIterstart, InIterend,RandIterres_start,RandIterres_end,Compcmpfn);Thepartial_sort_copy()
algorithmsortstherange
starttoendandthencopiesasmany
elementsaswillfitintotheresultingsequencedefinedby
res_start
andres_end
.Itreturnsan
iteratortoonepastthelastelementcopiedintotheresultingsequence.
The second form allows you to specify a comparison function that determines whenone element is less than another.
partition
template <class BiIter, class UnPred>BiIter partition(BiIterstart, BiIterend, UnPredpfn);Thepartition( )algorithm arranges the sequence defined bystartandendsuch thatall elements for which the predicate specified by
pfnreturns true come before those for
which the predicate returns false. It returns an iterator to the beginning of the elements
for which the predicate is false.
pop_heaptemplate <class RandIter>void pop_heap(RandIterstart, RandIterend);template <class RandIter, class Comp>void pop_heap(RandIterstart, RandIterend, Compcmpfn);Thepop_heap( )algorithm exchanges thefirstandlast−1 elements and thenrebuilds the heap.
850C++:TheCompleteReference
THESTANDARDC++
CLASSLIBRARY
Chapter34:TheSTLAlgorithms
851The second form allows you to specify a comparison function that determines whenone element is less than another.
prev_permutation
template <class BiIter>bool prev_permutation(BiIterstart, BiIterend);template <class BiIter, class Comp>bool prev_permutation(BiIterstart, BiIterend, Compcmpfn);Theprev_permutation()
algorithmconstructsthepreviouspermutationofasequence.
Thepermutationsaregeneratedassumingasortedsequence:fromlowtohighrepresents
thefirstpermutation.Ifthenextpermutationdoesnotexist,
prev_permutation()
sortsthe
sequenceasitsfinalpermutationandreturnsfalse.Otherwise,itreturnstrue.
The second form allows you to specify a comparison function that determines whenone element is less than another.
push_heaptemplate <class RandIter>void push_heap(RandIterstart, RandIterend);template <class RandIter, class Comp>void push_heap(RandIterstart, RandIterend, Compcmpfn);Thepush_heap( )algorithm pushes an element onto the end of a heap. The rangespecified bystartandendis assumed to represent a valid heap.
The second form allows you to specify a comparison function that determines whenone element is less than another.
random_shuffle
template <class RandIter>void random_shuffle(RandIterstart, RandIterend);template <class RandIter, class Generator>voidrandom_shuffle(RandIter
start,RandIter
end,Generator
rand_gen);Therandom_shuffle()
algorithmrandomizesthesequencedefinedby
startandend.852C++:TheCompleteReference
The second form specifies a custom random number generator. This function must
have the following general form:rand_gen(num);It must return a random number between zero and
num.remove, remove_if, remove_copy, and remove_copy_if
template <class ForIter, class T>ForIter remove(ForIterstart, ForIterend, const T &val);template <class ForIter, class UnPred>ForIter remove_if(ForIterstart, ForIterend,  UnPredpfn);template <class InIter, class OutIter, class T>OutIter remove_copy(InIterstart, InIterend,OutIterresult, const T &val);template <class InIter, class OutIter, class UnPred>OutIter remove_copy_if(InIterstart, InIterend,OutIterresult, UnPredpfn);Theremove( )algorithm removes elements from the specified range that are equal
toval. It returns an iterator to the end of the remaining elements.
Theremove_if( )algorithm removes elements from the specified range for which
the predicate
pfnis true. It returns an iterator to the end of the remaining elements.
Theremove_copy( )algorithm copies elements from the specified range that are
equalto
valandputstheresultintothesequencepointedtoby
result
.Itreturnsaniterator
to the end of the result.
Theremove_copy_if()
algorithmcopieselementsfromthespecifiedrangeforwhich
the predicate
pfnis true and puts the result into the sequence pointed to by
result
. Itreturns an iterator to the end of the result.
replace, replace_copy, replace_if, and replace_copy_if
template <class ForIter, class T>void replace(ForIterstart, ForIterend,const T &old, const T &new);template <class ForIter, class UnPred, class T>void replace_if(ForIterstart, ForIterend,UnPredpfn, const T &new);template <class InIter, class OutIter, class T>OutIter replace_copy(InIterstart, InIterend, OutIterresult,const T &old, const T &new);template <class InIter, class OutIter, class UnPred, class T>OutIter replace_copy_if(InIterstart, InIterend, OutIterresult,UnPredpfn, const T &new);Withinthespecifiedrange,the
replace()
algorithmreplaceselementswiththevalue
oldwith elements that have the valuenew.Within the specified range, the
replace_if( )algorithm replaces those elements for
which the predicate
pfnis true with elements that have the value
new.
Within the specified range, the
replace_copy( )algorithm copies elements toresult
.In the process it replaces elements that have the value
oldwith elements that have thevaluenew. The original range is unchanged. An iterator to the end ofresult
is returned.
Within the specified range, the
replace_copy_if( )algorithm copies elements toresult
. In the process it replaces elements for which the predicate
pfnreturns true with
elements that have the valuenew. The original range is unchanged. An iterator to theend ofresult
is returned.
reverse and reverse_copy
template <class BiIter>void reverse(BiIterstart, BiIterend);template <class BiIter, class OutIter>OutIter reverse_copy(BiIterstart, BiIterend, OutIterresult);Thereverse( )algorithm reverses the order of the range specified by
startandend.Thereverse_copy( )algorithm copies in reverse order the range specified by
startandendand stores the result in
result
. It returns an iterator to the end of
result
.rotate and rotate_copy
template <class ForIter>void rotate(ForIterstart, ForItermid, ForIterend);template <class ForIter, class OutIter>OutIter rotate_copy(ForIterstart, ForItermid, ForIterend,OutIterresult);Therotate( )algorithm left-rotates the elements in the range specified by
startandendso that the element specified bymidbecomes the new first element.Chapter34:TheSTLAlgorithms
853THESTANDARDC++
CLASSLIBRARY
854C++:TheCompleteReference
Therotate_copy( )algorithm copies the range specified bystartandend,storing theresult in
result
. In the process it left-rotates the elements so that the element specified by
midbecomes the new first element. It returns an iterator to the end of
result
.search
template <class ForIter1, class ForIter2>ForIter1 search(ForIter1start1, ForIter1end1,ForIter2start2, ForIter2end2);template <class ForIter1, class ForIter2, class BinPred>ForIter1 search(ForIter1start1, ForIter1end1,ForIter2start2, ForIter2end2, BinPredpfn);Thesearch()
algorithmsearchesforasubsequencewithinasequence.Thesequence
beingsearchedisdefinedby
start1andend1.Thesubsequencebeingsearchedisspecified
bystart2andend2. If the subsequence is found, an iterator to its beginning is returned.
Otherwise,end1is returned.
The second form allows you to specify a binary predicate that determines when one
element is equal to another.
search_n
template <class ForIter, class Size, class T>ForIter search_n(ForIterstart, ForIterend,Sizenum, const T &val);template <class ForIter, class Size, class T, class BinPred>ForIter search_n(ForIterstart, ForIterend,Sizenum, const T &val,BinPredpfn);Thesearch_n()
algorithmsearchesforasequenceof
numelementsequalto
valwithinasequence.Thesequencebeingsearchedisdefinedby
start1andend1.Ifthesubsequenceis
found,aniteratortoitsbeginningisreturned.Otherwise,
endisreturned.
The second form allows you to specify a binary predicate that determines when one
element is equal to another.
set_difference
template <class InIter1, class InIter2, class OutIter>OutIter set_difference(InIter1start1, InIter1end1,InIter2start2, InIter2end2, OutIterresult);template <class InIter1, class InIter2, class OutIter, class Comp>OutIter set_difference(InIter1start1, InIter1end1,InIter2start2, InIter2end2,OutIterresult, Compcmpfn);Theset_difference( )
algorithm produces a sequence that contains the difference
between the two ordered sets defined by
start1,end1andstart2,end2. That is, the setdefined bystart2,end2is subtracted from the set defined by
start1,end1. The result is
ordered and put into
result
. It returns an iterator to the end of the result.
The second form allows you to specify a comparison function that determines whenone element is less than another.
set_intersectiontemplate <class InIter1, class InIter2, class OutIter>OutIter set_intersection(InIter1start1, InIter1end1,InIter2start2, InIter2end2, OutIterresult);template <class InIter1, class InIter2, class OutIter, class Comp>OutIter set_intersection(InIter1start1, InIter1end1,InIter2start2, InIter2end2,OutIterresult, Compcmpfn);Theset_intersection( )algorithm produces a sequence that contains the intersection
of the two ordered sets defined by
start1,end1andstart2,end2. These are the elements
common to both sets. The result is ordered and put into
result
. It returns an iterator to
the end of the result.
The second form allows you to specify a comparison function that determines whenone element is less than another.
set_symmetric_difference
template <class InIter1, class InIter2, class OutIter>OutIter set_symmetric_difference(InIter1start1, InIter1end1,InIter2start2, InIter2end2, OutIterresult);template <class InIter1, class InIter2, class OutIter, class Comp>OutIter set_symmetric_difference(InIter1start1, InIter1end1,InIter2start2, InIter2end2, OutIterresult,Compcmpfn);Chapter34:TheSTLAlgorithms
855THESTANDARDC++
CLASSLIBRARY
856C++:TheCompleteReference
Theset_symmetric_difference( )
algorithm produces a sequence that contains the
symmetric difference between the two ordered sets defined by
start1,end1andstart2,end2.Thatis,theresultantsetcontainsonlythoseelementsthatarenotcommontoboth
sets.Theresultisorderedandputinto
result
.Itreturnsaniteratortotheendoftheresult.
The second form allows you to specify a comparison function that determines whenone element is less than another.
set_uniontemplate <class InIter1, class InIter2, class OutIter>OutIter set_union(InIter1start1, InIter1end1,InIter2start2, InIter2end2, OutIterresult);template <class InIter1, class InIter2, class OutIter, class Comp>OutIter set_union(InIter1start1, InIter1end1,InIter2start2, InIter2end2, OutIterresult,Compcmpfn);Theset_union( )algorithm produces a sequence that contains the union of the two
ordered sets defined by
start1,end1andstart2,end2. Thus, the resultant set contains
those elements that are in both sets. The result is ordered and put into
result
. It returns
an iterator to the end of the result.
The second form allows you to specify a comparison function that determines whenone element is less than another.
sort
template <class RandIter>void sort(RandIterstart, RandIterend);template <class RandIter, classComp>void sort(RandIterstart, RandIterend, Compcmpfn);Thesort( )algorithm sorts the range specified bystartandend.The second form allows you to specify a comparison function that determines whenone element is less than another.
sort_heap
template <class RandIter>void sort_heap(RandIterstart, RandIterend);template <class RandIter, class Comp>void sort_heap(RandIterstart, RandIterend, Compcmpfn);Thesort_heap( )algorithm sorts a heap within the range specified bystartandend.The second form allows you to specify a comparison function that determines whenone element is less than another.
stable_partition
template <class BiIter, class UnPred>BiIter stable_partition(BiIterstart, BiIterend, UnPredpfn);Thestable_partition( )algorithm arranges the sequence defined bystartandendsuch that all elements for which the predicate specified by
pfnreturns true come before
those for which the predicate returns false. The partitioning is stable. This means that
the relative ordering of the sequence is preserved. It returns an iterator to the beginning

of the elements for which the predicate is false.
stable_sort
template <class RandIter>void stable_sort(RandIterstart, RandIterend);template <class RandIter, class Comp>void stable_sort(RandIterstart, RandIterend, Compcmpfn);Thesort( )algorithm sorts the range specified bystartandend. The sort is stable.This means that equal elements are not rearranged.
The second form allows you to specify a comparison function that determines whenone element is less than another.
swaptemplate <class T>void swap(T &i, T &j);Theswap( )algorithm exchanges the values referred to by
iandj.Chapter34:TheSTLAlgorithms
857THESTANDARDC++
CLASSLIBRARY
swap_rangestemplate <class ForIter1, class ForIter2>ForIter2 swap_ranges(ForIter1start1, ForIter1end1,ForIter2start2);Theswap_ranges( )algorithm exchanges elements in the range specified bystart1andend1with elements in the sequence beginning atstart2. It returns an iterator to the
end of the sequence specified bystart2.transform
template <class InIter, class OutIter, class Func>OutIter transform(InIterstart, InIterend,OutIterresult, Funcunaryfunc);template <class InIter1, class InIter2, class OutIter, class Func>OutIter transform(InIter1start1, InIter1end1,InIter2start2, OutIterresult,Funcbinaryfunc);Thetransform( )algorithm applies a function to a range of elements and stores the
outcome inresult
. In the first form, the range is specified bystartandend. The functionto be applied is specified byunaryfunc.This function receives the value of an element in
its parameter and it must return its transformation.
In the second form, the transformation is applied using a binary operator functionthat receives the value of an element from the sequence to be transformed in its first
parameter and an element from the second sequence as its second parameter.
Both versions return an iterator to the end of the resulting sequence.
unique and unique_copytemplate <class ForIter>ForIter unique(ForIterstart, ForIterend);template <class ForIter, class BinPred>ForIter unique(ForIterstart, ForIterend, BinPredpfn);template <class ForIter, class OutIter>OutIter unique_copy(ForIterstart, ForIterend, OutIterresult);template <class ForIter, class OutIter, class BinPred>OutIter unique_copy(ForIterstart, ForIterend, OutIterresult,BinPredpfn);858C++:TheCompleteReference
Theunique()
algorithmeliminatesduplicateelementsfromthespecifiedrange.The
secondformallowsyoutospecifyabinarypredicatethatdetermineswhenoneelement
isequaltoanother.
unique()
returnsaniteratortotheendoftherange.
Theunique_copy()
algorithmcopiestherangespecifiedby
start1andend1,eliminatingduplicateelementsintheprocess.Theoutcomeisputinto
result
.Thesecond
formallowsyoutospecifyabinarypredicatethatdetermineswhenoneelementisequal

toanother.
unique_copy()
returnsaniteratortotheendoftherange.
upper_boundtemplate <class ForIter, class T>ForIter upper_bound(ForIterstart, ForIterend, const T &val);template <class ForIter, class T, class Comp>ForIter upper_bound(ForIterstart, ForIterend, const T &val,Compcmpfn);Theupper_bound( )algorithm finds the last point in the sequence defined bystartandendthat is not greater than
val. It returns an iterator to this point.
The second form allows you to specify a comparison function that determines whenone element is less than another.
Chapter34:TheSTLAlgorithms
859THESTANDARDC++
CLASSLIBRARY
This page intentionally left blank Chapter35
STL Iterators,Allocators, and
Function Objects861Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
862C++:TheCompleteReference
This chapter describes the classes and functions that support iterators, allocators,and function objects. These components are part of the standard template library.
They may also be used for other purposes.IteratorsWhile containers and algorithms form the foundation of the standard template library,

iterators are the glue that holds it together. An
iteratoris a generalization (or perhaps
more precisely, an abstraction) of a pointer. Iterators are handled in your program like

pointers, and they implement the standard pointer operators. They give you the ability

to cycle through the contents of a container in much the same way that you would use

a pointer to cycle through an array.
Standard C++ defines a set of classes and functions that support iterators. However,
for the vast majority of STL-based programming tasks, you will not use these classes

directly. Instead, you will use the iterators provided by the various containers in the

STL,manipulatingthemlikeyouwouldanyotherpointer.Theprecedingnotwithstanding,

itisstillvaluabletohaveageneralunderstandingoftheiteratorclassesandtheircontents.

Forexample,itispossibletocreateyourowniteratorsthataccommodatespecial

situations. Also, developers of third-party libraries will find the iterator classes useful.
Iterators use the header<iterator>.The Basic Iterator Types
There are five types of iterators:
IteratorAccess AllowedRandom AccessStore and retrieve values. Elements may be accessed
randomly.
BidirectionalStore and retrieve values. Forward and backward moving.
ForwardStore and retrieve values. Forward moving only.

InputRetrieve but not store values. Forward moving only.

OutputStore but not retrieve values. Forward moving only.
In general, an iterator that has greater access capabilities can be used in place of one
that has lesser capabilities. For example, a forward iterator can be used in place of an

input iterator.
The STLalso supports
reverseiterators
. Reverse iterators are either bidirectional or
random-access iterators that move through a sequence in the reverse direction. Thus, if
THESTANDARDC++
CLASSLIBRARY
Chapter35:STLIterators,Allocators,andFunctionObjects
863a reverse iterator points to the end of a sequence, incrementing that iterator will cause
it to point one element before the end.
Stream-based iterators are available that allow you to operate on streams through
iterators.Finally,insertiteratorclassesareprovidedthatsimplifytheinsertionofelements

into a container.
Alliteratorsmustsupportthepointeroperationsallowedbytheirtype.Forexample,
aninputiteratorclassmustsupport
–>,++,*,==,and
!=.Further,the
*operatorcannotbe
usedtoassignavalue.Bycontrast,arandom-accessiteratormustsupport
–>,+,++,–,,*,<,>,<=,>=,–=,+=,==,!=,and
[].Also,the*mustallowassignment.
The Low-Level Iterator ClassesThe<iterator>header defines several classes that provide support for and aid in the
implementationofiterators.AsexplainedinChapter24,eachoftheSTLcontainersdefines

its own iterator type, which istypedefed asiterator. Thus, when using the standard
STLcontainers, you will not usually interact directly with the low-level iterator classes

themselves. But you can use the classes described here to derive your own iterators.
Several of the iterator classes make use of theptrdiff_t
type. This type is capable ofrepresenting the difference between two pointers.
iteratorTheiteratorclass is a base for iterators. It is shown here:
template <class Cat, class T, class Dist = ptrdiff_t,class Pointer = T *, class Ref = T &>struct iterator {typedef T value_type;typedef Dist difference_type;
typedef Pointer pointer;
typedef Ref reference;
typedef Cat iterator_category;};Here,
difference_type
isatypethatcanholdthedifferencebetweentwoaddresses,
value_typeisthetypeofvalueoperatedupon,
pointeristhetypeofapointertoa
value,referenceisthetypeofareferencetoavalue,and
iterator_categorydescribesthe type of the iterator (such as input, random-access, etc.).The following category classes are provided.
struct input_iterator_tag {};
struct output_iterator_tag {};864C++:TheCompleteReference
struct forward_iterator_tag: public input_iterator_tag {};struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: publicbidirectional_iterator_tag {};iterator_traitsThe classiterator_traitsprovides a convenient means of exposing the various types
defined by an iterator. It is defined like this:
template<class Iterator> struct iterator_traits {typedef Iterator::difference_type difference_type;typedef Iterator::value_type value_type;
typedef Iterator::pointer pointer;
typedef Iterator::reference reference;
typedef Iterator::iterator_category iterator_category;}The Predefined Iterators
The<iterator>header contains several predefined iterators that may be used directly
byyourprogramortohelpcreateotheriterators.TheseiteratorsareshowninTable35-1.
Notice that there are four iterators that operate on streams. The main purpose for the

stream iterators is to allow streams to be manipulated by algorithms. Also notice the

insert iterators. When these iterators are used in an assignment statement, they insert

elements into a sequence rather than overwriting existing elements.Each of the predefined iterators is examined here.
insert_iterator
Theinsert_iteratorclass supports output iterators that insert objects into a container. Its
template definition is shown here:
template <class Cont> class insert_iterator:public iterator<output_iterator_tag, void, void, void, void>Here,
Contis the type of container that the iterator operates upon.insert_iteratorhasthe following constructor:
insert_iterator(Cont &cnt, typename Cont::iteratoritr);Here,
cntis the container being operated upon anditris an iterator into the containerthat will be used to initialize theinsert_iterator.insert_iteratordefines the following operators: =, *, ++. Apointer to the container is
stored in a protected variable called
container. The container's iterator is stored in a
protected variable called
iter.Also defined is the functioninserter( ), which creates an
insert_iterator. It isshown here:
template <class Cont, class Iterator> insert_iterator<Cont>inserter(Cont &cnt, Iteratoritr);Insert iterators insert into, rather than overwrite, the contents of a container. To
fully understand the effects of an insert iterator, consider the following program. It first
createsasmallvectorofintegers,andthenusesan
insert_iteratortoinsertnewelements
into the vector rather than overwriting existing elements.// Demonstrate insert_iterator.#include <iostream>
#include <iterator>
#include <vector>
using namespace std;int main(){vector<int> v;Chapter35:STLIterators,Allocators,andFunctionObjects
865THESTANDARDC++
CLASSLIBRARY
ClassDescriptioninsert_iteratorAn output iterator that inserts anywhere in the container.
back_insert_iteratorAn output iterator that inserts at the end of a container.

front_insert_iteratorAn output iterator that inserts at the front of a container.

reverse_iteratorAreverse, bidirectional, or random-access iterator.

istream_iteratorAn input stream iterator.

istreambuf_iteratorAn input streambuf iterator.

ostream_iteratorAn output stream iterator.

ostreambuf_iteratorAn output streambuf iterator.
Table35-1.
The Predefined Iterator Classes
866C++:TheCompleteReference
vector<int>::iterator itr;int i;for(i=0; i<5; i++)v.push_back(i);cout << "Original array: ";itr = v.begin();
while(itr != v.end())cout << *itr++ << " ";cout << endl;itr = v.begin();itr += 2; // point to element 2// create insert_iterator to element 2insert_iterator<vector<int> > i_itr(v, itr);// insert rather than overwrite*i_itr++ = 100;
*i_itr++ = 200;cout << "Array after insertion: ";itr = v.begin();
while(itr != v.end())cout << *itr++ << " ";return 0;}The output from the program is shown here:
Original array: 0 1 2 3 4
Array after insertion: 0 1 100 200 2 3 4Intheprogram,hadtheassignmentsof100and200beendoneusingastandarditerator,
theoriginalelementsinthearraywouldhavebeenoverwritten.Thesamebasicprocess

appliesto
back_insert_iteratorandfront_insert_iteratoraswell.
Chapter35:STLIterators,Allocators,andFunctionObjects
867THESTANDARDC++
CLASSLIBRARY
back_insert_iterator
Theback_insert_iteratorclass supports output iterators that insert objects on the endof a container usingpush_back( ). Its template definition is shown here:
template <class Cont> class back_insert_iterator:public iterator<output_iterator_tag, void, void, void, void>Here,
Contis the type of container that the iterator operates upon.back_insert_iteratorhas the following constructor:
explicit back_insert_iterator(Cont &cnt);Here,
cntis the container being operated upon. All insertions will occur at the end.back_insert_iteratordefinesthefollowingoperators:=,*,++.Apointertothecontainer
isstoredinaprotectedvariablecalled
container.Also defined is the functionback_inserter( ), which creates a
back_insert_iterator.It is shown here:
template <class Cont> back_insert_iterator<Cont> back_inserter(Cont &cnt);front_insert_iterator
Thefront_insert_iteratorclass supports output iterators that insert objects on the front
of a container usingpush_front( ). Its template definition is shown here:
template <class Cont> class front_insert_iterator:public iterator<output_iterator_tag, void, void, void, void>Here,
Contis the type of container that the iterator operates upon.front_insert_iteratorhas the following constructor:
explicit front_insert_iterator(Cont &cnt);Here,
cntis the container being operated upon. All insertions will occur at the front.
front_insert_iteratordefinesthefollowingoperators:=,*,++.Apointertothecontainer
isstoredinaprotectedvariablecalled
container.Also defined is the functionfront_inserter( ), which creates a
front_insert_iterator.It is shown here:
template <class Cont> front_insert_iterator<Cont> inserter(Cont &cnt);868C++:TheCompleteReference
reverse_iterator
Thereverse_iteratorclasssupportsreverseiteratoroperations.Areverseiteratoroperates
the opposite of a normal iterator. For example,
++causes a reverse iterator to back up.
Its template definition is shown here:
template <class Iter> class reverse_iterator:public iterator<iterator_traits<Iter>::iterator_category,iterator_traits<Iter>::value_type,iterator_traits<Iter>::difference_type,
iterator_traits<Iter>::pointer,
iterator_traits<Iter>::reference>Here,
Iteris either a random-access iterator or a bidirectional iterator.
reverse_iteratorhas the following constructors:
reverse_iterator( );
explicit reverse_iterator(Iteritr);Here,
itris an iterator that specifies the starting location.IfIteris a random-access iterator, then the following operators are available:
–>,+,++,–,––,*,<,>,<=,>=,–=,+=,==,!=, and[ ]. IfIteris a bidirectional iterator, then
only–>,++,––, *,==, and!=are available.
Thereverse_iteratorclass defines a protected member called
current, which is aniterator to the current location.
The functionbase( )is also defined byreverse_iterator. Its prototype is shown here:
Iter base( ) const;It returns an iterator to the current location.
istream_iterator
Theistream_iteratorclass supports input iterator operations on a stream. Its template
definition is shown here:
template <class T, class CharType, class Attr = char_traits<CharType>,class Dist = ptrdiff_t> class istream_iterator:public iterator<input_iterator_tag, T, Dist, const T *, const T &>Here,
Tisthetypeofdatabeingtransferred,and
CharType
isthecharactertype(
charorwchar_t)thatthestreamisoperatingupon.
Distisatypecapableofholdingthedifference
betweentwoaddresses.
istream_iteratorhasthefollowingconstructors:
THESTANDARDC++
CLASSLIBRARY
Chapter35:STLIterators,Allocators,andFunctionObjects
869istream_iterator( );istream_iterator(istream_type &stream);
istream_iterator(const istream_iterator<T, CharType, Attr, Dist> &ob);Thefirstconstructorcreatesaniteratortoanemptystream.Thesecondcreatesaniterator

to the stream specified by
stream
. The typeistream_typeis atypedefthat specifies thetype of the input stream. The third form creates a copy of an
istream_iteratorobject.Theistream_iteratorclass defines the following operators:–>,*,++. The operators==and!=are also defined for objects of type
istream_iterator.Here is a short program that demonstrates
istream_iterator. It reads and displays
characters from
cinuntil a period is received.
// Use istream_iterator#include <iostream>
#include <iterator>
using namespace std;int main(){istream_iterator<char> in_it(cin);do {cout << *in_it++;} while (*in_it != '.');
return 0;}istreambuf_iterator
Theistreambuf_iteratorclass supports character input iterator operations on a stream.
Its template definition is shown here:
template <class CharType, class Attr = char_traits<CharType> >class istreambuf_iterator:public iterator<input_iterator_tag, CharType, typename Attr::off_type,CharType *, CharType &>Here,
CharType
isthecharactertype(
charorwchar_t)thatthestreamisoperatingupon.
istreambuf_iteratorhas the following constructors:
istreambuf_iterator( ) throw( );
istreambuf_iterator(istream_type &stream) throw( );
istreambuf_iterator(streambuf_type *streambuf) throw( );870C++:TheCompleteReference
Thefirstconstructorcreatesaniteratortoanemptystream.Thesecondcreatesaniterator
to the stream specified by
stream
. The typeistream_typeis atypedefthat specifies thetype of the input stream. The third form creates an iterator using the stream buffer

specified bystreambuf
.Theistreambuf_iteratorclass defines the following operators:*,++. The operators==and!=are also defined for objects of type
istreambuf_iterator.istreambuf_iteratordefines the member functionequal( ), which is shown here:
bool equal(istreambuf_iterator<CharType, Attr> &ob);Its operation is a bit counterintuitive. It returns
trueif the invoking iterator andobbothpoint to the end of the stream. It also returns
trueif both iterators do not point to theendofthestream.Thereisnorequirementthatwhattheypointtobethesame.Itreturns

falseotherwise. The==and!=operators work in the same fashion.ostream_iterator
Theostream_iteratorclass supports output iterator operations on a stream. Its template
definition is shown here:
template <class T, class CharType, class Attr = char_traits<CharType> >
class ostream_iterator:public iterator<output_iterator_tag, void, void, void, void>Here,
Tis the type of data being transferred,
CharType
is the character type (charorwchar_t) that the stream is operating upon.
ostream_iteratorhas the followingconstructors:
ostream_iterator(ostream_type &stream);
ostream_iterator(ostream_type &stream, const CharType *delim);ostream_iterator(const ostream_iterator<T, CharType, Attr> &ob);The first creates an iterator to the stream specified by
stream
. The typeostream_typeisatypedefthatspecifiesthetypeoftheoutputstream.Thesecondformcreatesan
iterator to the stream specified by
stream
and uses the delimiters specified bydelim. Thedelimiters are written to the stream after every output operation. The third form creates

a copy of anostream_iteratorobject.Theostream_iteratorclass defines the following operators:=, *,++.Here is a short program that demonstrates
ostream_iterator.Chapter35:STLIterators,Allocators,andFunctionObjects
871THESTANDARDC++
CLASSLIBRARY
// Use ostream_iterator#include <iostream>
#include <iterator>
using namespace std;int main(){ostream_iterator<char> out_it(cout);*out_it = 'X';out_it++;
*out_it = 'Y';
out_it++;
*out_it = ' ';char str[] = "C++ Iterators are powerful.\n";char *p = str;while(*p) *out_it++ = *p++;
ostream_iterator<double> out_double_it(cout);*out_double_it = 187.23;
out_double_it++;
*out_double_it = -102.7;return 0;}The output from this program is shown here:
XY C++ Iterators are powerful.187.23-102.7ostreambuf_iterator
Theostreambuf_iteratorclasssupportscharacteroutputiteratoroperationsonastream.
Itstemplatedefinitionisshownhere:
template <class CharType, class Attr = char_traits<CharType> >class ostreambuf_iterator:public iterator<output_iterator_tag, void, void, void, void>872C++:TheCompleteReference
Here,
CharType
isthecharactertype(
charorwchar_t)thatthestreamisoperatingupon.
ostreambuf_iteratorhas the following constructors:
ostreambuf_iterator(ostream_type &stream) throw( );ostreambuf_iterator(streambuf_type *streambuf) throw( );The first creates an iterator to the stream specified by
stream
. The typeostream_typeisatypedefthatspecifiesthetypeoftheinputstream.Thesecondformcreatesaniterator
using the stream buffer specified by
streambuf
. The typestreambuf_typeis atypedefthat specifies the type of the stream buffer.
Theostreambuf_iteratorclassdefinesthefollowingoperators:
=,*,++.Themember
functionfailed()
isalsodefinedasshownhere:
bool failed( ) const throw( );It returns
falseif no failure has occurred and
trueotherwise.Two Iterator Functions
There are two special functions defined for iterators:
advance( )anddistance( ). Theyare shown here:
template <class InIter, class Dist> void advance(InIter &itr, Distd);template <class InIter> ptrdiff_t distance(InIterstart, InIterend);Theadvance( )function increments
itrby the amount specified byd. Thedistance( )function returns the number of elements between
startandend.Thereasonforthesetwofunctionsisthatonlyrandom-accessiteratorsallowavalue
to be added to or subtracted from an iterator. The
advance( )anddistance( )functionsovercome this restriction. It must be noted, however, that some iterators will not be

able to implement these functions efficiently.
Function ObjectsFunctionobjectsareclassesthatdefine
operator()
.TheSTLdefinesseveralbuilt-in
functionobjectsthatyourprogramsmayuse.Youcanalsodefineyourownfunction

objects.Supportforfunctionobjectsisinthe
<functional>header.Alsodefinedin
<functional>areseveralentitiesthatsupportfunctionobjects.Thesearebinders,
negators, and adaptors. Each is described here.
Refer to Chapter 24 for an overview of function objects.Function ObjectsFunction objects come in two varieties: binary and unary. The built-in binary function
objects are shown here:
plusminus
multipliesdividesmodulus
equal_tonot_equal_togreatergreater_equalless
less_equallogical_andlogical_or
Here are the built-in unary function objects.
logical_notnegate
The general form for invoking a function object is shown here:
func_ob<type>( )For example,less<int>()invokesless( )relative to operands of type
int.Abase class for all binary function objects is
binary_function, shown here:
template <class Argument1, class Argument2, class Result>struct binary_function {typedef Argument1 first_argument_type;
typedef Argument2 second_argument_type;
typedef Result result_type;};The base class for all unary functions isunary_function, shown here:
template <class Argument, class Result> struct unary_function {typedef Argument argument_type;
typedef Result result_type;};These template classes provide concrete type names for the generic data types used
by the function object. Although they are technically a convenience, they are almost
always used when creating function objects.
Chapter35:STLIterators,Allocators,andFunctionObjects
873THESTANDARDC++
CLASSLIBRARY
874C++:TheCompleteReference
The templatespecificationsforallbinaryfunctionobjectsaresimilar,andthetemplate
specificationsforallunaryfunctionobjectsaresimilar.Hereareexamplesofeach:
template <class T> struct plus : binary_function<T, T, T>{T operator() (const T &arg1, const T&arg2) const;};template <class T> struct negate : unary_function<T, T>{T operator() (const T &arg) const;};Eachoperator( )function returns the specified result.
BindersBinders bind a value to an argument of a binary function object, producing a unary
function object. There are two binders:
bind2nd( )andbind1st( ). Here is how they
are defined:
template <class BinFunc, class T>binder1st<BinFunc> bind1st(const BinFunc &op, const T &value);template <class BinFunc, class T>binder2nd<BinFunc> bind2nd(const BinFunc &op, const T &value);Here,
opisabinaryfunctionobject,suchas
less()
orgreater()
,thatprovidesthedesired
operation,and
valueisthevaluebeingbound.
bind1st()
returnsaunaryfunctionobject
that hasop's left-hand operand bound tovalue.bind2nd( )returns a unary function
object that hasop's right-hand operand bound tovalue. Thebind2nd( )binder is by farthe most commonly used. In either case, the outcome of a binder is a unary function
object that is bound to the value specified.Thebinder1standbinder2ndclasses are shown here:
template <class BinFunc> class binder1st:public unary_function(typename BinFunc::second_argument_type,typename BinFunc::result_type>{protected:BinFunc op;
typename BinFunc::first_argument_type value;public:Chapter35:STLIterators,Allocators,andFunctionObjects
875THESTANDARDC++
CLASSLIBRARY
binder1st(const BinFunc &op,const typename BinFunc::first_argument_type &v);result_type operator()(const argument_type &v) const;};template <class BinFunc> class binder2nd:public unary_function(typename BinFunc::first_argument_type,typename BinFunc::result_type>{protected:BinFunc op;
typename BinFunc::second_argument_type value;public:binder2nd(const BinFunc &op,const typename BinFunc::second_argument_type &v);result_type operator()(const argument_type &v) const;};Here,
BinFuncis the type of a binary function object. Notice that both classes inheritunary_function. This is why the resulting object of
bind1st( )andbind2nd( )can beused anywhere that a unary function can be.
NegatorsNegators return predicates that yield the opposite of whatever predicate they modify.
The negators are
not1( )andnot2( ). They are defined like this:
template <class UnPred> unary_negate<UnPred> not1(const UnPred &pred);template <class BinPred> binary_negate<BinPred> not2(const BinPred &pred);The classes are shown here:
template <class UnPred> class unary_negate:public unary_function<typename UnPred::argument_type, bool>{public:explicit unary_negate(const UnPred &pred);bool operator()(const argument_type &v) const;};template <class BinPred> class binary_negate:876C++:TheCompleteReference
public binary_function<typename BinPred::first_argument_type,typename BinPred::second_argument_type,bool>{public:explicit binary_negate(const BinPred &pred);bool operator()(const first_argument_type &v1,const second_argument_type &v2) const;};In both classes,operator( )returns the negation of the predicate specified by
pred
.AdaptorsThe header<functional>defines several classes calledadaptorsthat allow you to adapta function pointer to a form that can be used by the STL. For example, you can use anadaptor to allow a function such asstrcmp( )to be used as a predicate. Adaptors also
exist for member pointers.The Pointer-to-Function AdaptorsThe pointer-to-function adaptors are shown here:
template <class Argument, class Result>pointer_to_unary_function<Argument, Result>ptr_fun(Result (*func)(Argument));template <class Argument1, class Argument2, class Result>pointer_to_binary_function<Argument1, Argument2, Result>ptr_fun(Result (*func)(Argument1, Argument2));Here,
ptr_fun( )returns either an object of type
pointer_to_unary_functionorpointer_to_binary_function. These classes are shown here:
template <class Argument, class Result>class pointer_to_unary_function:public unary_function<Argument, Result>{
public:explicit pointer_to_unary_function(Result (*func)(Argument));
Result operator()(Argumentarg) const;};Chapter35:STLIterators,Allocators,andFunctionObjects
877THESTANDARDC++
CLASSLIBRARY
template <class Argument1, class Argument2, class Result>class pointer_to_binary_function:public binary_function<Argument1, Argument2, Result>{public:explicit pointer_to_binary_function(Result (*func)(Argument1, Argument2));Result operator()(Argument1arg1, Argument2arg2) const;};For unary functions,operator( )returns
func(arg).For binary functions,operator( )returns
func(arg1,arg2);The type of the result of the operation is specified by the
Resultgeneric type.The Pointer-to-Member Function AdaptorsThe pointer-to-member function adaptors are shown here:
template<class Result, class T>mem_fun_t<Result, T> mem_fun(Result (T::*func)( ));template<class Result, class T, class Argument>mem_fun1_t<Result, T, Argument>mem_fun1(Result (T::*func)(Argument));Here,
mem_fun()
returnsanobjectoftype
mem_fun_t,andmem_fun1()
returnsan
objectoftype
mem_fun1_t.Theseclassesareshownhere:
template <class Result, class T> class mem_fun_t:public unary_function<T *, Result> {public:explicit mem_fun_t(Result (T::*func)());Result operator() (T *func) const;};template <class Result, class T,class Argument> class mem_fun1_t:public binary_function<T *, Argument, Result> {public:explicit mem_fun1_t(Result (T::*func)(Argument));Result operator() (T *func, Argumentarg) const;};Here, the
mem_fun_tconstructor calls the member function specified as its parameter.
Themem_fun1_tconstructor calls the member function specified as its first parameter,
passing a value of typeArgumentas its second parameter.
There are parallel classes and functions for using references to members. The
general form of the functions is shown here:
template<class Result, class T>mem_fun_ref_t<Result, T> mem_fun_ref(Result (T::*func)( ));template<class Result, class T, class Argument>mem_fun1_ref_t<Result, T, Argument>mem_fun1_ref(Result (T::*func)(Argument));The classes are shown here:
template <class Result, class T> class mem_fun_ref_t:public unary_function<T, Result>{public:explicit mem_fun_ref_t(Result (T::*func)());Result operator()(T &func) const;};template <class Result, class T, class Argument>class mem_fun1_ref_t:public binary_function<T, Result, Argument>{public:explicit mem_fun1_ref_t(Result (T::*func)(Argument));Result operator()(T &func, Argumentarg) const;};878C++:TheCompleteReference
Chapter35:STLIterators,Allocators,andFunctionObjects
879THESTANDARDC++
CLASSLIBRARY
AllocatorsAn allocator manages memory allocation for a container. Since the STLdefines a
default allocator that is automatically used by the containers, most programmers will

never need to know the details about allocators or create their own. However, these

details are useful if you are creating your own library classes, etc.
All allocators must satisfy several requirements. First, they must define the
following types:const_pointerA
constpointer to an object of typevalue_type.const_referenceA
constreference to an object of type
value_type.difference_typeCan represent the difference between two addresses.
pointerApointer to an object of type
value_type.referenceAreference to an object of type
value_type.size_typeCapable of holding the size of the largest possible object that
can be allocated.value_typeThe type of object being allocated.
Second, they must provide the following functions.
address
Returns a pointer given a reference.
allocateAllocates memory.
deallocateFrees memory.
max_sizeReturns the maximum number of objects that can be allocated.

constructConstructs an object.

destroy
Destroys an object.
The operations==and!=must also be defined.The default allocator isallocator, and it is defined within the header<memory>. Itstemplate specification is shown here:
template <class T> class allocatorHere,
Tisthetypeofobjectsthat
allocatorwillbeallocating.
allocatordefinesthefollowing
constructors:
allocator( ) throw( );allocator(const allocator<T> &ob) throw( );The first creates a new allocator. The second creates a copy of
ob.The operators == and != are defined for
allocator. The member functions defined byallocatorare shown in Table 35-2.
One last point: Aspecialization of
allocatorforvoid *pointers is also defined.880C++:TheCompleteReference
FunctionDescriptionpointer address(reference
ob) const;const_pointer address(const_reference
ob) const;Returns the address of
ob.pointer allocate(size_typenum,allocator<void>::const_pointerh= 0);Returns a pointer toallocated memory that is
large enough to hold
numobjects of type T. The value

ofhis a hint to the functionthat can be used to help
satisfy the request or

ignored.
void construct(pointer
ptr, const_reference
val);Constructs an object of type
T with the value specified by
valatptr.void deallocate(pointerptr, size_typenum);Deallocates
numobjects oftype T starting atptr. Thevalue ofptrmust have beenobtained from
allocate( ).void destroy(pointer
ptr);Destroys the object at
ptr.
Its destructor is

automatically called.size_type max_size( ) const throw( );
Returns the maximumnumber of objects of type T
that can be allocated.Table35-2.
Member Functions ofallocatorChapter36
The String Class881Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
882C++:TheCompleteReference
This chapter describes the Standard C++ string class. C++ supports characterstringstwoways.Thefirstisasanull-terminatedcharacterarray.Thisissometimes

referred to as aC string. The second way is as a class object of typebasic_string.There are two specializations ofbasic_string:string, which supportscharstrings, andwstring, which supportswchar_t(wide character) strings. Most often, you will usestring objects of typestring.Thebasic_stringclass is essentially a container. This means that iterators and the
STLalgorithms can operate on strings. However, strings have additional capabilities.
Aclass used by
basic_stringischar_traits, which defines several attributes of thecharactersthatcompriseastring.Itisimportanttounderstandthatwhilethemost

commonstringsaremadeupofeither
charorwchar_tcharacters,basic_stringcanoperate on any object that can be used to represent a text character. Both
basic_stringandchar_traitsare described here.
For an overview of using the string class, refer to Chapter 24.
The basic_string ClassThe template specification forbasic_stringistemplate <class CharType, class Attr = char_traits<CharType>,class Allocator = allocator<T> > class basic_stringHere,
CharType
is the type of character being used,Attris the class that describes thecharacter's traits, andAllocatorspecifies the allocator.
basic_stringhas the followingconstructors:
explicit basic_string(const Allocator &a= Allocator( ));basic_string(size_typelen, CharTypech,const Allocator &a= Allocator( ));basic_string(const CharType *str,  const Allocator&a= Allocator( ));basic_string(const CharType *str, size_typelen,const Allocator &a= Allocator( ));basic_string(const basic_string &str, size_typeindx= 0,size_typelen=npos, const Allocator &a =Allocator( ));template <class InIter> basic_string(InIterstart, InIterend,const Allocator &a= Allocator( ));Thefirstformconstructsanemptystring.Thesecondformconstructsastringthathas

lencharactersofvalue
ch.Thethirdformconstructsastringthatcontainsthesame
elementsas
str.Thefourthformconstructsastringthatcontainsasubstringof
strthatbeginsatzeroandis
lencharacterslong.Thefifthformconstructsastringfromanother
basic_stringusingthesubstringthatbeginsat
indxthatis
lencharacterslong.Thesixth
formconstructsastringthatcontainstheelementsintherangespecifiedby
startandend.The following comparison operators are defined for
basic_string:==, <, <=, !=, >, >=Also defined is the+operator, which yields the result of concatenating one string with
another,andtheI/Ooperators
<<and>>,whichcanbeusedtoinputandoutputstrings.
The+operator can be used to concatenate a string object with another string objector a string object with a C-style string. That is, the following variations are supported:
string + stringstring + C-string
C-string + stringThe + operator can also be used to concatenate a character onto the end of a string.Thebasic_stringclassdefinestheconstant
npos,whichis–1.Thisconstant
represents the length of the longest possible string.
Inthedescriptions,thegenerictype
CharType
representsthetypeofcharacterstored
byastring.Sincethenamesoftheplaceholdertypesinatemplateclassarearbitrary,

basic_stringdeclares
typedefedversionsofthesetypes.Thismakesthetypenames
concrete. The types defined by
basic_stringare shown here:
size_typeSome integral type loosely equivalent tosize_t.referenceAreference to a character within a string.
const_referenceAconstreference to a character within a string.
iteratorAn iterator.
const_iteratorAconstiterator.
reverse_iteratorAreverse iterator.
const_reverse_iteratorAconstreverse iterator.
value_typeThe type of character stored in a string.
allocator_typeThe type of the allocator.
pointerApointer to a character within a string.
const_pointerAconstpointer to a character within a string.traits_typeAtypedefforchar_traits<CharType>
difference_type
Atype that can store the difference between two

addresses.
Chapter36:TheStringClass
883THESTANDARDC++
CLASSLIBRARY
The member functions defined bybasic_stringare shown in Table 36-1. Since the
vast majority of programmers will be using
charstrings (and to keep the descriptionseasy-to-understand),thetableusesthetype
string,butthefunctionsalsoapplytoobjects
of typewstring(or any other type ofbasic_string).884C++:TheCompleteReference
MemberDescriptionstring &append(const string &str);Appendsstronto the end of theinvoking string. Returns*this.string &append(const string &str,size_typeindx,size_typelen);Appends a substring ofstronto theend of the invoking string. Thesubstring being appended begins at
indxand runs for
lencharacters.Returns*this.string &append(const CharType *
str);Appends
stronto the end of theinvoking string. Returns*this.string &append(const CharType *
str,size_typenum);Appends the firstnumcharactersfrom
stronto the end of the invokingstring. Returns*this.string &append(size_typelen, CharType
ch);Appends
lencharacters specified bychonto the end of the invokingstring. Returns*this.template<class InIter>string &append(InIterstart,InIterend);Appends the sequence specified by
startandendonto the end of theinvoking string. Returns*this.string &assign(const string &str);Assignsstrto the invoking string.Returns*this.string &assign(const string &str,size_typeindx,size_typelen);Assigns a substring ofstrto theinvoking string. The substring being
assigned begins atindxand runs for
lencharacters. Returns*this.string &assign(const CharType *str);Assigns
strto the invoking string.Returns*this.Table36-1.
The String Member FunctionsChapter36:TheStringClass
885THESTANDARDC++
CLASSLIBRARY
MemberDescriptionstring &assign(const CharType *
str,size_typelen);Assigns the firstlencharactersfrom
strto the invoking string.Returns*this.string &assign(size_typelen, CharType
ch);Assigns
lencharacters specified bychto the end of the invoking string.Returns*this.template<class InIter>string &assign(InIterstart, InIterend);Assigns the sequence specified bystartandendto the invoking string.Returns*this.reference at(size_type
indx);const_reference at(size_type
indx) const;Returns a reference to the character

specified byindx.iterator begin( );
const_iterator begin( ) const;Returns an iterator to the first
element in the string.const CharType *c_str( ) const;
Returns a pointer to a C-style(i.e., null-terminated) version
of the invoking string.size_type capacity( ) const;Returns the current capacity of
thestring.Thisisthenumber

of characters it can hold before it

will need to allocate more memory.
int compare(const string &
str) const;Compares
strto the invoking string.It returns one of the following:

Less than zero if
*this<strZero if
*this==strGreater than zero if
*this>strint compare(size_type
indx, size_typelen,const string &str) const;Compares
strto a substring withinthe invoking string. The substring
begins atindxand islencharacterslong. It returns one of the following:

Less than zero if *
this<strZero if *
this==strGreater than zero if *
this>strTable36-1.
The String Member Functions(continued)886C++:TheCompleteReference
MemberDescriptionint compare(size_type
indx, size_typelen,const string &str,
size_typeindx2,size_typelen2) const;Compares a substring of
strto asubstring within the invoking string.The substring in the invoking string
begins atindxand islencharacterslong. The substring instrbeginsatindx2and islen2characters long.It  returns one of the following:

Less than zero if *
this<strZero if *
this==strGreater than zero if *
this>strint compare(const CharType *
str) const;Compares
strto the invoking string.It returns one of the following:

Less than zero if
*this<strZero if
*this==strGreater than zero if
*this>strint compare(size_type
indx, size_typelen,const CharType *
str,
size_typelen2= npos) const;Compares a substring of
strto asubstring within the invoking string.
The substring in the invoking string
begins atindxand islencharacterslong. The substring instrbeginsat zero and is
len2characters long.It  returns one of the following:

Less than zero if
*this<strZero if
*this==strGreater than zero if
*this>strsize_type copy(CharType *
str,size_typelen,size_typeindx= 0) const;Beginning atindx, copieslencharacters from the invokingstring into the character array
pointed to bystr. Returns thenumber of characters copied.const CharType *data( ) const;
Returns a pointer to the firstcharacter in the invoking string.bool empty( ) const;Returnstrueif the invoking stringis empty andfalseotherwise.Table36-1.
The String Member Functions(continued)Chapter36:TheStringClass
887THESTANDARDC++
CLASSLIBRARY
MemberDescriptioniterator end( );const_iterator end( ) const;Returns an iterator to the end of
the string.iterator erase(iteratori);Removes character pointed to byi.Returns an iterator to the character
after the one removed.
iterator erase(iteratorstart, iteratorend);Removes characters in the range
starttoend. Returns an iterator to thecharacter after the last character
removed.
string &erase(size_typeindx= 0,size_typelen= npos);Beginning atindx, removes
lencharacters from the invoking string.

Returns*this.size_type find(const string &str,size_typeindx= 0) const;Returns the index of the first
occurrence of
strwithin the invokingstring. The search begins at index

indx.nposis returned if no match is
found.size_type find(const CharType *
str,size_typeindx= 0) const;Returns the index of the first
occurrence of
strwithin the invokingstring. The search begins at index

indx.nposis returned if no match is
found.size_type find(const CharType *
str,size_typeindx,size_typelen) const;Returns the index of the first
occurrence of the first
lencharactersofstrwithin the invoking string. Thesearch begins at index
indx.nposisreturned if no match is found.
size_type find(CharType
ch,size_typeindx= 0) const;Returns the index of the first
occurrence of
chwithin the invokingstring. The search begins at index

indx.nposis returned if no match
is found.Table36-1.
The String Member Functions(continued)888C++:TheCompleteReference
MemberDescriptionsize_type find_first_of(const string &str,size_typeindx= 0) const;Returns the index of the firstcharacter within the invoking string
that matches any character instr.
Thesearch begins at index
indx.nposisreturned if no match is found.
size_type find_first_of(const CharType *
str,size_typeindx= 0) const;Returnstheindexofthefirst

characterwithintheinvokingstring

thatmatchesanycharacterin
str.
Thesearchbeginsatindex
indx.nposisreturnedifnomatchisfound.
size_type find_first_of(const CharType *
str,size_typeindx,size_typelen) const;Returns the index of the first
character within the invoking string
that matches any character in the
firstlencharacters ofstr.
The search
begins at indexindx.nposisreturned if no match is found.
size_type find_first_of(CharType
ch,size_typeindx= 0) const;Returns the index of the first
occurrence of
chwithin the invokingstring. The search begins at index

indx.nposis returned if no match
is found.size_type find_first_not_of(const string &str,
size_typeindx= 0) const;Returns the index of the first
character within the invoking string
that does not match any character in
str.
The search begins at index
indx.nposis returned if no mismatch
is found.size_type find_first_not_of(const CharType *
str,size_typeindx= 0) const;Returns the index of the first
character within the invoking string
that does not match any character in
str.
The search begins at index
indx.nposis returned if no mismatch
is found.Table36-1.
The String Member Functions(continued)Chapter36:TheStringClass
889THESTANDARDC++
CLASSLIBRARY
MemberDescriptionsize_type find_first_not_of(const CharType *
str,size_typeindx,size_typelen) const;Returns the index of the firstcharacter within the invoking string
that does not match any character in
the firstlencharacters ofstr.
Thesearch begins at index
indx.nposisreturned if no mismatch is found.
size_type find_first_not_of(CharType
ch,size_typeindx= 0) const;Returns the index of the first
character within the invoking string
that does not matchch. The search
begins at indexindx.nposisreturned if no mismatch is found.
size_type find_last_of(const string &str,size_typeindx= npos) const;Returnstheindexofthelastcharacter

withintheinvokingstringthat

matchesanycharacterin
str.
Thesearchendsatindex
indx.nposisreturnedifnomatchisfound.
size_type find_last_of(const CharType *
str,size_typeindx= npos) const;Returnstheindexofthelastcharacter

withintheinvokingstringthat

matchesanycharacterin
str.
Thesearchendsatindex
indx.nposisreturnedifnomatchisfound.
size_type find_last_of(const CharType *
str,size_typeindx,size_typelen) const;Returns the index of the last
character within the invoking string
that matches any character in the
firstlencharacters ofstr.
The search
ends at indexindx.nposis returned
if no match is found.size_type find_last_of(CharType
ch,size_typeindx= npos) const;Returns the index of the last
occurrence of
chwithin the invokingstring. The search ends at indexindx.nposis returned if no match
is found.Table36-1.
The String Member Functions(continued)890C++:TheCompleteReference
MemberDescriptionsize_type find_last_not_of(const string &str,size_typeindx= npos) const;Returnstheindexofthelastcharacter

withintheinvokingstringthatdoes

notmatchanycharacterin
str.
Thesearchendsatindex
indx.nposisreturnedifnomismatchisfound.
size_type find_last_not_of(const CharType *
str,size_typeindx= npos) const;Returnstheindexofthelastcharacter

withintheinvokingstringthatdoes

notmatchanycharacterin
str.
Thesearchendsatindex
indx.nposisreturnedifnomismatchisfound.
size_type find_last_not_of(const CharType *
str,size_typeindx,size_typelen) const;Returns the index of the last
character within the invoking string
that does not match any character in
the firstlencharacters ofstr.
Thesearch ends at index
indx.nposisreturned if no mismatch is found.
size_type find_last_not_of(CharType
ch,size_typeindx= npos) const;Returns the index of the last
character within the invoking string
that does not matchch. The search
ends at indexindx.nposis returned
if no mismatch is found.allocator_type get_allocator( ) const;Returns the string's allocator.
iterator insert(iteratori,const CharType &
ch);Insertschimmediately before the
character specified byi.An iteratorto the character is returned.
string &insert(size_typeindx,const string &str);Insertsstrinto the invoking string atthe index specified byindx. Returns*this.string &insert(size_typeindx1,const string &str,size_typeindx2,size_typelen);Inserts a substring ofstrinto theinvoking string at the index specified
byindx1. The substring begins atindx2and islencharacters long.Returns*this.Table36-1.
The String Member Functions(continued)THESTANDARDC++
CLASSLIBRARY
Chapter36:TheStringClass
891MemberDescriptionstring &insert(size_typeindx,const CharType *
str);Insertsstrinto the invoking stringat the index specified byindx.Returns*this.string &insert(size_typeindx,const CharType *
str,size_typelen);Inserts the firstlencharacters ofstrinto the invoking string at the indexspecified byindx. Returns*this.string &insert(size_typeindx,size_typelen,CharType
ch);Insertslencharacters of valuechinto the invoking string at the index
specified byindx. Returns*this.void insert(iteratori, size_typelen,const CharType &
ch)Insertslencopies ofchimmediatelybefore the element specified by
i.template <class InIter>void insert(iteratori, InIterstart,InIterend);Inserts the sequence defined by
startandendimmediately before
the element specified byi.size_type length( ) const;Returns the number of charactersin the string.size_type max_size( ) const;Returns the maximum number ofcharacters that the string can hold.reference operator[ ](size_type
indx) const;const_reference operator[ ](size_type
indx)const;Returns a reference to the character

specified byindx.string &operator=(const string &str);string &operator=(const CharType *str);string &operator=(CharType
ch);Assigns the specified string or
character to the invoking string.
Returns*this.string &operator+=(const string &str);
string &operator+=(const CharType *
str);string &operator+=(CharType
ch);Appends the specified string
or character onto the end of the
invoking string. Returns*this.void push_back (const CharType
ch)reverse_iterator rbegin( );

const_reverse_iterator rbegin( ) const;
Addschto the end of theinvoking string.Returns a reverse iterator to
the end of the string.reverse_iterator rend( );

const_reverse_iterator rend( ) const;
Returns a reverse iterator to

the start of the string.Table36-1.
The String Member Functions(continued)892C++:TheCompleteReference
MemberDescriptionstring &replace(size_type
indx,size_typelen,const string &str);Replaces up tolencharacters in theinvoking string, beginning atindxwith the string instr. Returns*this.string &replace(size_type
indx1,size_typelen1,const string &str,
size_typeindx2,size_typelen2);Replaces up tolen1characters in theinvoking string beginning atindx1with thelen2characters from the
string instrthat begins atindx2.Returns*this.string &replace(size_type
indx,size_typelen,const CharType *
str);Replaces up tolencharacters in theinvoking string, beginning atindxwith the string instr. Returns*this.string &replace(size_type
indx,size_typelen1,const CharType *
str,
size_typelen2);Replaces up tolen1characters in theinvoking string beginning atindxwith thelen2characters from the
string instr. Returns*this.string &replace(size_type
indx,size_typelen1,size_typelen2,CharTypech);Replaces up tolen1characters in theinvoking string beginning atindxwithlen2characters specified bych.Returns*this.string &replace(iterator
start,iteratorend,const string &str);Replaces the range specified bystartandendwithstr. Returns*this.string &replace(iterator
start,iteratorend,const CharType *
str);Replaces the range specified bystartandendwithstr. Returns*this.string &replace(iterator
start,iteratorend,const CharType *s
tr,
size_typelen);Replaces the range specified bystartandendwith the firstlencharactersfrom
str. Returns*this.string &replace(iterator
start,interatorend, size_typelen,CharType
ch);Replaces the range specified bystartandendwith thelencharactersspecified bych. Returns*this.Table36-1.
The String Member Functions(continued)Chapter36:TheStringClass
893THESTANDARDC++
CLASSLIBRARY
MemberDescriptiontemplate <class InIter>string &replace(iterator
start1,interatorend1,InIterstart2,InIterend2);Replaces the range specified bystart1andend1with the charactersspecified bystart2andend2.Returns*this.void reserve(size_type
num= 0);Sets the capacity of the string so that
it is equal to at leastnum.void resize(size_type
num)void resize(size_type
num, CharType
ch);Changes the size of the string to that
specified bynum. If the string mustbe lengthened, then elements with
the value specified bychare added
to the end.size_type rfind(const string &str,size_typeindx= npos) const;Returns the index of the last
occurrence of
strwithin the invokingstring. The search ends at index
indx.nposis returned if no match
is found.size_type rfind(const CharType *
str,size_typeindx= npos) const;Returns the index of the last
occurrence of
strwithin the invokingstring. The search ends at index
indx.nposis returned if no match
is found.size_type rfind(const CharType *
str,size_typeindx,size_typelen) const;Returns the index of the last
occurrence of the first
lencharactersofstrwithin the invoking string. Thesearch ends at index
indx.nposisreturned if no match is found.
size_type rfind(CharType
ch,size_typeindx= npos) const;Returns the index of the last
occurrence ofchwithin the invokingstring. The search ends at index
indx.nposis returned if no match
is found.size_type size( ) const;Returns the number of characters
currently in the string.
Table36-1.
The String Member Functions(continued)894C++:TheCompleteReference
The char_traits ClassTheclass
char_traitsdescribesseveralattributesassociatedwithacharacter.Itstemplate
specificationisshownhere:
template<class CharType> struct char_traitsHere,
CharType
specifies the type of the character.
The C++ library provides two specializations of
char_traits: one forcharcharactersandonefor
wchar_tcharacters.The
char_traitsclassdefinesthefollowingfive
data types:char_typeThe type of the character. This is a
typedefforCharType
.int_typeAn integer type that can hold a character of typechar_typeorthe EOF character.
off_type
An integer type that can represent an offset in a stream.
pos_typeAn integer type that can represent a position in a stream.
state_typeAn object type that stores the conversion state. (Applies to
multibyte characters.)The member functions ofchar_traitsare shown in Table 36-2.
MemberDescriptionstring substr(size_typeindx= 0,size_typelen= npos) const;Returns a substring oflencharactersbeginning atindxwithin theinvoking string.void swap(string &str)Exchanges the characters stored in
the invoking string with those inob.Table36-1.
The String Member Functions(continued)Chapter36:TheStringClass
895THESTANDARDC++
CLASSLIBRARY
MemberDescriptionstatic void assign(char_type &ch1,const char_type &ch2);Assignsch2toch1.static char_type *assign(char_type *str,size_tnum,char_typech2);Assignsch2to the firstnumcharacters instr. Returnsstr.static int compare(const char_type *
str1,const char_type *str2,size_tnum);Compares
numcharacters instr1to those instr2. Returnszero if the strings are same.

Otherwise, returns less than

zero if
str1is less thanstr2orgreater than zero if
str1isgreater than
str2.static char_type *copy(char_type *to,const char_type *from
,size_tnum);Copiesnumcharacters from
from
toto. Returnsto.static int_type eof( );Returns the end-of-file
character.
static bool eq(const char_type &ch1,const char_type &ch2);Compares
ch1toch2andreturns
trueif the charactersare the same and
falseotherwise.static bool eq_int_type(const int_type &ch1,const int_type &ch2);Returnstrueifch1equalsch2andfalseotherwise.static const char_type *find(const char_type *str,size_tnum,const char_type *ch);Returns a pointer to the first
occurrence ofchinstr. Onlythe firstnumcharacters are
examined. Returns a null
pointer on failure.
static size_t length(const char_type *str);Returns the length ofstr.static bool lt(const char_type &ch1,const char_type &ch2);Returnstrueifch1is lessthanch2andfalseotherwise.Table36-2.
Thechar_traitsMember Functions896C++:TheCompleteReference
MemberDescriptionstatic char_type *move(char_type *to,const char_type *from
,size_tnum);Copiesnumcharacters from
from
toto. Returnsto.static int_type not_eof(const int_type &ch);If
chis not the EOF character,
thenchis returned.
Otherwise, the EOF characteris returned.
static char_type to_char_type(const int_type &ch);Converts
chinto achar_typeand returns the result.
static int_type to_int_type(const char_type &ch);Converts
chinto anint_typeand returns the result.
Table36-2.
Thechar_traitsMember Functions(continued)Chapter37
The Numeric Classes897Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
898C++:TheCompleteReference
One of the features added during the standardization of C++ is the numeric classlibrary. These classes aid in the development of numerical programs. Several of
thememberfunctionsoftheseclassesparallelthestand-alonefunctionsinherited
from the C library. The difference is that many of the numeric functions described here
operate on objects of typevalarray, which is essentially an array of values, or on objectsof typecomplex, which represent complex numbers. By including the numeric classes,StandardC++hasexpandedthescopeofprogrammingtaskstowhichitcanbe

conveniently applied.The complex ClassThe header<complex>defines thecomplexclass, which represents complex numbers.
Italsodefinesaseriesoffunctionsandoperatorsthatoperateonobjectsoftype
complex.The template specification forcomplexis shown here:
template <class T> class complexHere,
Tspecifies the type used to store the components of a complex number. There are
three predefined specializations of
complex:class complex<float>
class complex<double>
class complex<long double>Thecomplexclass has the following constructors:
complex(const T &real= T( ), const T &imaginary= T( ));complex(const complex &ob);
template <class T1> complex(const complex<T1> &ob);The first constructs a
complexobject with a real component of
real
and an imaginarycomponentof
imaginary.Thesevaluesdefaulttozeroifnotspecified.Thesecondcreates
a copy ofob. The third creates a
complexobject from
ob.The following operations are defined for
complexobjects:+−*/−=+=/=*====!
=Chapter37:TheNumericClasses
899THESTANDARDC++
CLASSLIBRARY
Thenonassignmentoperatorsareoverloadedthreeways.Onceforoperationsinvolving
acomplexobjectontheleftandascalarobjectontheright,againforoperationsinvolvinga
scalarontheleftanda
complexobjectontheright,andfinallyforoperationsinvolvingtwo
complexobjects.Forexample,thefollowingtypesofoperationsareallowed:
complex_ob + scalar
scalar + complex_ob
complex_ob + complex_obOperations involving scalar quantities affect only the real component.
Two member functions are defined for
complex:real( )andimag( ). They are
shown here:
T real( ) const;
T imag( ) const;Thereal( )function returns the real component of the invoking object, and
imag( )returns the imaginary component. The functions shown in Table 37-1 are also defined

forcomplexobjects.Here is a sample program that demonstrates
complex.// Demonstrate complex.#include <iostream>
#include <complex>
using namespace std;int main(){complex<double> cmpx1(1, 0);
complex<double> cmpx2(1, 1);cout << cmpx1 << " " << cmpx2 << endl;
complex<double> cmpx3 = cmpx1 + cmpx2;cout << cmpx3 << endl;cmpx3 += 10;cout << cmpx3 << endl;return 0;}Its output is shown here:
(1,0) (1,1)(2,1)
(12,1)900C++:TheCompleteReference
FunctionDescriptiontemplate <class T>T abs(const complex<T> &ob);Returns the absolute value ofob.template <class T>T arg(const complex<T> &
ob);Returns the phase angle ofob.template <class T> complex<T>conj(const complex<T> &ob);Returns the conjugate ofob.template <class T>complex<T> cos(const complex<T> &ob);Returns the cosine ofob.template <class T>complex<T>cosh(const complex<T> &ob);Returns the hyperbolic cosine ofob.template <class T>complex<T>exp(const complex<T> &ob);Returns the eob.template <class T>T imag(const complex<T> &ob);Returns the imaginary componentofob.template <class T>complex<T>log(const complex<T> &ob);Returns the natural logarithm ofob.template <class T>complex<T>log10(const complex<T> &ob);Returns the base 10 logarithm ofob.template <class T>T norm(const complex<T> &ob);Returnsthemagnitudeof
obsquared.
Table37-1.
Functions Defined forcomplexChapter37:TheNumericClasses
901THESTANDARDC++
CLASSLIBRARY
FunctionDescriptiontemplate <class T>complex<T>polar(const T &v, const T &theta=0);Returns a complex number that hasthe magnitude specified byvand aphase angle oftheta.template <class T>complex<T>pow(const complex<T> &b, inte);Returns be.template <class T>complex<T>pow(const complex<T> &b,const T &e);Returns be.template <class T>complex<T>pow(const complex<T> &b,const complex<T> &e);Returns be.template <class T>complex<T>pow(const T &b,const complex<T> &e);Returns be.template <class T>T real(const complex<T> &
ob);Returns the real component of
ob.template <class T>complex<T> sin(const complex<T> &ob);Returns the sine ofob.template <class T>complex<T>sinh(const complex<T> &ob);Returns the hyperbolic sine ofob.template <class T>complex<T>sqrt(const complex<T> &ob);Returns the square root of
ob.template <class T>complex<T>tan(const complex<T> &ob);Returns the tangent ofob.template <class T>complex<T>tanh(const complex<T> &ob);Returns the hyperbolic tangent ofob.Table37-1.
Functions Defined forcomplex(continued)The valarray ClassThe header<valarray>defines a number of classes that support numeric arrays. Themain class isvalarray, and it defines a one-dimensional array of values. There are a
widevarietyofmemberoperatorsandfunctionsdefinedforitaswellasalargenumber
of nonmember functions. While the description ofvalarraythat is given here will be
sufficientformostprogrammers,thoseespeciallyinterestedinnumericprocessing

willwanttostudy
valarrayingreaterdetail.Oneotherpoint:Although
valarrayisvery large, most of its operations are intuitive.
Thevalarrayclass has this template specification:template <class T> class valarrayIt defines the following constructors:
valarray( );
explicit valarray (size_tnum);valarray(const T &v, size_tnum);valarray(const T *ptr, size_tnum);valarray(const valarray<T> &ob);
valarray(const slice_array<T> &ob);
valarray(const gslice_array<T> &ob);
valarray(const mask_array<T> &ob);
valarray(const indirect_array<T> &ob);Here,thefirstconstructorcreatesanemptyobject.Thesecondcreatesa
valarrayoflengthnum.Thethirdcreatesa
valarrayoflength
numinitializedto
v.Thefourth
creates a
valarrayof lengthnumand initializes it with the elements pointed to byptr.The fifth form creates a copy of
ob. The next four constructors create a
valarrayfrom
one ofvalarray's helper classes.The following operators are defined for
valarray:+−*/−=+=/=*=
===!=<<
>><<=>>=^

^=%%=~

!||=&

&=[ ]
902C++:TheCompleteReference
These operators have several overloaded forms that are described in the accompanying
tables.The member functions and operators defined byvalarrayare shown in Table 37-2.
The nonmember operator functions defined forvalarrayare shown in Table 37-3. The
transcendental functions defined forvalarrayare shown in Table 37-4.
Chapter37:TheNumericClasses
903THESTANDARDC++
CLASSLIBRARY
FunctionDescriptionvalarray<T> apply(Tfunc(T)) const;valarray<T> apply(Tfunc(const T &ob)) const;Appliesfunc( )to the invokingarray and returns an array

containing the result.
valarray<T> cshift(intnum) const;Left-rotates the invoking array

numplaces. (That is, it performsa circular shift left.) Returns an

array containing the result.
T max( ) const;Returns the maximum value in
the invoking array.
T min( ) constReturns the minimum value in
the invoking array.
valarray<T>&operator=(const valarray<T> &ob);Assigns the elements inobto thecorresponding elements in the

invoking array. Returns a

reference to the invoking array.
valarray<T> &operator=(const T &v);Assigns each element in the
invoking array the valuev.Returns a reference to the

invoking array.
valarray<T>&operator=(const slice_array<T> &ob);Assigns a subset. Returns a
reference to the invoking array.
valarray<T>&operator=(const gslice_array<T> &ob);Assigns a subset. Returns a
reference to the invoking array.
valarray<T>&operator=(const mask_array<T> &ob);Assigns a subset. Returns a
reference to the invoking array.
Table37-2.
The Member Functions ofvalarray
904C++:TheCompleteReference
FunctionDescriptionvalarray<T>&operator=(const indirect_array<T> &
ob);Assigns a subset. Returns areference to the invoking array.
valarray<T> operator+( ) const;Unary plus applied to each
element in the invoking array.

Returns the resulting array.
valarray<T> operator−( ) const;Unary minus applied to each
element in the invoking array.

Returns the resulting array.
valarray<T> operator~( ) const;Unary bitwise NOT applied
to each element in the invoking
array.Returnstheresultingarray.
valarray<T> operator!( ) const;Unary logical NOT applied to
each element in the invoking
array.Returnstheresultingarray.
valarray<T> &operator+=(const T &v) const;Adds
vto each element inthe invoking array. Returns a

reference to the invoking array.
valarray<T> &operator−=(const T &v) const;Subtractsvfrom each element
in the invoking array. Returns a

reference to the invoking array.
valarray<T> &operator/=(const T &v) const;Divides each element in the
invoking array byv. Returns areference to the invoking array.
valarray<T> &operator*=(const T &v) const;Multiplies each element in the
invoking array byv. Returns areference to the invoking array.
valarray<T> &operator%=(const T &v) const;Assigns each element in the
invoking array the remainder

of a division byv. Returns areference to the invoking array.
Table37-2.
The Member Functions ofvalarray
(continued)Chapter37:TheNumericClasses
905THESTANDARDC++
CLASSLIBRARY
FunctionDescriptionvalarray<T> &operator^=(const T &v) const;XORs
vwith each element inthe invoking array. Returns a
reference to the invoking array.
valarray<T> &operator&=(const T &v) const;ANDs
vwith each element inthe invoking array. Returns a

reference to the invoking array.
valarray<T> &operator|=(const T &v) const;ORs
vto each element inthe invoking array. Returns a

reference to the invoking array.
valarray<T> &operator<<=(const T &v) const;Left-shifts each element in the
invoking arrayvplaces. Returnsareferencetotheinvokingarray.
valarray<T> &operator>>=(const T &v) const;Right-shifts each element in the
invoking arrayvplaces. Returnsareferencetotheinvokingarray.
valarray<T>&operator+=(const valarray<T> &ob) const;Corresponding elements of the

invoking array andobare added
together. Returns a reference to

the invoking array.
valarray<T>&operator−=(const valarray<T> &ob) const;Theelementsin
obaresubtracted
fromtheircorresponding

elementsin the invoking array.

Returnsareferencetothe

invoking array.
valarray<T>&operator/=(const valarray<T> &ob) const;The elements in the invoking
array are divided by their

corresponding elements in

ob. Returns a reference to

the invoking array.
valarray<T>&operator*=(const valarray<T> &ob) const;Corresponding elements of

the invoking array andobare
multiplied together. Returns a

reference to the invoking array.
Table37-2.
The Member Functions ofvalarray
(continued)906C++:TheCompleteReference
FunctionDescriptionvalarray<T>&operator%=(const valarray<T> &ob) const;The elements in the invokingarray are divided by their

corresponding elements in
oband the remainder is stored.

Returns a reference to the

invoking array.
valarray<T>&operator^=(const valarray<T> &ob) const;The XOR operator is applied
to corresponding elements in

oband the invoking array.
Returns a reference to the

invoking array.
valarray<T>&operator&=(const valarray<T> &ob) const;The AND operator  is applied
to corresponding elements in
oband the invoking array. Returns

areferencetotheinvokingarray.
valarray<T>&operator|=(const valarray<T> &ob) const;The OR operator  is applied
to corresponding elements

inoband the invoking array.
Returns a reference to the

invoking array.
valarray<T>&operator<<=(const valarray<T> &ob) const;Elements in the invoking array
are left-shifted by the number

of places specified in the
corresponding elements in

ob. Returns a reference to

the invoking array.
valarray<T>&operator>>=(const valarray<T> &ob) const;Elements in invoking array
are right-shifted by the number

of places specified in the
corresponding elements in

ob. Returns a reference to

the invoking array.
Table37-2.
The Member Functions ofvalarray
(continued)Chapter37:TheNumericClasses
907THESTANDARDC++
CLASSLIBRARY
FunctionDescriptionT &operator[ ] (size_tindx) ;Returns a reference to the
element at the specified index.T operator[ ] (size_tindx) const;Returns the value at the
specified index.slice_array<T> operator[ ](sliceob);Returns the specified subset.valarray<T> operator[ ](sliceob) const;Returns the specified subset.
gslice_array<T> operator[ ](const gslice &ob);Returns the specified subset.
valarray<T> operator[ ](const gslice &ob) const;Returns the specified subset.

mask_array<T>operator[ ](valarray<bool> &ob);Returns the specified subset.valarray<T>operator[ ](valarray<bool> &ob) const;Returns the specified subset.indirect_array<T>
operator[ ](const valarray<size_t> &ob);Returns the specified subset.valarray<T>operator[ ](const valarray<size_t> &ob)const;Returns the specified subset.void resize(size_t
num, Tv= T( ));Resizes the invoking array. If
elements must be added, they
are assigned the value of
v.size_t size( ) const;Returns the size (i.e., the number
of elements) of the invoking
array.
valarray<T> shift(intnum) const;Shifts the invoking array left
numplaces. Returns an arraycontaining the result.
T sum( ) const;Returns the sum of the values
stored in the invoking array.
Table37-2.
The Member Functions ofvalarray
(continued)908C++:TheCompleteReference
FunctionDescriptiontemplate <class T> valarray<T>operator+(const valarray<T>ob,const T &v);Addsvto each element ofob.Returns an array containingthe result.
template <class T> valarray<T>operator+(const T &v,const valarray<T>ob);Addsvto each element ofob.Returns an array containing
the result.
template <class T> valarray<T>operator+(const valarray<T>ob1,const valarray<T> &ob2);Adds each element inob1to itscorresponding element in
ob2.Returns an array containing
the result.
template <class T> valarray<T>operator−(const valarray<T>ob,const T &v);Subtractsvfrom each element
ofob. Returns an arraycontaining the result.
template <class T> valarray<T>operator−(const T &v,const valarray<T>ob);Subtracts each element of
obfrom
v. Returns an arraycontaining the result.
template <class T> valarray<T>operator−(const valarray<T>ob1,const valarray<T> &ob2);Subtracts each element in
ob2from its corresponding
element inob1.Returns anarray containing the result.
template <class T> valarray<T>operator*(const valarray<T>ob,const T &v);Multiplies each element
inobbyv. Returns an arraycontaining the result.
template <class T> valarray<T>operator*(const T &v,const valarray<T>ob);Multiplies each element
inobbyv. Returns an arraycontaining the result.template <class T> valarray<T>operator*(const valarray<T>ob1,const valarray<T> &ob2);Multiplies corresponding

elements inob1by thoseinob2. Returns an arraycontaining the result.
Table37-3.
The Nonmember Operator Functions Defined forvalarray
Chapter37:TheNumericClasses
909THESTANDARDC++
CLASSLIBRARY
FunctionDescriptiontemplate <class T> valarray<T>operator/(const valarray<T>ob,const T &v);Divides each element inobbyv. Returns an array containingthe result.
template <class T> valarray<T>operator/(const T &v,const valarray<T>ob);Dividesvby each element inob. Returns an array containing
the result.
template <class T> valarray<T>operator/(const valarray<T>ob1,const valarray<T> &ob2);Divides each element inob1by its corresponding element

inob2. Returns an arraycontaining the result.
template <class T> valarray<T>operator%(const valarray<T>ob,const T &v);Obtains the remainder that

results from dividing each

element inobbyv. Returnsan array containing the result.
template <class T> valarray<T>operator%(const T &v,const valarray<T>ob);Obtains the remainder that

results from dividing
vby eachelement inob. Returns an arraycontaining the result.
template <class T> valarray<T>operator%(const valarray<T>ob1,const valarray<T> &ob2);Obtains the remainder that

results from dividing each

element inob1by itscorresponding element in
ob2.Returns an array containing
the result.
template <class T> valarray<T>operator^(const valarray<T>ob,const T &v);XORs each element inobwithv. Returns an array containing
the result.
template <class T> valarray<T>operator^(const T &v,const valarray<T>ob);XORs each element inobwithv. Returns an array containing
the result.Table37-3.
The Nonmember Operator Functions Defined forvalarray
(continued)910C++:TheCompleteReference
FunctionDescriptiontemplate <class T> valarray<T>operator^(const valarray<T>ob1,const valarray<T> &ob2);XORs each element inob1withits corresponding element in
ob2.Returnsanarraycontaining

the result.
template <class T> valarray<T>operator&(const valarray<T>ob,const T &v);ANDs each element inobwithv. Returns an array containing
the result.
template <class T> valarray<T>operator&(const T &v,const valarray<T>ob);ANDs each element inobwithv. Returns an array containing
the result.
template <class T> valarray<T>operator&(const valarray<T>ob1,const valarray<T> &ob2);ANDs each element inob1withits corresponding element in

ob2.Returnsanarraycontaining

the result.
template <class T> valarray<T>operator|(const valarray<T>ob,const T &v);ORs each element inobwithv. Returns an arraycontaining the result.
template <class T> valarray<T>operator|(const T &v,const valarray<T>ob);ORs each element inobwithv. Returns an arraycontaining the result.
template <class T> valarray<T>operator|(const valarray<T>ob1,const valarray<T> &ob2);ORs each element inob1withits corresponding elementin

ob2.Returnsanarraycontaining

the result.
template <class T> valarray<T>operator<<(const valarray<T>ob,const T &v);Left-shifts each element in
obby the number of placesspecifiedby
v. Returns anarray containing the result.Table37-3.
The Nonmember Operator Functions Defined forvalarray
(continued)Chapter37:TheNumericClasses
911THESTANDARDC++
CLASSLIBRARY
FunctionDescriptiontemplate <class T> valarray<T>operator<<(const T &v,const valarray<T>ob);Left-shiftsvthe numberof places specified by theelements inob. Returns anarray containing the result.
template <class T> valarray<T>operator<<(const valarray<T>ob1,const valarray<T> &ob2);Left-shifts each element inob1the number of places specified
by its corresponding element

inob2. Returns an arraycontaining the result.
template <class T> valarray<T>operator>>(const valarray<T>ob,const T &v);Right-shifts each element
inobthe number of placesspecified byv. Returns anarray containing the result.
template <class T> valarray<T>operator>>(const T &v,const valarray<T>ob);Right-shiftsvthe numberof places specified by the
elements inob. Returns anarray containing the result.
template <class T> valarray<T>operator>>(const valarray<T>ob1,const valarray<T> &ob2);Right-shifts each element
inob1the number of placesspecified by its corresponding

element inob2. Returns anarray containing the result.
template <class T> valarray<bool>operator==(const valarray<T>ob,const T &v);For every i, performsob[i] ==v. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator==(const T &v,const valarray<T>ob);For every i, performsv==ob[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator==(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] ==ob2[i]. Returns a Boolean array
containing the result.Table37-3.
The Nonmember Operator Functions Defined forvalarray
(continued)912C++:TheCompleteReference
FunctionDescriptiontemplate <class T> valarray<bool>operator!=(const valarray<T>ob,const T &v);For every i, performsob[i] !=v.Returns a Boolean arraycontaining the result.
template <class T> valarray<bool>operator!=(const T &v,const valarray<T>ob);For every i, performsv!=ob[i].Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator!=(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] !=ob2[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator<(const valarray<T>ob,const T &v);For every i, performsob[i] <v.Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator<(const T &v,const valarray<T>ob);For every i, performsv<ob[i].Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator<(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] <ob2[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator<=(const valarray<T>ob,const T &v);For every i, performsob[i] <=v.Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator<=(const T &v,const valarray<T>ob);For every i, performsv<=ob[i].Returns a Boolean arraycontaining the result.
template <class T> valarray<bool>operator<=(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] <=ob2[i]. Returns a Boolean array
containing the result.template <class T> valarray<bool>operator>(const valarray<T>ob,const T &v);For every i, performsob[i] >v.Returns a Boolean array
containing the result.
Table37-3.
The Nonmember Operator Functions Defined forvalarray
(continued)Chapter37:TheNumericClasses
913THESTANDARDC++
CLASSLIBRARY
FunctionDescriptiontemplate <class T> valarray<bool>operator>(const T &v,const valarray<T>ob);For every i, performsv>ob[i].Returns a Boolean arraycontaining the result.
template <class T> valarray<bool>operator>(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] >ob2[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator>=(const valarray<T>ob,const T &v);For every i, performsob[i] >=v. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator>=(const T &v,const valarray<T>ob);For every i, performsv>=ob[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator>=(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] >=ob2[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator&&(const valarray<T>ob,const T &v);For every i, performsob[i] &&v. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator&&(const T &v,const valarray<T>ob);For every i, performsv&&ob[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator&&(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] &&ob2[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator||(const valarray<T>ob,const T &v);For every i, performsob[i] ||v. Returns a Boolean array
containing the result.template <class T> valarray<bool>operator||(const T &v,const valarray<T>ob);For every i, performsv||ob[i]. Returns a Boolean array
containing the result.
template <class T> valarray<bool>operator||(const valarray<T>ob1,const valarray<T> &ob2);For every i, performsob1[i] ||ob2[i]. Returns a Boolean array
containing the result.
Table37-3.
The Nonmember Operator Functions Defined forvalarray
(continued)914C++:TheCompleteReference
FunctionDescriptiontemplate<class T> valarray<T>abs(const valarray<T> &ob);Obtains the absolute value ofeach element inoband returns
an array containing the result.
template<class T> valarray<T>acos(const valarray<T> &ob);Obtains the arc cosine of each

element inoband returns an
array containing the result.
template<class T> valarray<T>asin(const valarray<T> &ob);Obtains the arc sine of each

element inoband returns an
array containing the result.
template<class T> valarray<T>atan(const valarray<T> &ob);Obtains the arc tangent of each

element inoband returns an
array containing the result.
template<class T> valarray<T>atan2(const valarray<T> &ob1,const valarray<T> &ob2);For all i, obtains the arc tangent

ofob1[i] /ob2[i] and returns an
array containing the result.
template<class T> valarray<T>atan2(const T &v, const valarray<T> &ob);For all i, obtains the arc tangent

ofv / ob1[i] and returns an array
containing the result.
template<class T> valarray<T>atan2(const valarray<T> &ob, const T &v);For all i, obtains the arc tangent

ofob1[i] /vand returns an array
containing the result.
template<class T> valarray<T>cos(const valarray<T> &ob);Obtains the cosine of each
element inoband returns an
array containing the result.
template<class T> valarray<T>cosh(const valarray<T> &ob);Obtains the hyperbolic cosine of
each element inoband returns
an array containing the result.
template<class T> valarray<T>exp(const valarray<T> &ob);Computesexponentialfunction

foreachelementin
obandreturns
anarraycontainingtheresult.
Table37-4.
Transcendental Functions Defined for
valarray
Chapter37:TheNumericClasses
915THESTANDARDC++
CLASSLIBRARY
FunctionDescriptiontemplate<class T> valarray<T>log(const valarray<T> &ob);Obtains the natural logarithm ofeach element inoband returns
an array containing the result.
template<class T> valarray<T>log10(const valarray<T> &ob);Obtains the common logarithm
of each element inoband returns
an array containing the result.
template<class T> valarray<T>pow(const valarray<T> &ob1,const valarray<T> &ob2);For all i, computesob1[i]ob2[i]and returns an array containing

the result.
template<class T> valarray<T>pow(const T &v, const valarray<T> &ob);For all i, computesvob[i]andreturns an array containing

the result.
template<class T> valarray<T>pow(const valarray<T> &ob, const T &v);For all i, computesob1[i]vandreturns an array containing

the result.
template<class T> valarray<T>sin(const valarray<T> &ob);Obtains the sine of each element
inoband returns an array
containing the result.
template<class T> valarray<T>sinh(const valarray<T> &ob);Obtains the hyperbolic sine of
each element inoband returns
an array containing the result.
template<class T> valarray<T>sqrt(const valarray<T> &ob);Obtains the square root of each

element inoband returns an
array containing the result.
template<class T> valarray<T>tan(const valarray<T> &ob);Obtains the tangent of each
element inoband returns an
array containing the result.
template<class T> valarray<T>tanh(const valarray<T> &ob);Obtains the hyperbolic tangent
of each element inoband returns
an array containing the result.
Table37-4.
Transcendental Functions Defined for
valarray
(continued)916C++:TheCompleteReference
The following program demonstrates a few of the many capabilities of
valarray.// Demonstrate valarray#include <iostream>
#include <valarray>
#include <cmath>
using namespace std;int main(){valarray<int> v(10);
int i;for(i=0; i<10; i++) v[i] = i;
cout << "Original contents: ";for(i=0; i<10; i++)cout << v[i] << " ";cout << endl;v = v.cshift(3);
cout << "Shifted contents: ";for(i=0; i<10; i++)cout << v[i] << " ";cout << endl;valarray<bool> vb = v < 5;cout << "Those elements less than 5: ";
for(i=0; i<10; i++)cout << vb[i] << " ";cout << endl << endl;valarray<double> fv(5);for(i=0; i<5; i++) fv[i] = (double) i;cout << "Original contents: ";for(i=0; i<5; i++)cout << fv[i] << " ";cout << endl;Chapter37:TheNumericClasses
917THESTANDARDC++
CLASSLIBRARY
fv = sqrt(fv);cout << "Square roots: ";for(i=0; i<5; i++)cout << fv[i] << " ";cout << endl;fv = fv + fv;cout << "Double the square roots: ";
for(i=0; i<5; i++)cout << fv[i] << " ";cout << endl;fv = fv - 10.0;cout << "After subtracting 10 from each element:\n";
for(i=0; i<5; i++)cout << fv[i] << " ";cout << endl;return 0;}Its output is shown here:
Original contents: 0 1 2 3 4 5 6 7 8 9Shifted contents: 3 4 5 6 7 8 9 0 1 2
Those elements less than 5: 1 1 0 0 0 0 0 1 1 1Original contents: 0 1 2 3 4Square roots: 0 1 1.41421 1.73205 2
Double the square roots: 0 2 2.82843 3.4641 4
After subtracting 10 from each element:
-10 -8 -7.17157 -6.5359 -6The slice and gslice ClassesThe<valarray>header defines two utility classes calledsliceandgslice. These classesencapsulate a slice (i.e., a portion) from an array. These classes are used with the subset
forms ofvalarray's operator[ ].Thesliceclass is shown here:
class slice {public:slice();
slice(size_t start, size_t len, size_t interval);
size_t start() const;
size_t size() const;
size_t stride();};The first constructor creates an empty slice. The second constructor creates a slice that
specifiesthestartingelement,thenumberofelements,andtheintervalbetweenelements

(that is, thestride). The member functions return these values.
Here is a program that demonstrates
slice.// Demonstrate slice#include <iostream>
#include <valarray>
using namespace std;int main(){valarray<int> v(10), result;
unsigned int i;for(i=0; i<10; i++) v[i] = i;
cout << "Contents of v: ";for(i=0; i<10; i++)cout << v[i] << " ";cout << endl;result = v[slice(0,5,2)];
cout << "Contents of result: ";for(i=0; i<result.size(); i++)cout << result[i] << " ";return 0;}918C++:TheCompleteReference
The output from the program is shown here:
Contents of v: 0 1 2 3 4 5 6 7 8 9Contents of result: 0 2 4 6 8As you can see, the resulting array consists of 5 elements of
v, beginning at 0, thatare 2 apart.
Thegsliceclass is shown here:
class gslice {
public:gslice();
gslice()(size_t start, const valarray<size_t> &lens,const valarray<size_t> &intervals);size_t start() const;
valarray<size_t> size() const;
valarray<size_t> stride() const;};The first constructor creates an empty slice. The second constructor creates a slice that
specifies the starting element, an array that specifies the number of elements, and an
array that specifies the intervals between elements (that is, thestrides). The number oflengthsandintervalsmustbethesame.Thememberfunctionsreturntheseparameters.

This class is used to create multidimensional arrays from a
valarray(which is alwaysone-dimensional).The following program demonstrates
gslice.// Demonstrate gslice()#include <iostream>
#include <valarray>
using namespace std;int main(){valarray<int> v(12), result;
valarray<size_t> len(2), interval(2);
unsigned int i;for(i=0; i<12; i++) v[i] = i;
len[0] = 3; len[1] = 3;Chapter37:TheNumericClasses
919THESTANDARDC++
CLASSLIBRARY
interval[0] = 2; interval[1] = 3;cout << "Contents of v: ";for(i=0; i<12; i++)cout << v[i] << " ";cout << endl;result = v[gslice(0,len,interval)];
cout << "Contents of result: ";for(i=0; i<result.size(); i++)cout << result[i] << " ";return 0;}The output is shown here:
Contents of v: 0 1 2 3 4 5 6 7 8 9 10 11
Contents of result: 0 3 6 2 5 8 4 7 10The Helper ClassesThe numeric classes rely upon these "helper" classes, which your program will never
instantiate directly:
slice_array,gslice_array,indirect_array, andmask_array.The Numeric AlgorithmsThe header<numeric>defines four numeric algorithms that can be used to process the
contents of containers. Each is examined here.
accumulateTheaccumulate( )algorithm computes a summation of all of the elements within aspecified range and returns the result. Its prototypes are shown here:
template <class InIter, class T> T accumulate(InIterstart, InIterend, Tv);template <class InIter, class T, class BinFunc>T accumulate(InIterstart, InIterend, Tv, BinFuncfunc);Here,
Tis the type of values being operated upon. The first version computes the sumof all elements in the rangestarttoend. The second version appliesfuncto the running
920C++:TheCompleteReference
total. (That is,funcspecifies how the summation will occur.) The value of
vprovides an
initial value to which the running total is added.
Here is an example that demonstrates
accumulate( ).// Demonstrate accumulate()#include <iostream>
#include <vector>
#include <numeric>
using namespace std;int main(){vector<int> v(5);
int i, total;for(i=0; i<5; i++) v[i] = i;
total = accumulate(v.begin(), v.end(), 0);
cout << "Summation of v is: " << total;
return 0;}The following output is produced:
Summation of v is: 10adjacent_difference
Theadjacent_difference()
algorithmproducesanewsequenceinwhicheachelementis
thedifferencebetweenadjacentelementsintheoriginalsequence.(Thefirstelementinthe
resultisthesameastheoriginalfirstelement.)Theprototypesfor
adjacent_difference()
areshownhere:
template <class InIter, class OutIter>OutIter adjacent_difference(InIterstart, InIterend, OutIterresult);template <class InIter, class OutIter, class BinFunc>OutIter adjacent_difference(InIterstart, InIterend, OutIterresult,BinFuncfunc);Here,
startandendare iterators to the beginning and ending of the original sequence.
The resulting sequence is stored in the sequence pointed to by
result
. In the first form,Chapter37:TheNumericClasses
921THESTANDARDC++
CLASSLIBRARY
adjacent elements are subtracted, with the element at location
nbeing subtracted from
theelementatlocation
n+1.Inthesecond,thebinaryfunction
funcisappliedtoadjacent
elements. An iterator to the end ofresult
is returned.
Here is an example that uses
adjacent_difference( )
.// Demonstrate adjacent_difference()#include <iostream>
#include <vector>
#include <numeric>
using namespace std;int main(){vector<int> v(10), r(10);
int i;for(i=0; i<10; i++) v[i] = i*2;cout << "Original sequence: ";
for(i=0; i<10; i++)cout << v[i] << " ";cout << endl;adjacent_difference(v.begin(), v.end(), r.begin());
cout << "Resulting sequence: ";for(i=0; i<10; i++)cout << r[i] << " ";return 0;}The output produced is shown here:
Original sequence: 0 2 4 6 8 10 12 14 16 18
Resulting sequence: 0 2 2 2 2 2 2 2 2 2As you can see, the resulting sequence contains the difference between the value of
adjacent elements.inner_product
Theinner_product()
algorithmproducesasummationoftheproductofcorresponding
elementsintwosequencesandreturnstheresult.Ithastheseprototypes:
922C++:TheCompleteReference
template <class InIter1, class InIter2, class T>T inner_product(InIter1start1, InIter1end1, InIter2start2, Tv);template <class InIter1, class InIter2, class T, class BinFunc1, class BinFunc2>T inner_product(InIter1start1, InIter1end1, InIter2start2, Tv,BinFunc1func2, BinFunc2func2);Here,
start1andend1are iterators to the beginning and end of the first sequence. The
iteratorstart2isaniteratortothebeginningofthesecondsequence.Thevalue
vprovidesaninitialvaluetowhichtherunningtotalisadded.Inthesecondform,
func1specifiesabinaryfunctionthatdetermineshowtherunningtotaliscomputed,
andfunc2specifiesabinaryfunctionthatdetermineshowthetwosequencesare
multiplied together.
Here is a program that demonstrates
inner_product( ).// Demonstrate inner_product()#include <iostream>
#include <vector>
#include <numeric>
using namespace std;int main(){vector<int> v1(5), v2(5);
int i, total;for(i=0; i<5; i++) v1[i] = i;for(i=0; i<5; i++) v2[i] = i+2;total = inner_product(v1.begin(), v1.end(),v2.begin(), 0);cout << "Inner product is: " << total;
return 0;}Here is the output:
Inner product is: 50partial_sum
Thepartial_sum( )algorithm sums a sequence of values, putting the current total into
each successive element of a new sequence as it goes. (That is, it creates a sequence that
is a running total of the original sequence.) The first element in the result is the same as
Chapter37:TheNumericClasses
923THESTANDARDC++
CLASSLIBRARY
924C++:TheCompleteReference
the first element in the original sequence. The prototypes for
partial_sum( )are
shown here:
template <class InIter, class OutIter>OutIter partial_sum(InIterstart, InIterend, OutIterresult);template <class InIter, class OutIter, class BinFunc>OutIter partial_sum(InIterstart, InIterend, OutIterresult,BinFuncfunc);Here,
startandendare iterators to the beginning and end of the original sequence. The
iteratorresult
is an iterator to the beginning of the resulting sequence. In the second
form,funcspecifiesabinaryfunctionthatdetermineshowtherunningtotaliscomputed.
An iterator to the end ofresult
is returned.
Here is an example of
partial_sum( ).// Demonstrate partial_sum()#include <iostream>
#include <vector>
#include <numeric>
using namespace std;int main(){vector<int> v(5), r(5);
int i;for(i=0; i<5; i++) v[i] = i;cout << "Original sequence: ";
for(i=0; i<5; i++)cout << v[i] << " ";cout << endl;partial_sum(v.begin(), v.end(), r.begin());
cout << "Resulting sequence: ";for(i=0; i<5; i++)cout << r[i] << " ";return 0;}Here is its output:
Original sequence: 0 1 2 3 4
Resulting sequence: 0 1 3 6 10Chapter38
Exception Handling andMiscellaneous Classes925Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
926C++:TheCompleteReference
This chapter describes the exception handling classes. It also describes theauto_ptrandpairclasses, and gives a brief introduction to the localization library.ExceptionsTheStandardC++librarydefinestwoheadersthatrelatetoexceptions:
<exception>and<stdexcept>.Exceptionsareusedtoreporterrorconditions.Eachheaderisexaminedhere.
<exception>The<exception>header defines classes, types, and functions that relate to exception
handling. The classes defined by <exception>are shown here.
class exception {public:exception() throw();
exception(const bad_exception &ob) throw();
virtual ~exception() throw();exception &operator=(const exception &ob) throw();virtual const char *what(() const throw();};class bad_exception: public exception {public:bad_exception() throw();
bad_exception(const bad_exception &ob) throw();
virtual ~bad_exception() throw();bad_exception &operator=(const bad_exception &ob) throw();virtual const char *what(() const throw();};Theexceptionclass is a base for all exceptions defined by the C++ standard library. The
bad_exceptionclass is the type of exception thrown by the
unexpected( )function. Ineach,thememberfunction
what()
returnsapointertoanull-terminatedstringthat
describes the exception.Several important classes are derived from
exception. The first isbad_alloc, thrown
when thenewoperator fails. Next isbad_typeid. It is thrown when an illegal
typeidexpression is executed. Finally,
bad_castis thrown when an invalid dynamic cast is
attempted. These classes contain the same members asexception.The types defined by<exception>are:
Type
Meaningterminate_handlervoid (*terminate_handler) ( );unexpected_handlervoid (*unexpected_handler) ( );The functions declared in
<exception>are shown in Table 38-1.
<stdexcept>Theheader
<stdexcept>definesseveralstandardexceptionsthatmaybethrownbyC++
libraryfunctionsand/oritsrun-timesystem.Therearetwogeneraltypesofexceptions
definedby
<stdexcept>:logicerrorsandrun-timeerrors.Logicerrorsoccurbecauseof
mistakesmadebytheprogrammer.Run-timeerrorsoccurbecauseofmistakesinlibrary

functionsortherun-timesystem,andarebeyondprogrammercontrol.
Chapter38:ExceptionHandlingandMiscellaneousClasses
927THESTANDARDC++
CLASSLIBRARY
FunctionDescriptionterminate_handlerset_terminate(terminate_handlerfn)throw( );
Sets the function specified byfnas theterminate handler. Apointer to the old

terminate handler is returned.
unexpected_handlerset_unexpected(unexpected_handlerfn)throw( );
Sets the function specified byfnas theunexpected handler. Apointer to the

old unexpected handler is returned.
void terminate( );Calls the terminate handler when a
fatal exception is unhandled. Calls
abort( )by default.bool uncaught_exception( );Returns true if an exception is
uncaught.void unexpected( );Callstheunexpectedexceptionhandler

whenafunctionthrowsadisallowed

exception.Bydefault,
terminate()
iscalled.
Table38-1.
TheFunctions
Defined Within<exception>The standard exceptions defined by C++ caused by logic errors are derived from
the base classlogic_error. These exceptions are shown here.
ExceptionMeaning
domain_errorDomain error occurred.
invalid_argumentInvalid argument used in function call.

length_errorAn attempt was made to create an object that was too
large.
out_of_rangeAn argument to a function was not in the required range.
The following run-time exceptions are derived from the base class
runtime_error.ExceptionMeaningoverflow_errorArithmetic overflow occurred.

range_errorAn internal range error occurred.

underflow_errorAn underflow occurred.
auto_ptrAvery interesting class is
auto_ptr, which is declared in the header
<memory>. Anauto_ptris a pointer that owns the object to which it points. Ownership of this objectcan be transferred to another
auto_ptr, but someauto_ptralways owns the object. Thekey purpose of this scheme is to ensure that dynamically allocated objects are properly
destroyed in all circumstances (that is, that the object's destructor is always properly

executed).Forexample,whenone
auto_ptrobjectisassignedtoanother,onlythetarget
of the assignment will own the object. When the pointers are destroyed, the object will

only be destroyed once, when the pointer holding ownership is destroyed. One benefit

ofthisapproachisthatdynamicallyallocatedobjectscanbedestroyedwhenanexception

is handled.The template specification forauto_ptris shown here:
template <class T> class auto_ptrHere,
Tspecifies the type of pointer stored by the
auto_ptr.Here are the constructors for
auto_ptr:explicit auto_ptr(T *ptr= 0) throw( );928C++:TheCompleteReference
auto_ptr(auto_ptr &ob) throw( );template <class T2> auto_ptr(auto_ptr<T2> &ob) throw( );The first constructor creates an
auto_ptrto the object specified byptr. The secondconstructor creates a copy of the
auto_ptrspecified byoband transfers ownership tothe new object. The third converts
obto type T (if possible) and transfers ownership.Theauto_ptrclass defines the=,*, and>operators. Here are two of its member
functions:T *get( ) const throw( );T *release( ) const throw( );Theget()
functionreturnsapointertothestoredobject.The
release()
functionremoves
ownershipofthestoredobjectfromtheinvoking
auto_ptrandreturnsapointertothe
object.Afteracallto
release()
,thepointed-toobjectisnotautomaticallydestroyedwhen
theauto_ptrobjectgoesout-of-scope.
Here is a short program that demonstrates the use of
auto_ptr.// Demonstrate an auto_ptr.#include <iostream>
#include <memory>
using namespace std;class X {public:X() { cout << "constructing\n"; }
~X() { cout << "destructing\n"; }
void f() { cout << "Inside f()\n"; }};int main(){auto_ptr<X> p1(new X), p2;p2 = p1; // transfer ownershipp2->f();// can assign to a normal pointerX *ptr = p2.get();Chapter38:ExceptionHandlingandMiscellaneousClasses
929THESTANDARDC++
CLASSLIBRARY
ptr->f();return 0;}The output produced by this program is shown here:
constructingInside f()
Inside f()
destructingNoticethat
X'smemberfunction
f()
canbecalledeitherthroughan
auto_ptrorthrough
the"normal"pointerreturnedby
get()
.The pair ClassThepairclass is used to house pairs of objects, such as might be stored in an associative
container. It has this template specification:
template <class Ktype, class Vtype> struct pair {typedef Ktype first_type;
typedef Vtype second_type;
Ktype first;
Vtype second;// constructorspair();
pair(const Ktype &k, const Vtype &v);
template<class A, class B> pair(const<A, B> &ob);}The value infirsttypically contains a key, and the value in
secondtypically containsthe value associated with that key.
The following operators are defined for
pair:==,!=,<,<=,>, and>=.Youcanconstructapairusingeitheroneof
pair'sconstructorsorbyusing
make_pair( ), which constructs a pair object based upon the types of the data used
as parameters.make_pair( )is a generic function that has this prototype:
template <classKtype, classVtype>pair<Ktype,Vtype> make_pair(constKtype&k, constVtype&v);930C++:TheCompleteReference
As you can see, it returns a pair object consisting of values of the types specified by
KtypeandVtype. The advantage ofmake_pair( )is that the types of the objects beingstored are determined automatically by the compiler rather than being explicitly

specified by you.Thepairclass and themake_pair( )function require the header
<utility>.LocalizationStandard C++ provides an extensive localization class library. These classes allow an

application to set or obtain information about the geopolitical environment in which it

is executing. Thus, it defines such things as the format of currency, time and date, and

collation order. It also provides for character classification. The localization library uses

theheader
<locale>.Itoperatesthroughaseriesofclassesthatdefinefacets(bitsof
information associated with a locale). All facets are derived from the class
facet, whichis a nested class inside thelocaleclass.Frankly,thelocalizationlibraryisextraordinarilylargeandcomplex.Adescriptionof
itsfeaturesisbeyondthescopeofthisbook.Whilemostprogrammerswillnotmakedirect

useofthelocalizationlibrary,ifyouareinvolvedinthepreparationofinternationalized

programs,youwillwanttoexploreitsfeatures.
Other Classes of Interest
HereareafewotherclassesdefinedbytheStandardC++librarythatmaybeofinterest.
ClassDescriptiontype_infoUsed in conjunction with thetypeidoperator andfully described in Chapter 22. Uses the header
<typeinfo>.numeric_limtsEncapsulates various numeric limits. Uses theheader<limits>.raw_storage_iteratorEncapsulates allocation of uninitialized memory.
Uses the header<memory>.Chapter38:ExceptionHandlingandMiscellaneousClasses
931THESTANDARDC++
CLASSLIBRARY
This page intentionally left blank Part V
Applying C++PartFiveofthisbookprovidestwosampleC++applications.The
purposeofthissectionistwofold.First,theexampleshelpillustratethe

benefitsofobject-orientedprogramming.Second,theyshowhowC++

canbeappliedtosolvetwoverydifferenttypesofprogramming

problems.Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This page intentionally left blank Chapter39
IntegratingNew Classes:
A Custom String Class935Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
This chapter designs and implements a small string class. As you know, StandardC++providesafull-featured,powerfulstringclasscalled
basic_string.The
purpose of this chapter is not to develop an alternative to this class, but rather togive you insight into how any new data type can be easily added and integrated into
the C++ environment. The creation of a string class is the quintessential example of this
process. In the past, many programmers honed their object-oriented skills developing
their own personal string classes. In this chapter, we will do the same.While the example string class developed in this chapter is much simpler than theone supplied by Standard C++, it does have one advantage: it gives you full control

overhowstringsareimplementedandmanipulated.Youmayfindthisusefulincertain

situations. It is also just plain fun to play with!The StrType Class
Our string class is loosely modeled on the one provided by the standard library. Of

course, it is not as large or as sophisticated. The string class defined here will meet the

following requirements:
Strings may be assigned by using the assignment operator.
Both string objects and quoted strings may be assigned to string objects.Concatenation of two string objects is accomplished with the+operator.
Substring deletion is performed using the–operator.
String comparisons are performed with the relational operators.
String objects may be initialized by using either a quoted string or another
string object.Strings must be able to be of arbitrary and variable lengths. This implies that
storage for each string is dynamically allocated.Amethodofconvertingstringobjectstonull-terminatedstringswillbeprovided.
Although our string class will, in general, be less powerful than the standard string

class, it does include one feature not defined by
basic_string: substring deletion viathe–operator.
The class that will manage strings is calledStrType
. Its declaration is shown here:
class StrType {char *p;int size;public:StrType();936C++:TheCompleteReference
StrType(char *str);StrType(const StrType &o); // copy constructor~StrType() { delete [] p; }
friend ostream &operator<<(ostream &stream, StrType &o);friend istream &operator>>(istream &stream, StrType &o);StrType operator=(StrType &o); // assign a StrType objectStrType operator=(char *s); // assign a quoted stringStrType operator+(StrType &o); // concatenate a StrType objectStrType operator+(char *s); // concatenate a quoted string
friend StrType operator+(char *s, StrType &o); /*  concatenatea quoted string with a StrType object */StrType operator-(StrType &o); // subtract a substring
StrType operator-(char *s); // subtract a quoted substring// relational operations between StrType objectsint operator==(StrType &o) { return !strcmp(p, o.p); }
int operator!=(StrType &o) { return strcmp(p, o.p); }
int operator<(StrType &o) { return strcmp(p, o.p) < 0; }
int operator>(StrType &o) { return strcmp(p, o.p) > 0; }
int operator<=(StrType &o) { return strcmp(p, o.p) <= 0; }
int operator>=(StrType &o) { return strcmp(p, o.p) >= 0; }// operations between StrType objects and quoted stringsint operator==(char *s) { return !strcmp(p, s); }
int operator!=(char *s) { return strcmp(p, s); }
int operator<(char *s) { return strcmp(p, s) < 0; }
int operator>(char *s) { return strcmp(p, s) > 0; }
int operator<=(char *s) { return strcmp(p, s) <= 0; }
int operator>=(char *s) { return strcmp(p, s) >= 0; }int strsize() { return strlen(p); } // return size of stringvoid makestr(char *s) { strcpy(s, p); } // make quoted stringoperator char *() { return p; } // conversion to char *};Chapter39:IntegratingNewClasses:ACustomStringClass
937APPLYINGC++
The private part ofStrType
contains only two items:pandsize. When a stringobject is created, memory to hold the string is dynamically allocated by using
new, anda pointer to that memory is put inp. The string pointed to bypwill be a normal, null-terminatedcharacterarray.Althoughitisnottechnicallynecessary,thesizeofthestring
is held insize. Because the string pointed to bypis a null-terminated string, it wouldbe possible to compute the size of the string each time it is needed. However, as you

will see, this value is used so often by theStrType
member functions that the repeated
calls tostrlen( )cannot be justified.The next several sections detail how theStrType
class works.The Constructors and Destructors
AStrType
object may be declared in three different ways: without any initialization,
with a quoted string as an initializer, or with a
StrType
object as an initializer. The
constructors that support these three operations are shown here:
// No explicit initialization.StrType::StrType() {size = 1; // make room for null terminator
try {p = new char[size];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(p, "");}// Initialize using a quoted string.StrType::StrType(char *str) {size = strlen(str) + 1; // make room for null terminator
try {p = new char[size];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(p, str);}// Initialize using a StrType object.StrType::StrType(const StrType &o) {938C++:TheCompleteReference
size = o.size;try {p = new char[size];} catch (bad_alloc xa) {cout << "Allocation error\n";exit(1);}
strcpy(p, o.p);}When aStrType
object is created with no initializer, it is assigned a null-string.
Although the string could have been left undefined, knowing that allStrType
objectscontain a valid, null-terminated string simplifies several other member functions.When aStrType
object is initialized by a quoted string, first the size of the string isdetermined. This value is stored in
size. Then, sufficient memory is allocated by
newand the initializing string is copied into the memory pointed to byp.When aStrType
object is used to initialize another, the process is similar to using a
quoted string. The only difference is that the size of the string is known and does not
have to be computed. This version of theStrType
constructor is also the class' copy
constructor. This constructor will be invoked whenever one
StrType
object is used toinitialize another. This means that it is called when temporary objects are created and

when objects of typeStrType
are passed to functions. (See Chapter 14 for a discussion
of copy constructors.)
Given the three preceding constructors, the following declarations are allowed:
StrType x("my string"); // use quoted stringStrType y(x); // use another object
StrType z; // no explicit initializationTheStrType
destructor simply frees the memory pointed to by
p.I/O on StringsBecauseitiscommontoinputoroutputstrings,the
StrType
classoverloadsthe
<<and>>operators,asshownhere:
// Output a string.ostream &operator<<(ostream &stream, StrType &o)
{stream << o.p;APPLYINGC++
Chapter39:IntegratingNewClasses:ACustomStringClass
939940C++:TheCompleteReference
return stream;}// Input a string.istream &operator>>(istream &stream, StrType &o)
{char t[255]; // arbitrary size - change if necessary
int len;stream.getline(t, 255);len = strlen(t) + 1;if(len > o.size) {delete [] o.p;try {o.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
o.size = len;}
strcpy(o.p, t);
return stream;}Asyoucansee,outputisverysimple.However,noticethattheparameter
oispassed
by reference. Since
StrType
objects may be quite large, passing one by reference is more
efficient than passing one by value. For this reason, all
StrType
parameters are passed
by reference. (Any function you create that takes
StrType
parameters should probably
do the same.)Inputting astringproves to be a little more difficult than outputting one. First, the
string is read using the
getline( )function. The length of the largest string that can be
input is limited to 254 plus the null terminator. As the comments indicate, you can
change this if you like. Characters are read until a newline is encountered. Once the

string has been read, if the size of the new string exceeds that of the one currently held

byo, that memory is released and a larger amount is allocated. The new string is then
copied into it.Chapter39:IntegratingNewClasses:ACustomStringClass
941APPLYINGC++
The Assignment FunctionsYoucanassigna
StrType
objectastringintwoways.First,youcanassignanother
StrType
objecttoit.Second,youcanassignitaquotedstring.Thetwooverloaded
operator=()
functionsthataccomplishtheseoperationsareshownhere:
// Assign a StrType object to a StrType object.StrType StrType::operator=(StrType &o)
{StrType temp(o.p);if(o.size > size) {delete [] p; // free old memorytry {p = new char[o.size];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
size = o.size;}strcpy(p, o.p);strcpy(temp.p, o.p);return temp;}
// Assign a quoted string to a StrType object.StrType StrType::operator=(char *s)
{int len = strlen(s) + 1;
if(size < len) {delete [] p;
try {p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);942C++:TheCompleteReference
}size = len;}strcpy(p, s);
return *this;}These two functions work by first checking to see if the memory currently pointed
to bypof the target
StrType
object is sufficiently large to hold what will be copied to it.
Ifnot,theoldmemoryisreleasedandnewmemoryisallocated.Thenthestringiscopied
into the object and the result is returned. These functions allow the following types of

assignments:StrType x("test"), y;y = x; // StrType object to StrType object
x = "new string for x"; // quoted string to StrType objectEachassignmentfunctionreturnsthevalueassigned(thatis,theright-handvalue)so
thatmultipleassignmentslikethiscanbesupported:
StrType x, y, z;
x = y = z = "test";ConcatenationConcatenationoftwostringsisaccomplishedbyusingthe
+operator.The
StrType
classallowsforthefollowingthreedistinctconcatenationsituations:
Concatenation of aStrType
object with anotherStrType
objectConcatenation of aStrType
object with a quoted stringConcatenation of a quoted string with aStrType
objectWhenusedinthesesituations,the
+operatorproducesasitsoutcomea
StrType
objectthat
istheconcatenationofitstwooperands.Itdoesnotactuallymodifyeitheroperand.
Chapter39:IntegratingNewClasses:ACustomStringClass
943APPLYINGC++
The overloadedoperator+( )functions are shown here:
// Concatenate two StrType objects.StrType StrType::operator+(StrType &o)
{int len;
StrType temp;delete [] temp.p;len = strlen(o.p) + strlen(p) + 1;
temp.size = len;
try {temp.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(temp.p, p);strcat(temp.p, o.p);
return temp;}
// Concatenate a StrType object and a quoted string.StrType StrType::operator+(char *s)
{int len;
StrType temp;delete [] temp.p;
len = strlen(s) + strlen(p) + 1;temp.size = len;
try {temp.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";944C++:TheCompleteReference
exit(1);}strcpy(temp.p, p);strcat(temp.p, s);
return temp;}
// Concatenate a quoted string and a StrType object.StrType operator+(char *s, StrType &o)
{int len;
StrType temp;delete [] temp.p;
len = strlen(s) + strlen(o.p) + 1;temp.size = len;
try {temp.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(temp.p, s);strcat(temp.p, o.p);
return temp;}All three functions work basically in the same way. First, a temporary
StrType
object calledtempis created. This object will contain the outcome of the concatenation,
and it is the object returned by the functions. Next, the memory pointed to by
temp.pisfreed.Thereasonforthisisthatwhen
tempiscreated,only1byteofmemoryisallocated
(as a placeholder) because there is no explicit initialization. Next, enough memory is
allocatedtoholdtheconcatenationofthetwostrings.Finally,thetwostringsarecopied

into the memory pointed to bytemp.p, andtempis returned.
Chapter39:IntegratingNewClasses:ACustomStringClass
945APPLYINGC++
Substring SubtractionAusefulstringfunctionnotfoundin
basic_stringissubstringsubtraction
.Asimplemented
bythe
StrType
class,substringsubtractionremovesalloccurrencesofaspecifiedsubstring
fromanotherstring.Substringsubtractionisaccomplishedbyusingthe–operator.
TheStrType
classsupportstwocasesofsubstringsubtraction.Oneallowsa
StrType
objecttobesubtractedfromanother
StrType
object.Theotherallowsaquotedstringtobe
removedfroma
StrType
object.Thetwo
operator()functionsareshownhere:
// Subtract a substring from a string using StrType objects.StrType StrType::operator-(StrType &substr)
{StrType temp(p);
char *s1;
int i, j;s1 = p;for(i=0; *s1; i++) {if(*s1!=*substr.p) { // if not first letter of substringtemp.p[i] = *s1;  // then copy into temp
s1++;}
else {for(j=0; substr.p[j]==s1[j] && substr.p[j]; j++) ;
if(!substr.p[j]) { // is substring, so remove its1 += j;
i--;}
else { // is not substring, continue copyingtemp.p[i] = *s1;
s1++;}}}
temp.p[i] = '\0';
return temp;}// Subtract quoted string from a StrType object.StrType StrType::operator-(char *substr)
{StrType temp(p);char *s1;int i, j;s1 = p;for(i=0; *s1; i++) {if(*s1!=*substr) { // if not first letter of substringtemp.p[i] = *s1; // then copy into temp
s1++;}
else {for(j=0; substr[j]==s1[j] && substr[j]; j++) ;
if(!substr[j]) { // is substring, so remove its1 += j;
i--;}
else { // is not substring, continue copyingtemp.p[i] = *s1;
s1++;}}}
temp.p[i] = '\0';
return temp;}These functions work by copying the contents of the left-hand operand intotemp,removing any occurrences of the substring specified by the right-hand operand during
the process. The resulting
StrType
object is returned. Understand that neither operand
is modified by the process.
TheStrType
class allows substring subtractions like these:StrType x("I like C++"), y("like");StrType z;z = x - y; // z will contain "I C++"
z = x - "C++"; // z will contain "I like "
// multiple occurrences are removedz = "ABCDABCD";
x = z -"A"; // x contains "BCDBCD"946C++:TheCompleteReference
The Relational OperatorsTheStrType
classsupportsthefullrangeofrelationaloperationstobeappliedto
strings.Theoverloadedrelationaloperatorsaredefinedwithinthe
StrType
classdeclaration. They are repeated here for your convenience:
// relational operations between StrType objectsint operator==(StrType &o) { return !strcmp(p, o.p); }
int operator!=(StrType &o) { return strcmp(p, o.p); }
int operator<(StrType &o) { return strcmp(p, o.p) < 0; }
int operator>(StrType &o) { return strcmp(p, o.p) > 0; }
int operator<=(StrType &o) { return strcmp(p, o.p) <= 0; }
int operator>=(StrType &o) { return strcmp(p, o.p) >= 0; }// operations between StrType objects and quoted stringsint operator==(char *s) { return !strcmp(p, s); }
int operator!=(char *s) { return strcmp(p, s); }
int operator<(char *s) { return strcmp(p, s) < 0; }
int operator>(char *s) { return strcmp(p, s) > 0; }
int operator<=(char *s) { return strcmp(p, s) <= 0; }
int operator>=(char *s) { return strcmp(p, s) >= 0; }Therelationaloperationsareverystraightforward;youshouldhavenotrouble
understandingtheirimplementation.However,keepinmindthatthe
StrType
classimplementscomparisonsbetweentwo
StrType
objectsorcomparisonsthathavea
StrType
object as the left operand and a quoted string as the right operand. If you wantto be able to put the quoted string on the left and aStrType
object on the right, you willneed to add additional relational functions.
Giventheoverloadedrelationaloperatorfunctionsdefinedby
StrType
,thefollowing
types of string comparisons are allowed:
StrType x("one"), y("two"), z("three");if(x < y) cout << "x less than y";
if(z=="three")  cout << "z equals three";
y = "o";z = "ne";
if(x==(y+z)) cout << "x equals y+z";APPLYINGC++
Chapter39:IntegratingNewClasses:ACustomStringClass
947948C++:TheCompleteReference
Miscellaneous String FunctionsTheStrType
class defines three functions that make
StrType
objects integrate more
completely with the C++ programming environment. They are
strsize( ),makestr( ),and the conversion functionoperator char *( ). These functions are defined within the
StrType
declaration and are shown here:
int strsize() { return strlen(p); } // return size of stringvoid makestr(char *s) { strcpy(s, p); } // make quoted string
operator char *(){ return p; } // conversion to char *Thefirsttwofunctionsareeasytounderstand.Asyoucansee,the
strsize()
functionreturns the length of the string pointed to by
p. Since the length of the string might bedifferentthanthevaluestoredinthe
sizevariable(becauseofanassignmentofashorter
string, for example), the length is computed by callingstrlen( ). Themakestr( )functioncopies into a character array the string pointed to byp. This function is useful whenyou want to obtain a null-terminated string given aStrType
object.The conversion functionoperator char *( )returns
p, which is, of course, a pointerto the string contained within the object. This function allows aStrType
object to beusedanywherethatanull-terminatedstringcanbeused.Forexample,thisisvalidcode:
StrType x("Hello");
char s[20];// copy a string object using the strcpy() functionstrcpy(s, x); // automatic conversion to char *Recallthataconversionfunctionisautomaticallyexecutedwhenanobjectisinvolved
in an expression for which the conversion is defined. In this case, because the prototype
for thestrcpy( )function tells the compiler that its second argument is of type
char *,the conversion from
StrType
tochar *is automatically performed, causing a pointerto the string contained withinxto be returned. This pointer is then used by
strcpy( )tocopythestringinto
s.Becauseoftheconversionfunction,youcanusean
StrType
object in place of a null-terminated string as an argument to any function that takes an

argument of type
char *.Chapter39:IntegratingNewClasses:ACustomStringClass
949APPLYINGC++
The conversion tochar *does circumvent encapsulation, because once a function has a
pointer to the object's string, it is possible for that function to modify the string directly,
bypassing theStrType
member functions and without that object's knowledge. For thisreason, you must use the conversion to
char *with care. You can prevent the underlying
string from being modified by having the conversion to
char *return a
constpointer.
With this approach, encapsulation is preserved. You might want to try this change on

your own.The Entire StrType Class
Here is a listing of the entire
StrType
class along with a shortmain( )function thatdemonstrates its features:
#include <iostream>#include <new>
#include <cstring>
#include <cstdlib>
using namespace std;class StrType {char *p;int size;public:StrType();
StrType(char *str);
StrType(const StrType &o); // copy constructor~StrType() { delete [] p; }
friend ostream &operator<<(ostream &stream, StrType &o);friend istream &operator>>(istream &stream, StrType &o);StrType operator=(StrType &o); // assign a StrType objectStrType operator=(char *s); // assign a quoted stringStrType operator+(StrType &o); // concatenate a StrType objectStrType operator+(char *s); // concatenate a quoted string
friend StrType operator+(char *s, StrType &o); /*  concatenatea quoted string with a StrType object */StrType operator-(StrType &o); // subtract a substringStrType operator-(char *s); // subtract a quoted substring// relational operations between StrType objectsint operator==(StrType &o) { return !strcmp(p, o.p); }
int operator!=(StrType &o) { return strcmp(p, o.p); }
int operator<(StrType &o) { return strcmp(p, o.p) < 0; }
int operator>(StrType &o) { return strcmp(p, o.p) > 0; }
int operator<=(StrType &o) { return strcmp(p, o.p) <= 0; }
int operator>=(StrType &o) { return strcmp(p, o.p) >= 0; }// operations between StrType objects and quoted stringsint operator==(char *s) { return !strcmp(p, s); }
int operator!=(char *s) { return strcmp(p, s); }
int operator<(char *s) { return strcmp(p, s) < 0; }
int operator>(char *s) { return strcmp(p, s) > 0; }
int operator<=(char *s) { return strcmp(p, s) <= 0; }
int operator>=(char *s) { return strcmp(p, s) >= 0; }int strsize() { return strlen(p); } // return size of stringvoid makestr(char *s) { strcpy(s, p); } // null-terminated string
operator char *() { return p; } // conversion to char *};// No explicit initialization.StrType::StrType() {size = 1; // make room for null terminator
try {p = new char[size];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(p, "");}// Initialize using a quoted string.StrType::StrType(char *str) {size = strlen(str) + 1; // make room for null terminator
try {p = new char[size];} catch (bad_alloc xa) {950C++:TheCompleteReference
cout << "Allocation error\n";exit(1);}strcpy(p, str);}// Initialize using a StrType object.StrType::StrType(const StrType &o) {size = o.size;
try {p = new char[size];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(p, o.p);}// Output a string.ostream &operator<<(ostream &stream, StrType &o)
{stream << o.p;
return stream;}// Input a string.istream &operator>>(istream &stream, StrType &o)
{char t[255]; // arbitrary size - change if necessary
int len;stream.getline(t, 255);len = strlen(t) + 1;if(len > o.size) {delete [] o.p;try {o.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}Chapter39:IntegratingNewClasses:ACustomStringClass
951APPLYINGC++
o.size = len;}strcpy(o.p, t);
return stream;}// Assign a StrType object to a StrType object.StrType StrType::operator=(StrType &o)
{StrType temp(o.p);if(o.size > size) {delete [] p; // free old memorytry {p = new char[o.size];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
size = o.size;}strcpy(p, o.p);strcpy(temp.p, o.p);return temp;}
// Assign a quoted string to a StrType object.StrType StrType::operator=(char *s)
{int len = strlen(s) + 1;
if(size < len) {delete [] p;
try {p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
size = len;}952C++:TheCompleteReference
strcpy(p, s);return *this;}// Concatenate two StrType objects.StrType StrType::operator+(StrType &o)
{int len;StrType temp;delete [] temp.p;len = strlen(o.p) + strlen(p) + 1;
temp.size = len;
try {temp.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(temp.p, p);strcat(temp.p, o.p);
return temp;}
// Concatenate a StrType object and a quoted string.StrType StrType::operator+(char *s)
{int len;
StrType temp;delete [] temp.p;
len = strlen(s) + strlen(p) + 1;temp.size = len;
try {temp.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}Chapter39:IntegratingNewClasses:ACustomStringClass
953APPLYINGC++
strcpy(temp.p, p);strcat(temp.p, s);
return temp;}
// Concatenate a quoted string and a StrType object.StrType operator+(char *s, StrType &o)
{int len;
StrType temp;delete [] temp.p;
len = strlen(s) + strlen(o.p) + 1;temp.size = len;
try {temp.p = new char[len];} catch (bad_alloc xa) {cout << "Allocation error\n";
exit(1);}
strcpy(temp.p, s);strcat(temp.p, o.p);
return temp;}
// Subtract a substring from a string using StrType objects.StrType StrType::operator-(StrType &substr)
{StrType temp(p);
char *s1;
int i, j;s1 = p;for(i=0; *s1; i++) {if(*s1!=*substr.p) { // if not first letter of substringtemp.p[i] = *s1;  // then copy into temp
s1++;954C++:TheCompleteReference
}else {for(j=0; substr.p[j]==s1[j] && substr.p[j]; j++) ;if(!substr.p[j]) { // is substring, so remove its1 += j;
i--;}
else { // is not substring, continue copyingtemp.p[i] = *s1;
s1++;}}}
temp.p[i] = '\0';
return temp;}// Subtract quoted string from a StrType object.StrType StrType::operator-(char *substr)
{StrType temp(p);
char *s1;
int i, j;s1 = p;for(i=0; *s1; i++) {if(*s1!=*substr) { // if not first letter of substringtemp.p[i] = *s1; // then copy into temp
s1++;}
else {for(j=0; substr[j]==s1[j] && substr[j]; j++) ;
if(!substr[j]) { // is substring, so remove its1 += j;
i--;}
else { // is not substring, continue copyingtemp.p[i] = *s1;
s1++;}}}Chapter39:IntegratingNewClasses:ACustomStringClass
955APPLYINGC++
temp.p[i] = '\0';return temp;}int main(){StrType s1("A sample session using string objects.\n");StrType s2(s1);
StrType s3;
char s[80];cout << s1 << s2;
s3 = s1;cout << s1;s3.makestr(s);cout << "Convert to a string: " << s;s2 = "This is a new string.";cout << s2 << endl;StrType s4(" So is this.");s1 = s2+s4;
cout << s1 << endl;if(s2==s3) cout << "Strings are equal.\n";if(s2!=s3) cout << "Strings are not equal.\n";
if(s1<s4) cout << "s1 less than s4\n";
if(s1>s4) cout << "s1 greater than s4\n";
if(s1<=s4) cout << "s1 less than or equals s4\n";
if(s1>=s4) cout << "s1 greater than or equals s4\n";if(s2 > "ABC") cout << "s2 greater than ABC\n\n";
s1 = "one two three one two three\n";s2 = "two";
cout << "Initial string: " << s1;
cout << "String after subtracting two: ";
s3 = s1 - s2;
cout << s3;956C++:TheCompleteReference
cout << endl;s4 = "Hi there!";
s3 = s4 + " C++ strings are fun\n";
cout << s3;
s3 = s3 - "Hi there!";
s3 = "Aren't" + s3;
cout << s3;s1 = s3 - "are ";cout << s1;
s3 = s1;cout << "Enter a string: ";cin >> s1;
cout << s1 << endl;
cout << "s1 is " << s1.strsize() << " characters long.\n";puts(s1); // convert to char *
s1 = s2 = s3;cout << s1 << s2 << s3;s1 = s2 = s3 = "Bye ";cout << s1 << s2 << s3;return 0;}The preceding program produces this output:
A sample session using string objects.A sample session using string objects.
A sample session using string objects.
Convert to a string: A sample session using string objects.
This is a new string.
This is a new string. So is this.
Strings are not equal.
s1 greater than s4
s1 greater than or equals s4
s2 greater than ABCChapter39:IntegratingNewClasses:ACustomStringClass
957APPLYINGC++
958C++:TheCompleteReference
Initial string: one two three one two threeString after subtracting two: one  three one  threeHi there! C++ strings are funAren't C++ strings are fun
Aren't C++ strings fun
Enter a string: I like C++
s1 is 10 characters long.
I like C++
Aren't C++ strings fun
Aren't C++ strings fun
Aren't C++ strings fun
Bye Bye ByeThis output assumes that the string "I like C++" was entered by the user when
prompted for input.
To have easy access to the
StrType
class, remove the
main( )function and put therest of the preceding listing into a file called STR.H. Then, just include this header file
with any program in which you want to use
StrType
.Using the StrType Class
To conclude this chapter, two short examples are given that illustrate the
StrType
class.As you will see, because of the operators defined for it and because of its conversion
function tochar *,StrType
is fully integrated into the C++ programming environment.
That is, it can be used like any other type defined by Standard C++.
Thefirstexamplecreatesasimplethesaurusbyusing
StrType
objects.Itfirst
creates a two-dimensional array of
StrType
objects. Within each pair of strings, the first
contains the key word, which may be looked up. The second string contains a list of

alternative or related words. The program prompts for a word, and if the word is in the

thesaurus,alternativesaredisplayed.Thisprogramisverysimple,butnoticehowclean

andclearthestringhandlingisbecauseoftheuseofthe
StrType
classanditsoperators.
(Remember, the header file STR.H contains the
StrType
class.)#include "str.h"#include <iostream>
using namespace std;StrType thesaurus[][2] = {"book", "volume, tome",Chapter39:IntegratingNewClasses:ACustomStringClass
959APPLYINGC++
"store", "merchant, shop, warehouse","pistol", "gun, handgun, firearm",
"run", "jog, trot, race",
"think", "muse, contemplate, reflect",
"compute", "analyze, work out, solve",
"", ""};int main(){StrType x;cout << "Enter word: ";cin >> x;int i;for(i=0; thesaurus[i][0]!=""; i++)if(thesaurus[i][0]==x) cout << thesaurus[i][1];return 0;}The next example uses aStrType
object to check if there is an executable version of
aprogram,givenitsfilename.Tousetheprogram,specifythefilenamewithoutan
extensiononthecommandline.Theprogramthenrepeatedlytriestofindanexecutable

filebythatnamebyaddinganextension,tryingtoopenthatfile,andreportingthe

results. (If the file does not exist, it cannot be opened.) After each extension is tried, the

extensionissubtractedfromthefilenameandanewextensionisadded.Again,the

StrType
class and its operators make the string manipulations clean and easy to follow.
#include "str.h"#include <iostream>
#include <fstream>
using namespace std;// executable file extensionschar ext[3][4] = {"EXE",
"COM",
"BAT"};960C++:TheCompleteReference
int main(int argc, char *argv[]){StrType fname;int i;if(argc!=2) {cout << "Usage: fname\n";return 1;}fname = argv[1];
fname = fname + "."; // add periodfor(i=0; i<3; i++) {fname = fname + ext[i]; // add extension
cout << "Trying " << fname << " ";
ifstream f(fname);
if(f) {cout << "- Exists\n";
f.close();}
else cout << "- Not found\n";
fname = fname - ext[i]; // subtract extension}return 0;}For example, if this program is called ISEXEC, and assuming that TEST.EXE exists,
the command lineISEXEC TESTproduces this output:
Trying TEST.EXE - ExistsTrying TEST.COM - Not found
Trying TEST.BAT - Not foundOnethingtonoticeabouttheprogramisthatan
StrType
objectisusedbythe
ifstreamconstructor
.Thisworksbecausetheconversionfunction
char*()
isautomaticallyinvoked.
As this situation illustrates, by the careful application of C++ features, you can achieve
significantintegrationbetweenC++'sstandardtypesandtypesthatyoucreate.
Creating and Integrating New Types in General
As theStrType
class has demonstrated, it is actually quite easy to create and integrate a
new data type into the C++ environment. To do so, just follow these steps.
1.Overload all appropriate operators, including the I/O operators.
2.Define all appropriate conversion functions.

3.Provide constructors that allow objects to be easily created in a variety of
situations.Part of the power of C++ is its extensibility. Don't be afraid to take advantage of it.
A ChallengeHere is an interesting challenge that you might enjoy. Try implementing
StrType
usingtheSTL.Thatis,useacontainertostorethecharactersthatcompriseastring.Use
iterators to operate on the strings, and use the algorithms to perform the various string
manipulations.Chapter39:IntegratingNewClasses:ACustomStringClass
961APPLYINGC++
This page intentionally left blank Chapter40
Parsing Expressions963Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
964C++:TheCompleteReference
While Standard C++ is quite extensive, there are still a few things that it doesnot provide. In this chapter we will examine one of them: theexpressionparser
.An expression parser is used to evaluate an algebraic expression, such as(10 – 8) * 3. Expression parsers are quite useful and are applicable to a wide range ofapplications.Theyarealsooneofprogramming'smoreelusiveentities.Forvarious

reasons,theproceduresusedtocreateanexpressionparserarenotwidelytaughtor

disseminated. Indeed, many otherwise accomplished programmers are mystified by
the process of expression parsing.Expression parsing is actually very straightforward, and in many ways easier than
other programming tasks. The reason for this is that the task is well defined and works

accordingtothestrictrulesofalgebra.Thischapterwilldevelopwhatiscommonly

referredtoasa
recursive-descentparser
andallthenecessarysupportroutinesthat
enableyoutoevaluatenumericexpressions.Threeversionsoftheparser
willbe
created.Thefirsttwoarenongenericversions.Thefinaloneisgenericandmaybe

appliedtoanynumerictype.However,beforeanyparsercanbedeveloped,abrief

overviewofexpressionsandparsingisnecessary.
Expressions
Sinceanexpressionparserevaluatesanalgebraicexpression,itisimportanttounderstand

whattheconstituentpartsofanexpressionare.Althoughexpressionscanbemadeupofall

typesofinformation,thischapterdealsonlywithnumericexpressions.Forourpurposes,

numericexpressionsarecomposedofthefollowingitems:
NumbersThe operators +,−, /, *, ^, %, =Parentheses
Variables
For our parser, the operator
^indicates exponentiation (not the XOR as it does in C++),and=istheassignmentoperator.Theseitemscanbecombinedinexpressionsaccording

to the rules of algebra. Here are some examples:
10 – 8(100 – 5) * 14/6
a + b – c
10^5
a = 10 – bAssume this precedence for each operator:
highest+ – (unary)
^* / %
+ –lowest=
Operators of equal precedence evaluate from left to right.
Intheexamplesinthischapter,allvariablesaresingleletters(inotherwords,
26 variables,Athrough
Z, are available). The variables are not case sensitive (
aandAare treated as the same variable). For the first version of the parser, all numeric values
are elevated to
double, although you could easily write the routines to handle other
types of values. Finally, to keep the logic clear and easy to understand, only a minimal

amount of error checking is included.
Parsing Expressions: The Problem
Ifyouhavenotthoughtmuchabouttheproblemofexpressionparsing,youmightassume

that it is a simple task. However, to better understand the problem, try to evaluate this

sampleexpression:
10 – 2 * 3You know that this expression is equal to the value 4. Although you could easily create

a program that would compute that
specificexpression, the question is how to create a
program that gives the correct answer for any
arbitraryexpression. At first you might
think of a routine something like this:
a = get first operandwhile(operands present) {
op = get operator
b = get second operand
a = a op b}APPLYINGC++
Chapter40:ParsingExpressions
965966C++:TheCompleteReference
This routine gets the first operand, the operator, and the second operand to perform
the first operation and then gets the next operator and operand to perform the nextoperation, and so on. However, if you use this basic approach, the expression 10 – 2 * 3

evaluatesto24(thatis
,8*3)
insteadof4becausethisprocedureneglectstheprecedence
oftheoperators.Youcannotjusttaketheoperandsandoperatorsinorderfromleft

torightbecausetherulesofalgebradictatethatmultiplicationmustbedonebefore

subtraction.Somebeginnersthinkthatthisproblemcanbeeasilyovercome,and

sometimes, in very restricted cases, it can. But the problem only gets worse when you

add parentheses, exponentiation, variables, unary operators, and the like.
Although there are a few ways to write a routine that evaluates expressions, the
onedevelopedhereistheonemosteasilywrittenbyaperson.Itisalsothemostcommon.

Themethodusedhereiscalleda
recursive-descentparser
,andinthecourseofthischapter
youwillseehowitgotitsname.(Someoftheothermethodsusedtowriteparsers

employcomplextablesthatmustbegeneratedbyanothercomputerprogram.These

are sometimes called
table-driven parsers.)Parsing an Expression
Thereareanumberofwaystoparseandevaluateanexpression.Forusewitharecursive-

descent parser, think of expressions as
recursive data structures—
that is, expressions that
are defined in terms of themselves. If, for the moment, we assume that expressions can

onlyuse
+,,*,/,andparentheses,allexpressionscanbedefinedwiththefollowingrules:
expression
−> term [+ term] [−term]term−> factor [* factor] [/ factor]factor−> variable, number, or (expression)
Thesquarebracketsdesignateanoptionalelement,andthe
−>means
produces.
Infact,
therulesareusuallycalledthe
productionrules
oftheexpression.Therefore,youcouldsay:
"Termproducesfactortimesfactororfactordividedbyfactor"forthedefinitionof
term.Noticethattheprecedenceoftheoperatorsisimplicitinthewayanexpressionisdefined.
The expression
10 + 5 * BAPPLYINGC++
Chapter40:ParsingExpressions
967hastwoterms:10,an
d5*B.The
secondtermcontainstwofactors:5andB.Thesefactors
consist of one number and one variable.On the other hand, the expression
14 * (7 – C)hastwofactors:14and(7–C).Thefactorsconsistofonenumberandoneparenthesizedexpression.

Theparenthesizedexpressioncontainstwoterms:onenumberandonevariable.
Thisprocessformsthebasisforarecursive-descentparser,whichisasetofmutually
recursivefunctionsthatworkinachainlikefashionandimplementtheproductionrules.

Ateachappropriatestep,theparserperformsthespecifiedoperationsinthealgebraically

correct sequence. To see how the production rules are used to parse an expression, let's

work through an example using this expression:
9/3 – (100 + 56)Here is the sequence that you will follow:
1.Get the first term, 9/3.
2.Get each factor and divide the integers. The resulting value is 3.

3.Get the second term, (100 + 56). At this point, start recursively analyzing the
second subexpression.
4.Get each term and add. The resulting value is 156.

5.Return from the recursive call, and subtract 156 from 3. The answer is –153.
If you are a little confused at this point, don't feel bad. This is a fairly complex
concept that takes some getting used to. There are two basic things to remember about
this recursive view of expressions. First, the precedence of the operators is implicit in

thewaytheproductionrulesaredefined.Second,thismethodofparsingandevaluating

expressions is very similar to the way humans evaluate mathematical expressions.
Theremainderofthischapterdevelopsthreeparsers.Thefirstwillparseandevaluate
floating-point expressions of type
doublethat consist only of constant values.Next,this parser is enhanced to support the use of variables. Finally,in the third version, the

parserisimplementedasatemplateclassthatcanbeusedtoparseexpressionsof

any type.The Parser ClassTheexpressionparserisbuiltuponthe
parserclass.Thefirstversionof
parserisshown
here.Subsequentversionsoftheparserbuilduponit.
class parser {char *exp_ptr;  // points to the expressionchar token[80]; // holds current token
char tok_type;  // holds token's typevoid eval_exp2(double &result);void eval_exp3(double &result);
void eval_exp4(double &result);
void eval_exp5(double &result);
void eval_exp6(double &result);
void atom(double &result);
void get_token();
void serror(int error);
int isdelim(char c);public:parser();
double eval_exp(char *exp);};Theparserclasscontainsthreeprivatemembervariables.Theexpressiontobe
evaluatediscontainedinanull-terminatedstringpointedtoby
exp_ptr.Thus,the
parser evaluates expressions that are contained in standard ASCII strings. For example,
the following strings contain expressions that the parser can evaluate:
"10−5""2 * 3.3 / (3.1416 * 3.3)"When the parser begins execution,exp_ptrmust point to the first character in theexpression string. As the parser executes, it works its way through the string until the

null-terminator is encountered.
The meaning of the other two member variables,tokenandtok_type,are described
in the next section.The entry point to the parser is through
eval_exp( ), which must be called with apointertotheexpressiontobeanalyzed.Thefunctions
eval_exp2()
through
eval_exp6()
along withatom( )form the recursive-descent parser. They implement an enhanced set
oftheexpressionproductionrulesdiscussedearlier.Insubsequentversionsoftheparser,

a function calledeval_exp1( )will also be added.968C++:TheCompleteReference
Chapter40:ParsingExpressions
969APPLYINGC++
Theserror( )handles syntax errors in the expression. The functions
get_token( )andisdelim( )are used to dissect the expression into its component parts, as described
in the next section.Dissecting an Expression
In order to evaluate expressions, you need to be able to break an expression into its
components. Since this operation is fundamental to parsing, let's look at it before

examining the parser itself.Each component of an expression is called a
token. For example, the expression
A* B – (W + 10)
contains the tokens A, *, B, –, (, W, +, 10, and ). Each token represents an indivisible unit

of the expression. In general, you need a function that sequentially returns each token

in the expression individually. The function must also be able to skip over spaces and

tabs and detect the end of the expression. The function that we will use to perform this

task is calledget_token( ), which is a member function of theparserclass.Besidesthetoken,itself,youwillalsoneedtoknowwhattypeoftokenisbeing
returned.Fortheparserdevelopedinthischapter,youneedonlythreetypes:
VARIABLE
,NUMBER,and
DELIMITER.(DELIMITERisusedforbothoperatorsandparentheses.)
Theget_token()
functionisshownhere.Itobtainsthenexttokenfromtheexpression
pointedtoby
exp_ptrandputsitintothemembervariable
token.Itputsthetypeofthe
tokenintothemembervariable
tok_type.// Obtains the next token.void parser::get_token()
{register char *temp;tok_type = 0;temp = token;
*temp = '\0';if(!*exp_ptr) return; // at end of expression
while(isspace(*exp_ptr)) ++exp_ptr; // skip over white space
if(strchr("+-*/%^=()", *exp_ptr)){tok_type = DELIMITER;970C++:TheCompleteReference
// advance to next char*temp++ = *exp_ptr++;}else if(isalpha(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;
tok_type = VARIABLE;}
else if(isdigit(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;
tok_type = NUMBER;}*temp = '\0';}
// Return true if c is a delimiter.int parser::isdelim(char c)
{if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)return 1;return 0;}Lookcloselyattheprecedingfunctions.Afterthefirstfewinitializations,
get_token()
checkstoseeifthenullterminatingtheexpressionhasbeenfound.Itdoessobychecking
the character pointed to byexp_ptr. Sinceexp_ptris a pointer to the expression being
analyzed, if it points to a null, the end of the expression has been reached. If there are

stillmoretokenstoretrievefromtheexpression,
get_token()
firstskipsoveranyleading
spaces. Once the spaces have been skipped,exp_ptris pointing to either a number, a
variable,anoperator,oriftrailingspacesendtheexpression,anull.Ifthenextcharacter

isanoperator,itisreturnedasastringin
token,and
DELIMITERisplacedin
tok_type.Ifthenextcharacterisaletterinstead,itisassumedtobeoneofthevariables.Itis

returnedasastringin
token,and
tok_typeisassignedthevalue
VARIABLE
.Ifthe
next character is a digit, the entire number is read and placed in its string form in
tokenanditstypeis
NUMBER.Finally,ifthenextcharacterisnoneofthepreceding,itis
assumedthattheendoftheexpressionhasbeenreached.Inthiscase,
tokenisnull,
which signals the end of the expression.
As stated earlier, to keep the code in this function clean, a certain amount of error
checking has been omitted and some assumptions have been made. For example, any
unrecognized character may end an expression. Also, in this version, variables may be

of any length, but only the first letter is significant. You can add more error checking

and other details as your specific application dictates.Chapter40:ParsingExpressions
971APPLYINGC++
To better understand the tokenization process, study what it returns for each token
and type in the following expression:
A+ 100 – (B * C) /2
Token
Token type
AVARIABLE
+DELIMITER
100NUMBER
−DELIMITER(DELIMITER
BVARIABLE

*DELIMITER

CVARIABLE

)DELIMITER

/DELIMITER

2NUMBER

nullnull
Remember thattokenalways holds a null-terminated string, even if it contains justa single character.
A Simple Expression Parser
Here is the first version of the parser. It can evaluate expressions that consist solely of
constants,operators,andparentheses.Itcannotacceptexpressionsthatcontainvariables.
/* This module contains the recursive descentparser that does not use variables.*/#include <iostream>#include <cstdlib>
#include <cctype>
#include <cstring>using namespace std;enum types { DELIMITER = 1, VARIABLE, NUMBER};
class parser {char *exp_ptr;  // points to the expressionchar token[80]; // holds current token
char tok_type;  // holds token's typevoid eval_exp2(double &result);void eval_exp3(double &result);
void eval_exp4(double &result);
void eval_exp5(double &result);
void eval_exp6(double &result);
void atom(double &result);
void get_token();
void serror(int error);
int isdelim(char c);public:parser();
double eval_exp(char *exp);};// Parser constructor.parser::parser()
{exp_ptr = NULL;}// Parser entry point.double parser::eval_exp(char *exp)
{double result;exp_ptr = exp;
get_token();if(!*token) {serror(2); // no expression present
return 0.0;}
eval_exp2(result);972C++:TheCompleteReference
if(*token) serror(0); // last token must be nullreturn result;}// Add or subtract two terms.void parser::eval_exp2(double &result)
{register char op;double temp;eval_exp3(result);while((op = *token) == '+' || op == '-') {get_token();
eval_exp3(temp);
switch(op) {case '-':result = result - temp;
break;case '+':result = result + temp;
break;}}}// Multiply or divide two factors.void parser::eval_exp3(double &result)
{register char op;
double temp;eval_exp4(result);while((op = *token) == '*' || op == '/' || op == '%') {get_token();
eval_exp4(temp);
switch(op) {case '*':result = result * temp;
break;case '/':result = result / temp;
break;Chapter40:ParsingExpressions
973APPLYINGC++
case '%':result = (int) result % (int) temp;break;}}}// Process an exponent.void parser::eval_exp4(double &result)
{double temp, ex;
register int t;eval_exp5(result);if(*token== '^') {get_token();
eval_exp4(temp);
ex = result;
if(temp==0.0) {result = 1.0;
return;}
for(t=(int)temp-1; t>0; --t) result = result * (double)ex;}}// Evaluate a unary + or -.void parser::eval_exp5(double &result)
{register char  op;op = 0;if((tok_type == DELIMITER) && *token=='+' || *token == '-') {op = *token;
get_token();}
eval_exp6(result);
if(op=='-') result = -result;}// Process a parenthesized expression.void parser::eval_exp6(double &result)974C++:TheCompleteReference
{if((*token == '(')) {get_token();eval_exp2(result);
if(*token != ')')serror(1);get_token();}
else atom(result);}// Get the value of a number.void parser::atom(double &result)
{switch(tok_type) {case NUMBER:result = atof(token);
get_token();
return;default:serror(0);}}// Display a syntax error.void parser::serror(int error)
{static char *e[]= {"Syntax Error",
"Unbalanced Parentheses",
"No expression Present"};
cout << e[error] << endl;}// Obtain the next token.void parser::get_token()
{register char *temp;tok_type = 0;temp = token;Chapter40:ParsingExpressions
975APPLYINGC++
976C++:TheCompleteReference
*temp = '\0';if(!*exp_ptr) return; // at end of expression
while(isspace(*exp_ptr)) ++exp_ptr; // skip over white space
if(strchr("+-*/%^=()", *exp_ptr)){tok_type = DELIMITER;// advance to next char
*temp++ = *exp_ptr++;}
else if(isalpha(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;
tok_type = VARIABLE;}
else if(isdigit(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;
tok_type = NUMBER;}*temp = '\0';}
// Return true if c is a delimiter.int parser::isdelim(char c)
{if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)return 1;return 0;}Theparserasitisshowncanhandlethefollowingoperators:
+,–,*,/,%.Inaddition,
it can handle integer exponentiation (^) and the unary minus. The parser can also dealwith parentheses correctly. The actual evaluation of an expression takes place in the

mutuallyrecursivefunctions
eval_exp2()
through
eval_exp6()
,plusthe
atom()
function,whichreturnsthevalueofanumber.Thecommentsatthestartofeachfunctiondescribe

what role it plays in parsing the expression.
The simplemain( )function that follows demonstrates the use of the parser.
int main(){APPLYINGC++
Chapter40:ParsingExpressions
977char expstr[80];cout << "Enter a period to stop.\n";
parser ob; // instantiate a parser
for(;;) {cout << "Enter expression: ";cin.getline(expstr, 79);
if(*expstr=='.') break;
cout << "Answer is: " << ob.eval_exp(expstr) << "\n\n";};return 0;}Here is a sample run.
Enter a period to stop.Enter expression: 10-2*3
Answer is: 4Enter expression: (10-2)*3Answer is: 24Enter expression: 10/3Answer is: 3.33333Enter expression: .Understanding the ParserTo understand exactly how the parser evaluates an expression, work through the
following expression. (Assume that
exp_ptrpoints to the start of the expression.)
10 – 3 * 2Wheneval_exp()
,theentrypointintotheparser,iscalled,itgetsthefirsttoken.If
thetokenisnull,thefunctionprintsthemessage
NoExpressionPresent
andreturns.
However,inthiscase,thetokencontainsthenumber
10.Sincethefirsttokenisnotnull,
eval_exp2()
iscalled.Asaresult,
eval_exp2()
callseval_exp3()
,and
eval_exp3()
calls978C++:TheCompleteReference
eval_exp4()
,whichinturncalls
eval_exp5()
.Then
eval_exp5()
checkswhetherthe
tokenisaunaryplusorminus,whichinthiscaseitisnot,so
eval_exp6()
iscalled.At
thispoint
eval_exp6()
eitherrecursivelycalls
eval_exp2()
(inthecaseofaparenthesized
expression)orcalls
atom()
tofindthevalueofanumber.Sincethetokenisnotaleft
parentheses,
atom()
isexecutedand
resultisassignedthevalue10.Next,anothertoken
isretrieved,andthefunctionsbegintoreturnupthechain.Sincethetokenisnowthe
operator–,thefunctionsreturnupto
eval_exp2()
.Whathappensnextisveryimportant.Becausethetokenis
–,itissavedin
op.The
parserthengetsthenexttoken,whichis
3,andthedescentdownthechainbeginsagain.
Asbefore,
atom()
isentered.Thevalue3isreturnedin
result,andthetoken
*isread.
Thiscausesareturnbackupthechainto
eval_exp3()
,wherethefinaltoken2isread.At
thispoint,thefirstarithmeticoperationoccurs—themultiplicationof2and3.Theresult

isreturnedto
eval_exp2()
,andthesubtractionisperformed.Thesubtractionyieldsthe
answer4.Althoughtheprocessmayatfirstseemcomplicated,workthroughsomeother

examplestoverifythatthismethodfunctionscorrectlyeverytime.
Thisparserwouldbesuitableforusebyasimpledesktopcalculator,asisillustrated
by the previous program. Before it could be used in a computer language, database, or

inasophisticatedcalculator,however,itwouldneedtheabilitytohandlevariables.This

is the subject of the next section.Adding Variables to the Parser
All programming languages, many calculators, and spreadsheets use variables to store

values for later use. Before the parser can be used for such applications, it needs to be

expandedtoincludevariables.Toaccomplishthis,youneedtoaddseveralthingstothe

parser.First,ofcourse,arethevariablesthemselves.Asstatedearlier,wewillusethe

lettersAthrough
Zforvariables.Thevariableswillbestoredinanarrayinsidethe
parserclass. Each variable uses one array location in a 26-element array ofdoubles. Therefore,
add the following to theparserclass:double vars[NUMVARS]; // holds variables' valuesYou will also need to change the
parserconstructor, as shown here.
// parser constructorparser::parser()
{int i;exp_ptr = NULL;for(i=0; i<NUMVARS; i++) vars[i] = 0.0;}As you can see, the variables are initialized to 0 as a courtesy to the user.
You will also need a function to look up the value of a given variable. Because the
variables are named
Athrough
Z, they can easily be used to index the arrayvarsbysubtractingtheASCIIvaluefor
Afromthevariablename.Thememberfunction
find_var( ), shown here, accomplishes this:
// Return the value of a variable.double parser::find_var(char *s)
{if(!isalpha(*s)){serror(1);
return 0.0;}
return vars[toupper(*token)-'A'];}As this function is written, it will actually accept long variable names, but only the firstletter is significant. You may modify this to fit your needs.
You must also modify the
atom( )function to handle both numbers and variables.The new version is shown here:
// Get the value of a number or a variable.void parser::atom(double &result)
{switch(tok_type) {case VARIABLE:result = find_var(token);
get_token();
return;case NUMBER:result = atof(token);
get_token();
return;default:serror(0);}}Chapter40:ParsingExpressions
979APPLYINGC++
Technically, these additions are all that is needed for the parser to use variables
correctly; however, there is no way for these variables to be assigned a value. Often this
is done outside the parser, but you can treat the equal sign as an assignment operator

(which is how it is handled in C++) and make it part of the parser. There are various

waystodothis.Onemethodistoaddanotherfunction,called
eval_exp1()
,tothe
parserclass. This function will now begin the recursive-descent chain. This means that
it, noteval_exp2( ), must be called byeval_exp( )to begin parsing the expression.
eval_exp1( )is shown here:
// Process an assignment.void parser::eval_exp1(double &result)
{int slot;
char ttok_type;
char temp_token[80];if(tok_type==VARIABLE) {// save old tokenstrcpy(temp_token, token);
ttok_type = tok_type;// compute the index of the variableslot = toupper(*token) - 'A';get_token();if(*token != '=') {putback(); // return current token
// restore old token - not assignment
strcpy(token, temp_token);
tok_type = ttok_type;}
else {get_token(); // get next part of exp
eval_exp2(result);
vars[slot] = result;
return;}}eval_exp2(result);}980C++:TheCompleteReference
Asyoucansee,thefunctionneedstolookaheadtodeterminewhetheranassignment
is actually being made. This is because a variable name always precedes an assignment,
but a variable name alone does not guarantee that an assignment expression follows.

That is, the parser will accept A= 100 as an assignment, but is also smart enough to

know that A/10 is not. To accomplish this,
eval_exp1( )reads the next token from the
input stream. If it is not an equal sign, the token is returned to the input stream for later

use by callingputback( ). Theputback( )function must also be included in theparserclass. It is shown here:
// Return a token to the input stream.void parser::putback()
{char *t;t = token;for(; *t; t++) exp_ptr--;}After making all the necessary changes, the parser will now look like this./* This module contains the recursive descentparser that recognizes variables.*/#include <iostream>#include <cstdlib>
#include <cctype>
#include <cstring>
using namespace std;enum types { DELIMITER = 1, VARIABLE, NUMBER};
const int NUMVARS = 26;
class parser {char *exp_ptr;  // points to the expressionchar token[80]; // holds current token
char tok_type;  // holds token's type
double vars[NUMVARS]; // holds variables' valuesvoid eval_exp1(double &result);void eval_exp2(double &result);Chapter40:ParsingExpressions
981APPLYINGC++
void eval_exp3(double &result);void eval_exp4(double &result);
void eval_exp5(double &result);
void eval_exp6(double &result);
void atom(double &result);
void get_token();
void putback();
void serror(int error);
double find_var(char *s);
int isdelim(char c);public:parser();double eval_exp(char *exp);};// Parser constructor.parser::parser()
{int i;exp_ptr = NULL;
for(i=0; i<NUMVARS; i++) vars[i] = 0.0;}
// Parser entry point.double parser::eval_exp(char *exp)
{double result;exp_ptr = exp;
get_token();if(!*token) {serror(2); // no expression present
return 0.0;}
eval_exp1(result);
if(*token) serror(0); // last token must be null
return result;}982C++:TheCompleteReference
// Process an assignment.void parser::eval_exp1(double &result)
{int slot;char ttok_type;
char temp_token[80];if(tok_type==VARIABLE) {// save old tokenstrcpy(temp_token, token);
ttok_type = tok_type;// compute the index of the variableslot = toupper(*token) - 'A';get_token();if(*token != '=') {putback(); // return current token
// restore old token - not assignment
strcpy(token, temp_token);
tok_type = ttok_type;}
else {get_token(); // get next part of exp
eval_exp2(result);
vars[slot] = result;
return;}}eval_exp2(result);}
// Add or subtract two terms.void parser::eval_exp2(double &result)
{register char op;
double temp;eval_exp3(result);while((op = *token) == '+' || op == '-') {get_token();Chapter40:ParsingExpressions
983APPLYINGC++
eval_exp3(temp);switch(op) {case '-':result = result - temp;break;case '+':result = result + temp;
break;}}}// Multiply or divide two factors.void parser::eval_exp3(double &result)
{register char op;
double temp;eval_exp4(result);while((op = *token) == '*' || op == '/' || op == '%') {get_token();
eval_exp4(temp);
switch(op) {case '*':result = result * temp;
break;case '/':result = result / temp;
break;case '%':result = (int) result % (int) temp;
break;}}}// Process an exponent.void parser::eval_exp4(double &result)
{double temp, ex;
register int t;984C++:TheCompleteReference
eval_exp5(result);if(*token== '^') {get_token();eval_exp4(temp);
ex = result;
if(temp==0.0) {result = 1.0;
return;}
for(t=(int)temp-1; t>0; --t) result = result * (double)ex;}}// Evaluate a unary + or -.void parser::eval_exp5(double &result)
{register char  op;op = 0;if((tok_type == DELIMITER) && *token=='+' || *token == '-') {op = *token;
get_token();}
eval_exp6(result);
if(op=='-') result = -result;}// Process a parenthesized expression.void parser::eval_exp6(double &result)
{if((*token == '(')) {get_token();
eval_exp2(result);
if(*token != ')')serror(1);get_token();}
else atom(result);}// Get the value of a number or a variable.void parser::atom(double &result)Chapter40:ParsingExpressions
985APPLYINGC++
{switch(tok_type) {case VARIABLE:result = find_var(token);get_token();
return;case NUMBER:result = atof(token);
get_token();
return;default:serror(0);}}// Return a token to the input stream.void parser::putback()
{char *t;t = token;for(; *t; t++) exp_ptr--;}// Display a syntax error.void parser::serror(int error)
{static char *e[]= {"Syntax Error",
"Unbalanced Parentheses",
"No expression Present"};
cout << e[error] << endl;}// Obtain the next token.void parser::get_token()
{register char *temp;tok_type = 0;temp = token;986C++:TheCompleteReference
*temp = '\0';if(!*exp_ptr) return; // at end of expression
while(isspace(*exp_ptr)) ++exp_ptr; // skip over white space
if(strchr("+-*/%^=()", *exp_ptr)){tok_type = DELIMITER;// advance to next char
*temp++ = *exp_ptr++;}
else if(isalpha(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;
tok_type = VARIABLE;}
else if(isdigit(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;
tok_type = NUMBER;}*temp = '\0';}
// Return true if c is a delimiter.int parser::isdelim(char c)
{if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)return 1;return 0;}// Return the value of a variable.double parser::find_var(char *s)
{if(!isalpha(*s)){serror(1);
return 0.0;}
return vars[toupper(*token)-'A'];}Chapter40:ParsingExpressions
987APPLYINGC++
988C++:TheCompleteReference
To try the enhanced parser, you may use the same
main( )function that you usedfor the simple parser. With the enhanced parser, you can now enter expressions like
A= 10/4
A– B

C = A* (F – 21)
Syntax Checking in a Recursive-Descent ParserBefore moving on to the template version of the parser, let's briefly look at syntax
checking. In expression parsing, a syntax error is simply a situation in which the input

expression does not conform to the strict rules required by the parser. Most of the time,

this is caused by human error, usually typing mistakes. For example, the following

expressions are not valid for the parsers in this chapter:
10 ** 8(10 – 5) * 9)
/8The first contains two operators in a row, the second has unbalanced parentheses, and
the last has a division sign at the start of an expression. None of these conditions is

allowed by the parsers. Because syntax errors can cause the parser to give erroneous

results, you need to guard against them.
As you studied the code of the parsers, you probably noticed the
serror( )function,whichiscalledundercertainsituations.Unlikemanyotherparsers,therecursive-

descentmethodmakessyntaxcheckingeasybecause,forthemostpart,itoccursin

atom( ),find_var( ), oreval_exp6()
, where parentheses are checked. The only problem
with the syntax checking as it now stands is that the entire parser is not terminated on

syntax error. This can lead to multiple error messages.
The best way to implement theserror( )function is to have it execute some sort ofreset. For example, all C++ compilers come with a pair of companion functions called

setjmp( )andlongjmp()
. These two functions allow a program to branch to a
different
function. Therefore,
serror( )could execute alongjmp( )to some safe point in yourprogram outside the parser.
Depending upon the use you put the parser to, you might also find that C++'sexception handling mechanism (implemented through
try,catch, andthrow) will bebeneficial when handling errors.
If you leave the code the way it is, multiple syntax-error messages may be issued.
This can be an annoyance in some situations but a blessing in others because multiple
errorsmaybecaught.Generally,however,youwillwanttoenhancethesyntaxchecking

before using it in commercial programs.
Building a Generic ParserThe two preceding parsers operated on numeric expressions in which all values were
assumedtobeoftype
double.Whilethisisfineforapplicationsthatuse
doublevalues,it is certainly excessive for applications that use only integer values, for example. Also,
byhard-codingthetypeofvaluesbeingevaluated,theapplicationoftheparseris

unnecessarilyrestricted.Fortunately,byusingaclasstemplate,itisaneasytaskto

createagenericversionoftheparserthatcanworkwithanytypeofdataforwhich

algebraic-style expressions are defined. Once this has been done, the parser can be used

both with built-in types and with numeric types that you create.
Here is the generic version of the expression parser.
// A generic parser.#include <iostream>#include <cstdlib>
#include <cctype>
#include <cstring>
using namespace std;enum types { DELIMITER = 1, VARIABLE, NUMBER};
const int NUMVARS = 26;
template <class PType> class parser {char *exp_ptr;  // points to the expressionchar token[80]; // holds current token
char tok_type;  // holds token's type
PType vars[NUMVARS]; // holds variable's valuesvoid eval_exp1(PType &result);void eval_exp2(PType &result);
void eval_exp3(PType &result);
void eval_exp4(PType &result);
void eval_exp5(PType &result);
void eval_exp6(PType &result);
void atom(PType &result);
void get_token(), putback();
void serror(int error);
PType find_var(char *s);
int isdelim(char c);public:Chapter40:ParsingExpressions
989APPLYINGC++
990C++:TheCompleteReference
parser();PType eval_exp(char *exp);};// Parser constructor.template <class PType> parser<PType>::parser()
{int i;exp_ptr = NULL;
for(i=0; i<NUMVARS; i++) vars[i] = (PType) 0;}
// Parser entry point.template <class PType> PType parser<PType>::eval_exp(char *exp)
{PType result;exp_ptr = exp;
get_token();if(!*token) {serror(2); // no expression present
return (PType) 0;}
eval_exp1(result);
if(*token) serror(0); // last token must be null
return result;}// Process an assignment.template <class PType> void parser<PType>::eval_exp1(PType &result)
{int slot;
char ttok_type;
char temp_token[80];if(tok_type==VARIABLE) {// save old tokenstrcpy(temp_token, token);
ttok_type = tok_type;// compute the index of the variableslot = toupper(*token) - 'A';get_token();if(*token != '=') {putback(); // return current token// restore old token - not assignment
strcpy(token, temp_token);
tok_type = ttok_type;}else {get_token(); // get next part of exp
eval_exp2(result);
vars[slot] = result;
return;}}eval_exp2(result);}
// Add or subtract two terms.template <class PType> void parser<PType>::eval_exp2(PType &result)
{register char op;
PType temp;eval_exp3(result);while((op = *token) == '+' || op == '-') {get_token();
eval_exp3(temp);
switch(op) {case '-':result = result - temp;
break;case '+':result = result + temp;
break;}}}Chapter40:ParsingExpressions
991APPLYINGC++
992C++:TheCompleteReference
// Multiply or divide two factors.template <class PType> void parser<PType>::eval_exp3(PType &result)
{register char op;PType temp;eval_exp4(result);while((op = *token) == '*' || op == '/' || op == '%') {get_token();
eval_exp4(temp);
switch(op) {case '*':result = result * temp;
break;case '/':result = result / temp;
break;case '%':result = (int) result % (int) temp;
break;}}}// Process an exponent.template <class PType> void parser<PType>::eval_exp4(PType &result)
{PType temp, ex;
register int t;eval_exp5(result);if(*token== '^') {get_token();
eval_exp4(temp);
ex = result;
if(temp==0.0) {result = (PType) 1;
return;}
for(t=(int)temp-1; t>0; --t) result = result * ex;}}// Evaluate a unary + or -.template <class PType> void parser<PType>::eval_exp5(PType &result)
{register char  op;op = 0;if((tok_type == DELIMITER) && *token=='+' || *token == '-') {op = *token;
get_token();}
eval_exp6(result);
if(op=='-') result = -result;}// Process a parenthesized expression.template <class PType> void parser<PType>::eval_exp6(PType &result)
{if((*token == '(')) {get_token();
eval_exp2(result);
if(*token != ')')serror(1);get_token();}
else atom(result);}// Get the value of a number or a variable.template <class PType> void parser<PType>::atom(PType &result)
{switch(tok_type) {case VARIABLE:result = find_var(token);
get_token();
return;case NUMBER:result = (PType) atof(token);
get_token();
return;default:serror(0);}Chapter40:ParsingExpressions
993APPLYINGC++
}// Return a token to the input stream.template <class PType> void parser<PType>::putback()
{char *t;t = token;for(; *t; t++) exp_ptr--;}// Display a syntax error.template <class PType> void parser<PType>::serror(int error)
{static char *e[]= {"Syntax Error",
"Unbalanced Parentheses",
"No expression Present"};
cout << e[error] << endl;}// Obtain the next token.template <class PType> void parser<PType>::get_token()
{register char *temp;tok_type = 0;temp = token;
*temp = '\0';if(!*exp_ptr) return; // at end of expression
while(isspace(*exp_ptr)) ++exp_ptr; // skip over white space
if(strchr("+-*/%^=()", *exp_ptr)){tok_type = DELIMITER;// advance to next char
*temp++ = *exp_ptr++;}
else if(isalpha(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;994C++:TheCompleteReference
tok_type = VARIABLE;}else if(isdigit(*exp_ptr)) {while(!isdelim(*exp_ptr)) *temp++ = *exp_ptr++;tok_type = NUMBER;}*temp = '\0';}
// Return true if c is a delimiter.template <class PType> int parser<PType>::isdelim(char c)
{if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)return 1;return 0;}// Return the value of a variable.template <class PType> PType parser<PType>::find_var(char *s)
{if(!isalpha(*s)){serror(1);
return (PType) 0;}
return vars[toupper(*token)-'A'];}Asyoucansee,thetypeofdatanowoperateduponbytheparserisspecifiedbythe
generictype
PType
.Thefollowing
main()
functiondemonstratesthegenericparser.
int main()
{char expstr[80];// Demonstrate floating-point parser.parser<double> ob;cout << "Floating-point parser.  ";cout << "Enter a period to stop\n";
for(;;) {Chapter40:ParsingExpressions
995APPLYINGC++
cout << "Enter expression: ";cin.getline(expstr, 79);
if(*expstr=='.') break;
cout << "Answer is: " << ob.eval_exp(expstr) << "\n\n";}cout << endl;// Demonstrate integer-based parser.parser<int> Iob;cout << "Integer parser.  ";cout << "Enter a period to stop\n";
for(;;) {cout << "Enter expression: ";
cin.getline(expstr, 79);
if(*expstr=='.') break;
cout << "Answer is: " << Iob.eval_exp(expstr) << "\n\n";}return 0;}Here is a sample run.
Floating-point parser.  Enter a period to stopEnter expression: a=10.1
Answer is: 10.1Enter expression: b=3.2Answer is: 3.2Enter expression: a/bAnswer is: 3.15625Enter expression: .
Integer parser.  Enter a period to stopEnter expression: a=10
Answer is: 10Enter expression: b=3996C++:TheCompleteReference
Answer is: 3Enter expression: a/bAnswer is: 3Enter expression: .Asyoucansee,thefloating-pointparserusesfloating-pointvalues,andtheintegerparser
usesintegervalues.
Some Things to Try
As mentioned early on in this chapter, only minimal error checking is performed by the

parser.Youmightwanttoadddetailederrorreporting.Forexample,youcouldhighlight

the point in the expression at which an error was detected. This would allow the user

to find and correct a syntax error.
As the parser now stands it can evaluate only numeric expressions. However, with
afewadditions,itispossibletoenabletheparsertoevaluateothertypesofexpressions,

such as strings, spatial coordinates, or complex numbers. For example, to allow the

parser to evaluate string objects, you must make the following changes:1.Define a new token type called STRING.
2.Enhance
get_token( )so that it recognizes strings.
3.Add a new case inside
atom( )that handles STRING type tokens.After implementing these steps, the parser could handle string expressions like these:
a = "one"b = "two"
c = a + bThe result in
cshould be the concatenation ofaandb, or "onetwo".Hereisonegoodapplicationfortheparser:createasimple,pop-upmini-calculatorthat
acceptsanexpressionenteredbytheuserandthendisplaystheresult.Thiswouldmakean
excellent addition to nearly any commercial application. If you are programming for

Windows,thiswouldbeespeciallyeasytodo.
Chapter40:ParsingExpressions
997APPLYINGC++
This page intentionally left blank AppendixAThe .NET ManagedExtensions to C++999Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
1000C++:TheCompleteReference
Microsoft’s.NETFrameworkdefinesanenvironmentthatsupportsthe
developmentandexecutionofhighly-distributed,component-basedapplications.

It enables differing computer languages to work together, and provides forsecurity, program portability, and a common programming model for the Windows
platform. Although the .NET Framework is a relatively recent addition to computing,
it is an environment in which many C++ programmers will likely be working in the
near future.Microsoft’s.NETFrameworkprovidesamanagedenvironmentthatoversees
program execution. Aprogram targeted for the .NET Framework is not compiled into

executable object code. Rather, it is compiled into Microsoft Intermediate Language

(MSIL), which is then executed under the control of the Common Language Runtime

(CLR). Managed execution is the mechanism that supports the key advantages offered

by the .NET Framework.To take advantage of .NET managed execution, it is necessary for a C++ program
to use a set of nonstandard, extended keywords and preprocessor directives that have

been defined by Microsoft. It is important to understand that these extensions are not

defined by ANSI/ISO standard C++. Thus, code in which they are used is nonportable

to other environments.
It is far beyond the scope of this book to describe the .NET Framework, or the C++programming techniques necessary to utilize it. (Athorough explanation of the .NET

Framework and how to create C++ code for it would easily fill a large book!) However,

a brief synopsis of the .NET managed extensions to C++ is given here for the benefit of

those programmers working in the .NET environment. Abasic understanding of the

.NET Framework is assumed.The .NET Keyword Extensions
To support the .NET managed execution environment, Microsoft adds the following

keywords to the C++ language:
_ _abstract_ _box_ _delegate
_ _event_ _finally_ _gc

_ _identifier_ _interface_ _nogc

_ _pin_ _property
_ _sealed_ _try_cast_ _typeof_ _valueEach of these is briefly described in the following sections._ _abstract_ _abstractis used in conjunction with_ _gcto specify an abstract managed class.No object of an_ _abstractclass can be created. Aclass specified as
_ _abstractisnot required to contain pure virtual functions.
AppendixA:The.NETManagedExtensionstoC++
1001APPENDIXES_ _box_ _boxwraps a valuewithin an object. Boxing enables a value type to be used by code
that requires an object derived from
System::Object, which is the base class of all .NETobjects._ _delegate_ _delegatespecifies a delegate, which encapsulates a pointer to a function withina managed class (that is, a class modified by_ _gc)._ _event__event
specifiesafunctionthatrepresentsanevent.Onlytheprototypeforthefunctionisspecified.
_ _finally_ _finallyis an addition to the standard C++ exception handling mechanism. It is used
to specify a block of code that will execute when atry/catchblock is left. It does notmatterwhatconditionscausethe
try/catchblocktoterminate.Inallcases,the
__finally
block willbe executed._ _gc__gc
specifiesamanagedclass.Here,“gc”standsfor“garbagecollection”andindicates
thatobjectsoftheclassareautomaticallygarbagecollectedwhentheyarenolonger
needed. An object is no longer needed when no references to the object exist. Objects

of a_ _gcclass must be created using
new. Arrays, pointers, and interfaces can also bespecified as_ _gc._ _identifier__identifier
allowsaC++keywordtobeusedasanidentifier.Thisisaspecial-purpose
extension that will not be used by most programs.
_ _interface
_ _interfacespecifies a class that will act as an interface. In an interface, no function caninclude a body. All functions in an interface are implicitly pure virtual functions. Thus,

an interface is essentially an abstract class in which no function has an implementation._ _nogc_ _nogcspecifies a nonmanaged class. Since this is the type of class created by default,
the_ _nogckeyword is not usually used.
1002C++:TheCompleteReference
_ _pin_ _pinis used to specify a pointer that fixes the location in memory of the object towhich it points. Thus, an object that is “pinned” will not be moved in memory by thegarbage collector. As a result, garbage collection does not invalidate a pointer modified

by_ _pin._ _property
_ _propertyspecifies a property, which is a member function that gets or sets the value
ofamembervariable.Propertiesprovideaconvenientmeanstocontrolaccesstoprivate

or protected data.
_ _sealed_ _sealedprevents the class that it modifies from being inherited. It can also be used to
specify that a virtual function cannot be overridden._ _try_cast
_ _try_castattempts to cast one type of expression into another. If the cast fails, an
exception of typeSystem::InvalidCastExceptionis thrown.
_ _typeof__typeof
obtainsanobjectthatencapsulatestypeinformationforagiventype.Thisobjectis an
instance ofSystem::Type
._ _value_ _valuespecifies a class that is represented as a value type. Avalue type holds its own
values. This differs from a
_ _gctype, which must allocate storage through the use of
new. Value types are not subject to garbage collection.
Preprocessor Extensions
To support .NET, Microsoft defines the
#usingpreprocessor directive, which is used to
import metadata into your program. Metadata contains type and member information

in a form that is independent of a specific computer language. Thus, metadata helps
supportmixed-languageprogramming.AllmanagedC++programsmustimport

<mscorlib.dll>, which contains the metadata for the .NET Framework.Microsoft defines two pragmas that relate to the .NET Framework. (Pragmas are
used with the#pragmapreprocessing directive.) The first is,
managed, which specifiesmanaged code. The second isunmanaged, which specifies unmanaged (that is, native)code. These pragmas can be used within a program to selectively create managed and

unmanaged code.The attribute AttributeMicrosoft defines
attribute, which is the attribute used to declare another attribute.
Compiling Managed C++Atthetimeofthiswriting,theonlycompilercommonlyavailablethatcantargetthe
.NET Framework is the one supplied by Microsoft’s Visual Studio .NET. To compile a

managedcodeprogram,youmustusethe
/clroption,whichtargetscodeforthe
Common Language Runtime.AppendixA:The.NETManagedExtensionstoC++
1003APPENDIXESThis page intentionally left blank AppendixBC++ and theRobotics Age1005Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
Ihave had a long term interest in robotics, especially robotic control languages. Infact, years ago I designed and implemented industrial robotic control languages foruseonsmalleducationalrobots.AlthoughInolongerworkprofessionallyinthearea
ofrobotics,itremainsanimportantandengagingspecialinterestofmine.Overtheyears

Ihaveseenthecapabilitiesofrobots(andthecodethatcontrolsthem)makemajorleaps

forward. We now stand at the beginning of the robotics age. There are already robots
thatcanmowthelawnandvacuumthefloor.Theyassembleourcarsandworkin

environmentsdangeroustohumans.Battlefieldrobotsarenowbecomingareality.

Many more robotic applications are on the way. As robots become more commonplace,
integratingthemselvesintothefabricofeverydaylife,increasingnumbersofprogrammers

willfindthemselveswritingroboticcontrolcode.And,muchofthatcodewillbeinC++.
C++ is a natural choice for robotic programming because robots require efficient,
high-performance code. This is especially true for the low-level motor control routines,

andforsuchthingsasvisionprocessing,wherespeedisquiteimportant.Althoughsome

parts of a robotic subsystem, such as a natural language processor, may be written in a

language such as C#, the low-level code will almost certainly remain in C++. C++ and

robotics go hand-in-hand.
Ifyouareinterestedinrobotics,especiallyifyouareinterestedincreatingyourown
robot for experimentation, then you might find the robot in Figure B-1 of interest. This

is my current test robot. Several things make this robot interesting. First, it contains an
1006C++:TheCompleteReference
FigureB-1.
A simple, yet effective experimental robot (Photo by Ken Kaiser)
AppendixB:C++andtheRoboticsAge
1007APPENDIXESon-boardmicroprocessorthatprovidesbasicmotorcontrolandsensorfeedback.
Second,itcontainsanRS-232transceiverthatisusedtoreceiveinstructionsfrom

themaincomputerandreturnresults.Thisapproachenablesaremotecomputerto

providetheintensiveprocessingthatisnecessaryinroboticswithoutaddingallthat

weighttotherobot,itself.Third,itcontainsavideocamerathatisconnectedtoawireless

video transmitter.
The robot is built on a Hobbico M1 Abrams R/C tank chassis. (I have found that the
chassis of R/C model tanks and cars often work well as a robot base.) I removed most

of the internals from the tank, including the receiver and speed controls, but I kept the

motors.TheHobbicotankiswellsuitedforaroboticsplatformbecauseitisquitestrong,

the motors are good, it can carry a lot of weight, and its tank treads don’t fall off. Also,

byusingtanktreads,therobothasazeroturningradiusandcanrunonunevenground.

The chassis is about 18 inches long and about 8 inches wide.Oncethechassiswasempty,Iaddedthefollowingcomponents.Toprovide
on-boardcontrol,IusedaBASICStamp2,whichisasimple,yetpowerfulmicroprocessor

manufactured by Parallax. Inc. (www.parallaxinc.com). The RS-232 transceiver is also

fromParallax,asisthevideocameraandtransmitter.BoththewirelessRS-232transceiver

and the video transmitter have a range of about 300 feet. I also added electronic speed

controllers for the tank motors. They are of the type used by high-performance R/C

cars. They are controlled by the BASIC Stamp microprocessor.
Hereisthewaytherobotworks.Theremotecomputerrunsthemainroboticcontrol
program. This program handles all “heavy-duty” processing, such as vision, guidance,

andspatialorientation.Itcanalsolearnaseriesofmovesandthenreplaythem.The

remote computer transmits motion-control instructions (via the wireless RS-232 link) to

the robot. The BASIC Stamp receives those instructions and puts them into action. For

example, if a “move forward” command is received, the BASIC Stamp sends the proper

signals to the electronic speed controllers connected to the motors. When the robot has

completedacommand,itreturnsanacknowledgementcode.Thus,communication

betweentheremotecomputerandtherobotisbi-directional,andthesuccessfulcompletion

of each command can be confirmed.Because the main processing for the robot occurs on the remote computer, there are
no severe limitations to the amount of processing that I can do. For example, at the time

of this writing, the robot can follow an object by using its vision system. This capability

requires a fair amount of processing that would be difficult to carry on board.
Recently,Ihavebegunworkonarobotarmthatwillbeaddedtotherobot.A
prototypeofthearmisshowninFigureB-2.Althoughthereareseveralcommercial

robotarmsavailabletotheexperimenterandhobbyist,Idecidedtocreatemyown

becauseIwantedanarmthatwouldbestrongerandabletoliftheavierobjectsthan

was commonly available. The arm uses a stepper motor mounted at its base to turn a
long, threaded screw which opens and closes the gripper. This approach allows precise

movementalongwithconsiderablestrength.ThearmiscontrolledbyitsownStamp.Thus,

the main robot controller simply hands off arm commands to the second Stamp. This

allows fully parallel operation of the robot and the arm, and prevents bogging down

the main robot controller.
AlthoughthemainroboticcontrolcodewillalwaysremaininC++,Iamexperimenting
with migrating a couple of subsystems, including the RS-232 communication routines,
to C#. C# offers a convenient interface to IPdata transfers and being able to control the

robot from a remote location via the Internet is a tantalizing thought.
1008C++:TheCompleteReference
FigureB-2.
A prototype robot arm (Photo by Ken Kaiser)
Index& (bitwise operator), 43, 44& (pointer operator), 48, 49,115-116,141,167,170,262,347
& (reference parameter),
340-341, 347&&, 40, 41, 42
< >, 242, 268, 465, 483
–>, 51, 171, 176, 178, 329, 344overloading, 407, 413-414–>* (pointer-to-member
operator), 337, 338, 339* (multiplication operator), 37,38, 39* (pointer operator), 48-49,115-116, 124, 347
* (printf( ) placeholder), 202-203
|, 43, 44
||, 40, 41, 42
[ ], 51-52, 90, 145, 207, 350,351, 356overloading, 407-411
^, 43, 45, 207
:, 47, 271, 613
:: (scope resolution operator),
272, 319, 438-439, (comma operator), 50-51overloading, 414-416{ }, 8, 18, 58, 88
. (dot operator), 51, 165, 176,178, 272, 293, 344.* (pointer-to-member
operator), 337, 338!, 40, 41, 42
!=, 41, 42
=, 31, 35
= =, 41, 42
<, 41, 42
<< (left shift), 43, 45-46
<< (output operator), 262-264overloading, 526-532,794-795<=, 41, 42
–, 37, 38, 39
–  –, 38-39, 389-390, 393-395
( ) used for clarification inexpressions, 55-56
( ) function operator, 138
overloading, 407, 411-413
()precedenceoperator,40,
42,51
% (format specifier), 195
%(modulusoperator),37,38,39

+, 37, 38, 39
++, 38-39, 389-390, 393-395
# (preprocessor directive), 238

# (preprocessor operator),
248-249, 250# (printf( ) modifier), 202-203
## (preprocessor operator), 248,
249-250?, 47-48, 63-66>, 41, 42
>> (right shift), 43, 45-46
>> (input operator), 262,263-264overloading, 526, 532-535,794-795>=, 41, 42
; (semicolon), 88, 163
/, 37, 38, 39
/* */, 250-251
//, 252, 262
~, 43, 46-48, 285Aabort( ), 489, 490, 500, 503,504, 762abs( ), 762-763
_ _abstract keyword, 1000

Access declarations, 434-437
Access specifiers, 290, 418-425
accumulate( ) algorithm,920-921acos( ), 738
Ada, 5
Adaptor(s), 633, 876-878
Address, memory
& operator used to return,
48, 115-116
pointer as, 48, 115

relocatable format, 12
1009Copyright © 2003 by The McGraw-Hill Companies. Click here for terms of use. 
adjacent_difference( )
algorithm, 921-922adjacent_find( ) algorithm, 840adjustfield format flag, 514
advance( ), 872
Aggregate data type, 162

ALGOL, 6, 8
<algorithm> header, 664

Algorithms, 631, 635, 664-674,840-859table of STL, 665-667Allocation, dynamic.SeeDynamic allocationallocator class, 632, 879-880member functions,table of, 880Allocators, 632, 879-880
AND& bitwise operator, 43, 44

&& logical operator, 40,
41, 42ANSI/ISOC standard, 2, 4

C++standard,4,
256-257,267
app, 793
append( ), 688
argc, 144-145, 147

Arguments, function
call by reference passing
convention, 140-141, 170,
339-343call by value passingconvention, 139-140command line, 144-147
default, 371-378, 380
passing arrays as, 92-93, 98,102, 142-144passing functions as,126-129argv, 123, 144-147

Arithmetic operators, 37-40precedence of, 39
Array(s)allocating with new, 350-351

bounds checking on, 6, 91,367, 410compacting, 470-472
definition of, 90generating pointer to, 92
indexing versus pointerarithmetic, 121-122initialization, 105-107
multidimensional, 101-102
of objects, 326-329, 354,364-366to functions, passing, 92-93,142-144of pointers, 122-123
pointers to access, 103-104,121-122safe, creating, 367-369,
410-411
single-dimension, 90-91
sorting, 469-470
square brackets as operator
for indexing, 51-52of strings, 100-101
of structures, 166

within structures, 173

two-dimensional, 96-101
unsized, 106-107
variable-length, 4
vector as dynamic, 635Array-based I/O, 618-626and binary data, 625-626
using dynamic arrays and,624-625using ios member functionswith, 619Arrow operator (–>), 51, 171,
176, 178, 329, 344overloading, 407, 413-414asctime( ), 748-749
asin( ), 738-739
asm statement, 616-617
Assembly language, 5, 8-9using asm to embed,616-617C used in place of, 8, 42-43assert( ), 763
assign( ), 687-688
Assignmentcompound, 56
functions used in, 150,344-345multiple, 37
object, 324operation for C++ classes,default, 389operator, 35

pointer, 117, 332

shorthand, 56, 390
structure, 165-166

type conversion in, 35-37atan( ), 739
atan2( ), 739
ate, 793
atexit( ), 763
atof( ), 763-764
atoi( ), 146, 764
atol( ), 764
attribute, 1003
auto keyword, 18

auto_ptr class, 928-930BB language, 4
back_insert_iterator class,866, 867Backslash character constants,33-34bad( ), 563, 795
bad_alloc class, 348, 926
bad_cast, 578, 927
bad_exception class, 506, 926
bad_typeid, 572, 926
badbit, 561, 563, 794, 803
Base classaccess control, 418-424

constructors, passing
parameters to, 430-434definition of, 278, 418
general form for inheriting,279-280, 418inheritance, protected,
424-425virtual, 437-441base( ), 868
basefield format flag, 514
BASIC, 5, 6, 7, 8
basic_filebuf class, 788, 789
basic_fstream class, 512,
788, 789basic_ifstreamclass,512,
788,789
basic_iosclass,511,512,788,789
1010C++:TheCompleteReference
basic_iostream class, 511, 512,
788, 789basic_istream class, 511, 512,
788, 789basic_istringstream class,
788, 789basic_ofstream class, 512,
788, 789basic_ostream class, 511, 512,
788, 789basic_ostringstream class,
788, 789basic_streambuf class, 511, 512,
788, 789basic_string class, 683, 882-894constructors, 882
member functions, table of,884-894basic_stringbuf class, 788, 789
basic_stringstreamclass,788,
789BCPLlanguage, 4

before( ), 568-569

beg, 794
begin( ), 635, 636, 637, 641
BiIter, 632, 812

binary, 793

binary_function class, 679,873, 874binary_negate class, 875-876
binary_search( ) algorithm,
840-841bind1st( ) binder, 680-681,
874-875bind2nd( ) binder, 680-681,
874-875Binders, 633, 680-682, 874-875
BinPred type, 632, 812

Bit shift operators (>> and <<),43, 45-46Bit-fields, 162, 174-176
bitset container, 633, 634, 812,
814-816member functions, table of,815-816<bitset> header, 633, 812

Bitwise operation,definition of, 43Bitwise operators, 42-47table of, 43Block statements, 58, 88
bool data type, 14, 40, 58,59, 266_Bool data type, 59, 266
boolalphaformat flag, 514
manipulator, 522,
525-526, 791_ _box keyword, 1001

break statement, 67, 68, 69-70,
76, 83-85Broken-down time, 748

bsearch( ), 764-765

BUFSIZ macro, 719
C.C file extension, 12
C Programming Language, The
(Kernighan & Ritchie), 4C standard, ANSI/ISO, 2, 4

C89, 4-5
C99, 4-5
C++differences between C and,
130, 626-627differences between
old-style and modern,
267-270origins of, 256-257
and robotics, 1006, 1008

sample program, 260-263

Standard, 4, 257, 267
c_str( ), 692
Calendar time, 748
Call by reference, 140-141
automatic, using reference
parameter, 339-343
structure pointers
used for, 170
Call by value, 139-140
calloc( ), 758
Case sensitivity, 10, 17, 287

case statement, 67, 69-70
<cassert> header, 763

Casts, 54-55and base class pointers,334, 335C++ operators for, 55,
578-589and pointers, 116, 130-131
catch statement, 488-500, 502catch(...) form of, 498-500
and derived-classexceptions, 497general form of, 488
using multiple, 495-496<cctype> header, 724

ceil( ), 739-740
cerr, 512

<cerrno> header, 738

char data type, 14, 15
char_traits class, 789, 882,894-896member functions, table of,895-896Character(s)ASCII, 14, 547
in C console I/O, 189-191
constants, 32, 626
constants, backslash, 33-34
control, 724

printable, 724
set, extended, 547-548
wide.SeeWide character(s)
Character translationsin C I/O, 213, 217, 706
in C++ file I/O, 545, 557cin, 262, 512
Class(es)abstract, 455
access specifications,290-292base.SeeBase classcreating conversion
functions for, 603-607
declaration, general formfor, 271-272, 290
defining functions within,306-307, 309derived.SeeDerived classforward declaration of, 300

friend, 302-303
generic.SeeGeneric classinstance of, 271
libraries, 458
local, 320-321Index1011nested, 319overview of, 270-274
stream, 511-512

structures and, 293-295

unions and, 295-297class keyword, 270, 290, 295

Class member(s)accessing, public,272-273, 293definition of, 271, 292
initialization syntax,611-616
pointers to, 337-339
restrictions on, 292-293

static, 310-317clear( ), 795
clearerr( ), 700

<climits> header, 14

<clocale> header, 748

clock( ), 749
clock_t type, 748
CLOCKS_PER_SEC, 748, 749
clog, 512
close( ), 542
<cmath> header, 738

COBOL, 5, 7, 8
Codeblock, 8, 18-20
compartmentalization of,6-7, 8managed (.NETFramework), compiling,
1000, 1003Comma operator, 50-51
overloading, 414-416Command line arguments,
144-147Commentsin C89, 250-251
in C++ and C99, 4, 252, 262Common Language Runtime(CLR), 1000, 1003Comp type, 632, 812
compare( ), 692

Compilationconditional, 242-246
separate, 12, 27Compilerscompiling C programs with
C++, 12workingwitholderC++,270
complex class, 898-901functions defined for,
table of, 900-901<complex> header, 898

Compound data types, 162
Compound statements, 58, 88
Conditionalexpression,58,
66-67Conglomerate data type, 162
conio.h header file, 191
const qualifier, 23-24, 25

Constants, 32-34
const_cast, 586-588
Constructor(s), 283-287
copy, 322-323, 324, 366-369

and default arguments,
375-376execution order of, 317-318,
426-430explicit, 610-611

and inheritance, 426-434
and member initializationsyntax, 613-616overloading, 362-369
parameterized, 307-310
passing parameters to baseclass, 430-434containerprotectedvariable,867

Containers, 630-631, 812-837defined by STL, table of,633, 812-813string class and, 693-695
typedef names for, 634,
813-814continue statement, 86-87
copy( ) algorithm, 841
copy_backward()algorithm,
841cos( ), 740
cosh( ), 740
count( ), algorithm, 664, 665,668-669, 841count_if( ) algorithm, 664, 665,668, 669-670, 842cout, 262, 512_ _cplusplus predefined
macro, 250
.CPPfile extension, 12

<csetjump> header, 767, 770

<cstdarg> header, 722, 774

<cstdio> header, 188, 214-215,
700, 719, 721<cstdlib> header, 59, 758, 762

<csignal> header, 769, 771

<cstring> header, 94, 724

ctime( ), 749
<ctime> header, 748

ctype.h header file, 724
cur, 794

current protected member, 868

<cwchar> header, 776, 779,
782, 783<cwctype> header, 776
DDatacompartmentalizationof,6-7

in expressions, 14
Data type(s)aggregate, 162, 173

ANSI/ISO C, table of, 15
basic, 14-15
class as, 271
conversion of, inassignments, 35-37conversion of, inexpressions, 6, 53-54
creating and integrating
new C++, 961definition of, 6
modifiers for basic, 15-16_ _DATE_ _ predefined
macro, 250
decformat flag, 514, 791
manipulator, 522, 791
Decrement operator (– –), 38-39
overloading for prefix and
postfix, 389-390, 393-395default statement, 67
#define directive, 238-241
and function-like macros,
240-2411012C++:TheCompleteReference
and preprocessor operators
# and ##, 248-250defined compile-time operator,
247-248_ _delegate keyword, 1001
delete dynamic allocationoperator, 347-357, 758
and arrays, 350-351
and arrays of objects, 356
overloading, 398-403,406-407overloading for arrays,403-406deque container, 630, 633,
634-635, 812, 816-818member functions, table of,817-818<deque> header, 633, 812

Derived classaccess declaration within,434-436creating, 279

definition of, 278, 418
inheriting multiple baseclasses, 425-426objects, base class pointersto, 334-336Destructors, 284-287
execution order of, 317-318,
426-430and inheritance, 426-430difference_type, 863

difftime( ), 750

distance( ), 872
div( ), 762, 765-766
div_t type, 762, 765
divides( ) function object,677-678do-while loop, 7, 79-81
domain_error exception, 928

Dot operator (.), 51, 165, 176,178, 272, 293, 344double data type, 14, 15
Dynamic allocation, 129-131functions for, 130-131,
758-759operators for, 347-357, 758
dynamic_cast, 578-586EEarly binding, 458
EDOM, 738
#elif directive, 243, 244-245, 248

else, 59
#else directive, 243-245

empty( ), 646, 655
Encapsulation, 258, 265class as basic unit of, 290
and global variables, 315
how to achieve, 271, 292end, 794
end( ), 635, 636, 637, 641,649-651#endif, 243-245
endl manipulator, 522, 791

ends manipulator, 522, 791

enum keyword, 180

Enumerations, 162, 180-182
EOF macro, 189, 215, 220, 700

eof( ), 553-555, 563, 625, 795-796
eofbit, 794, 803
equal( )algorithm, 842
member function, 870equal_range( ) algorithm, 842
ERANGE, 738, 772, 773
erase( ), 634, 636, 637, 641,688-689errno, 700, 738, 772, 773
errno.h header file, 738
Error checking, run-time, 6

#error directive, 241

Errors
pointer, 131-135

See alsoException handlingEscape sequences, 33
_ _event keyword, 1001

exception class, 506, 794,926-927Exception handling, 348,488-507applying, 506-507
and catching all exceptions,498-500classes, 926-928
fundamentals, 488-497
and restricting exceptions,
500-502and rethrowing exceptions,
502-503<exception> header, 503, 504,
506, 926-927exceptions( ), 796
Exclusive OR.SeeXORexit( ), 85-86, 150, 490, 766
EXIT_FAILURE, 263, 762, 766

EXIT_SUCCESS, 263, 762, 766
exp( ), 740
explicit specifier, 610-611

export keyword, 485

Expression(s), 52-56
conditional, 58, 66-67
definition of, 14, 52
evaluation order, 52, 65

function calls used in, 64-65,149-150parser, 964-997

pointer, 116-120

production rules of, 966-967

statements, 58, 88
tokens, 969
type conversion in, 53-54extern storage class specifier,
25-27, 618Extractors, creating, 526,
532-535Ffabs( ), 741
facet class, 931
fail( ), 563, 796
failbit, 561, 563, 794, 803
failed( ), 872
failure class, 794

false, 40, 58, 266
fclose( ), 150, 217, 218-220, 701
feof( ), 220-221, 701
ferror( ), 224-225, 701-702

fflush( ), 226-227, 702

fgetc( ), 218, 702
fgetpos( ), 702-703
fgets( ), 192, 222, 232-233, 703
File(s), Cin C I/O system, 213-214
closing, 217
control structure, 213

erasing, 226Index1013opening, 215-217, 703-705pointer, 215, 216, 217
File(s), C++closing, 542
get pointer, 557, 561

opening, 540-542
put pointer, 557, 561

reading and writing
unformatted and binary,

545-553reading and writing text,
543-545FILE data type, 213, 215, 700
File position indicator, 213,
702-703, 708resetting, 223-224, 715

setting, 229-230_ _FILE_ _ predefined macro,
248, 250filebuf class, 540, 790
fill( )algorithm, 843
member function,521-522, 796fill_n( ) algorithm, 843
_ _finally keyword, 1001

find( )algorithm, 843
member function, 635, 659,662, 690-692find_end( ) algorithm, 843
find_first_of( ) algorithm,843-844find_if( ) alogrithm, 844
fixedformat flag, 514, 791
manipulator, 522, 791
flags( ), 518-520, 797
float data type, 14, 15
floatfield format flag, 514, 791
Floating-point constants, 32-33
floor( ), 741
flush manipulator, 522, 791

flush( ), 556-557, 797
fmod( ), 741
fmtflags enumeration, 513, 791
fopen( ), 215-217, 218-220, 233,703-705FOPEN_MAX macro, 215, 217

for loop, 7, 70-77declaringvariablewithin,81

general form of, 70-71
infinite, 76
variations of, 72-76
with no body, 77
for_each( ) algorithm, 844
ForIter, 632, 812

Formal parameters.SeeParameters, formalFormat flags, 513-520, 791
Forth, 5
FORTRAN, 5, 7, 257

Forward declaration, 300

fpos_t data type, 215, 700
fprintf( ), 230-232, 544, 705
fputc( ), 217, 705
fputs( ), 222, 705
fread( ), 227-228, 235, 706

free( ), 130-131, 348, 349,
758-759freeze( ), 625

freopen( ), 234-235, 706-707

frexp( ), 741-742

Friend classes, 302-303
Friend functions, 297-302andthethispointer,334,391
friend keyword, 298

front_insert_iterator class,
866, 867fscanf( ), 230-232, 544, 707
fseek( ), 215, 229-230, 707-708
fsetpos( ), 708
fstream class, 512, 540, 790

<fstream> header, 540, 790, 791

fstream( ), 797-798

ftell( ), 230, 708-709
Function(s), 7-8, 10arguments.
SeeArguments,
functionconversion, creating,
603-607formal parameters of.SeeParameters, formalfriend.SeeFriend functionsgeneral form of, 138generic.SeeGenericfunction(s)inline.SeeInline functionslibrary, 10-12, 697-698

main( ).Seemain( )member.
SeeMemberfunctionsobjects.SeeFunction objectspassing multidimensionalarrays to, 98, 102passing objects to, 320-323
passing single-dimensionarrays to, 92-93passing structures to,
167-169pointers to, 126-129
prototypes, 155-157, 626

predicate, 632

recursive, 153-155

return type, default
to int, 266returning from, 148-149

returning objects from,
323-324returning pointers from,
151-152returning references from,
344-345returning values from,
149-151scope rules of, 138-139

stand-alone, 7-8, 28
used in assignmentstatement, 344-345used in expressions, 64-65,
149-150virtual.SeeVirtual functions
void, 150, 152-153Function objects, 632-633,675-682, 872-878built-in, list of, 632, 675, 873
using binders with, 680-682,874-875creating, 678-680, 873
Function overloading, 275-278,360-371and ambiguity, 378-381

and constructors, 362-369
1014C++:TheCompleteReference
and function pointers,370-371versus default arguments,
376-377<functional> header, 632-633,
675, 872fwide( ), 779fwrite( ), 179, 227-228, 235, 709GGarbage collection, 1001
_ _gc keyword, 1001

gcount( ), 550-551, 798
generate( ) algorithm, 844-845
generate_n( ) algorithm,844-845Generated function, 462
Generic class, 472-484creating safe array with,
477-480default arguments and,
using, 481-483explicit specialization of,483-484general form of, 473
using non-type arguments
in, 479-480typeid and, 576-578Generic function(s), 460-472applying, 468-472
explicitly overloading,463-465general forms of, 460, 462
restrictions, 467-468
get( ), 546-547, 625, 798-799member function ofauto_ptr, 929-930
overloaded forms of, 551Get pointer, 557, 804, 808

getc( ), 218, 219-220, 709
getch( ), 190-191, 193
getchar( ), 189-191, 192, 193,205, 710getche( ), 190-191, 193
getenv( ), 766
getline( ), 551-553, 799-800
gets( ), 143, 144, 192, 193, 205,222, 232, 710gmtime( ), 750good( ), 563, 800
goodbit, 561, 563, 794, 803
goto statement, 7, 83, 138
greater( ) function object,
680-682gslice class, 917, 919-920
gslice_array class, 920HHeaders and header files, 27,157, 242, 261, 268-269, 603Heap, 130, 131, 758
hexformat flag, 514, 791
manipulator, 522, 791
Hexadecimal constants, 33
Hierarchical classifications, 418

Hoare, C.A.R., 769

HUGE_VALmacro, 738, 772
I_ _identifier keyword, 1001

Identifiers, 16-17, 626
#if directive, 243-244, 245, 247

if statementdeclaring variable within,81-82general form of, 59
if-else-if ladder, 62-63

nested, 60-62
? as alternative to, 63-66#ifdef directive, 245-246

#ifndef directive, 245, 246

ifstream class, 512, 540, 790

ifstream( ), 797-798

ignore( ), 555-556, 800

imag( ), 899
in, 793
#include directive, 242, 268, 269

includes( ) algorithm, 845
Increment operator (++), 38-39
overloading for prefix and
postfix, 389-390, 393-395indirect_array class, 920

Inheritance, 259, 278-283,418-441access declaration in,434-437access specifiers and,418-425constructors, destructors,
and, 426-434multiple base class, 425-426
and virtual base classes,437-441and virtual attribute offunctions, 448-450InIter, 632, 812

Inline functions, 303-307within a class, defining,305-306inline keyword, 241, 303, 306
and C99, 305inner_product( ) algorithm,
922-923inplace_merge( ) algorithm, 845

Input operator (>>), 262,263-264overloading, 526, 532-535,794-795insert( ), 634, 636, 637, 641, 643,646, 648, 688, 689insert_iterator class, 864-866
inserter( ), 865
Inserters, creating, 526-532

int data type, 14, 15default to, 265-266, 627
unsigned versus signed, 16Integerssigned vs. unsigned, 16
size of, 14_ _interface keyword, 1001

internalformat flag, 513, 791
manipulator, 522, 792
int_type data type, 555
invalid_argumentexception,928

I/O, C-style, 188functions, 700-722, 779, 780I/O, C console, 188-209basic functions for,
table of, 193and characters, 189-191
formatted, 195-209
and strings, 191-194I/O, C file, 212-235common functions for,
table of, 214Index1015connection with consoleI/O, 233-234files in, 212, 213-214.See alsoFile(s), Cformatted, with fprintf( )and fscanf( ), 230-232random-access, 229-230reading and writing a
character in, 217-218reading and writing blocks
of data in, 227-228streams in, 212-214.
See alsoStreams
and strings, 222I/O, C++array-based.SeeArray-based I/Obyte-oriented vs.character-oriented,

545-546formatted, 513-526
functions, 795-809
headers, 790-791
manipulators.SeeManipulatorsold vs. modern, 510
operators.SeeOperators,I/Opredefined streams, 512-513

streams, 511

template classes, 511-512,
788-790I/O, C++ file, 540-566customized I/O and,563-566flushing buffers in, 556-557

random access, 557-561, 814
status, obtaining, 561-563
See alsoFiles, C++_IOFBF, 719

_IOLBF, 719

<iomanip> header, 523, 790,
791, 792_IONBF, 719

ios class, 512, 540, 619, 789
<ios> header, 790

ios::app, 541, 801ios::ate, 541, 801
ios::badbit, 561
ios::beg, 557, 804
ios::binary, 541, 545, 801

ios::cur, 557, 804

ios::end, 557, 804
ios::eofbit, 561
ios::failbit, 561
ios::goodbit, 561
ios::in, 541, 801
ios::out, 541, 801
ios::trunc, 541, 801

ios_base class, 511, 788, 789

<iosfwd> header, 790, 793

iostate enumeration, 561, 794
iostream class, 512, 619, 789

<iostream> header, 260, 278,
510, 512, 790, 791iostream.h header file, 510

is_open( ), 542
isalnum( ), 724
isalpha( ), 724
iscntrl( ), 725
isdigit( ), 725
isgraph( ), 725
islower( ), 725-726
isprint( ), 726
ispunct( ), 726
isspace( ), 726
istream class, 512, 532, 619, 789

<istream> header, 790

istream_iterator class, 868-869

istream_type type, 869, 870

istreambuf_iterator class, 869

istringstream class, 790

istringstream( ), 806-807

istrstream class, 619, 621, 622

isupper( ), 727
iswctype( ), 776-778
isxdigit( ), 727
Iteration statements, 58, 70-81declaringvariables
within,81
Iterator(s), 631, 635, 639-641,812, 862-872functions, 872
predefined, 864-872
iteratorclass, 863
type, 631, 641, 863<iterator> header, 862, 863

iterator_category type, 863
iterator_traits class, 864
iter_swap( ) algorithm, 845JJava, 5, 7
jmp_buf type, 767
Jump statements, 58, 68, 82-87Kkbhit( ), 84
Kernighan, Brian, 4
Keywords
C, 6, 8
C89, table of, 10
C++, table of, 287-288
extended, common, 10
.NETFrameworkextensions
toC++,1000-1002
LL_tmpnam, 721
Labelidentifier for gotostatement, 83statements, 58, 67labs( ), 766
Language(s), computerblock-structured, 6, 139

high-level, 5-6
middle-level, C as, 5-6
programmer’s, C as, 8-9

structured, C as, 6-8,
257-258Late binding, 458
LC_ALL, 753
LC_COLLATE, 753

LC_CTYPE, 753
LC_MONETRAY, 753

LC_NUMERIC, 753
LC_TIME, 7531016C++:TheCompleteReference
lconv structure, 750-751
ldexp( ), 742
ldiv( ), 762, 767
ldiv_tstructure,762,
765-766,767
leftformat flag, 513, 791
manipulator, 522, 792
length_error exception, 928

less( ) function object, 632,633, 658lexicographical_compare( )
algorithm, 846Libraryclass, 11, 458, 785-786, 898

standard function, 10-12,
697-698standard template.
SeeStandard template

library (STL)<limits> header, 931

#line directive, 248

_ _LINE_ _ predefined macro,
248, 250Line-buffered input, 190

Linkagecategories of, 25
specification, 617-618Linker, 12, 27

list container, 630, 633, 634-635,
645-657, 812, 819-822member functions, table of,646-647, 819-822<list> header, 633

Literals, 32
locale class, 931
<locale> header, 931

locale.h header file, 748
localeconv( ), 750-752
LocalizationC functions for, 748,
750-751, 752-754class library, 931
localtime( ), 752
log( ), 742
log10( ), 742-743
logic_error class, 928
Logical operators, 40-42truth table for, 40
long modifier, 15-16

LONG_MAX, 772
LONG_MIN, 772
longjmp( ), 507, 767, 770
Loopsdo-while, 7, 79-81
for.
Seefor loopinfinite, 76
and structured languages, 7

time delay, 77

while, 7, 77-79
with no bodies, 77lower_bound( ) algorithm, 846
lvalue, 35MMacro
function-like, 240-241
name, 238
predefined, 250

replacement, 238
main( ), 10, 156, 627argc and argv as arguments
to, 144-147return value from, 153

using void in parameter listof, 147make_heap()algorithm,846-847

make_pair( ), 660-661, 662,930-931malloc( ), 130-131, 348, 349, 356,758, 759managed pragma, 1002
Manipulatorscreating custom, 535-538

to format I/O, using,522-526table of C++, 522-523,791-792map container, 631, 633, 634,
658-664, 813, 822-824member functions, table of,659-660, 823-824<map> header, 633, 813

mask_array class, 920math.h header file, 738
max( ) algorithm, 847
max_element( ) algorithm, 847
MB_CUR_MAX, 762, 774
mblen( ), 767-768
mbstate_t type, 776, 783
mbstowcs( ), 768
mbtowc( ), 768
mem_fun( ) adaptor, 877

mem_fun_ref( ) adaptor, 878

mem_fun_ref_t class, 878

mem_fun_t class, 877-878
mem_fun1( ) adaptor, 877

mem_fun1_ref( ) adaptor, 878

mem_fun1_ref_t class, 878

mem_fun1_t class, 877-878
Member functions, 271, 272, 292const, 607-609
and scope resolution
operator, 272
static, 315-317
and the this pointer, 332-334

volatile, 609
within class, defining,306-307, 309Member variables, 271, 272,292, 293initialization syntax for,
611-616
static, 310-315memchr( ), 727
memcmp( ), 727-728
memcpy( ), 728
memmove( ), 728
<memory> header, 879, 928, 931

memset( ), 729
merge( ), 647, 648, 653-655
algorithm, 847-848Metadata, 1002
Microsoft Intermediate
Language (MSIL), 1000min( ) algorithm, 848
min_element( ) algorithm, 848
mismatch( ) algorithm, 848-849
mktime( ), 752
modf( ), 743
Modula-2, 5, 6, 7, 8
<mscorlib.dll>, 1002Index1017multimap container, 633, 634,
658, 813, 824-826member functions, table of,825-826multiset container, 633, 634,
813, 827-829member functions, table of,827-829mutable keyword, 25, 608-609
Nname( ), 568, 569Namespace, 30, 261, 269-270,592-603unnamed, 598-599namespace statement, 267, 270,592-593NDEBUG, 763
negate( ) function object, 675,676-677Negators, 633, 682, 875-876
.NET Framework, 1000-1003C++ keyword extensions,
1000-1002preprocessorextensions,
1002new dynamic allocationoperator, 347-357, 758, 926
and allocating arrays,350-351and allocating objects,351-356and initializing memory,
349-350overloading, 398-403,406-407overloading for arrays,403-406placement form of, 357<new> header, 348, 356

next_permutation( )algorithm, 849noboolalpha manipulator,
522, 792_ _nogc keyword, 1001

noshowbase manipulator,
522, 792noshowpoint manipulator,
522, 792noshowpos manipulator,
522, 792noskipws manipulator, 523, 792

nounitbuf manipulator, 523, 792

nouppercase, 523, 792

NOT! logical operator, 40, 41, 42

~ bitwise operator, 43, 46-48
not1( ) negator, 682, 875

not2( ) negator, 682, 875

nothrow option for new, 356
overloading, 406-407nothrow_t data type, 407

npos constant, 685, 863
nth_element( ) algorithm, 849
Nulldefinition of, 94
statement, 88NULLmacro, 215, 762

Numericclasses, 898-924
constants, 32-33numeric_limits class, 931OObject(s)allocating, 351-356
arrays of, 326-329, 354,364-366assignment, 324
base class pointers toderived class, 334-336base class references to
dervied class, 346creating, 271

definition of, 258, 290
factory, 574

function.SeeFunctionobjectstofunctions,passing,
320-323from functions, returning,
323-324initialization, 283, 307, 309,310, 367passingreferencesto,
343-344pointers to, 329-331Object-oriented programming
(OOP), 256, 257-259octformat flag, 514, 791
manipulator, 523, 792
Octal constants, 33
off_type type, 793, 804

ofstream class, 512, 540, 790

ofstream( ), 797-798

One’s complement operator (~),43, 46-48OOP(Object-oriented
programming), 256, 257-259
open( ), 540-542, 800-801
openmode, 541, 793
Operator(s)arithmetic, 37-40
arrow.
SeeArrow
operator (–>)assignment, 35
bitwise, 42-47
casting, 54-55, 578-589
comma, 50-51
compile-time, 50
dot, 51, 165, 176, 178, 272,293, 344dynamic allocation, 347-357
pointer, 48-49, 115-116, 347

pointer-to-member (.* and
–>*), 337, 338, 339precedence of C, 52, 53

relational and logical, 40-42

scope resolution, 272, 319,
438-439ternary (?), 47-48, 63-66operator functionscreating member, 384-391

definition of, 384
using friend, 391-398operator keyword, 384

Operator overloading, 278,384-416[ ], ( ), and –>, 407-414
comma, 414-4161018C++:TheCompleteReference
increment and decrement,
389-390, 393-395newanddelete,398-407,758
restrictions, 390-391

shorthand, 390
See alsooperator functionsoperator( ), 632, 675, 678-680,872, 876, 877Operators, I/O (<< and >>),262-264overloading, 526-535,794-795ORbitwise operator (|), 43, 44
logical operator (||), 40,41, 42ostream class, 512, 526, 619, 789

<ostream> header, 790

ostream_iterator class, 870-871

ostream_type, 870, 872

ostreambuf_iterator class,
871-872ostringstream class, 790

ostringstream( ), 806-807

ostrstream class, 619, 624

out, 793
out_of_range exception, 928
OutIter, 632, 812

Output operator (<<), 262-264overloading, 526-532,794-795overflow_error exception, 928

overload keyword, 287, 371

Overloading functions.SeeFunction overloadingOverloading operators.SeeOperator overloadingOverriding versus functionoverloading, 446-447Ppair template class, 632, 660,662, 930-931Paragraph alignment, 183
Parallax, Inc., 1007
Parameters, formal, 21, 139, 626declarations, classic versusmodern, 158-159reference, 141, 339-343, 346
variable number of, 158Parity bit, 43, 44
partial_sort( ) algorithm,849-850partial_sort_copy( )algorithm, 850partial_sum( ) algorithm,923-924partition( ) algorithm, 850
Pascal, 5, 6, 257
pcount( ), 620
peek( ), 556, 801
perror( ), 710-711

_ _pin keyword, 1002

plus( ) function object, 675
POD (Plain Old Data), 295, 296
Pointer(s), 114-135
accessing arrays with,103-104, 121-122arithmetic, 103, 117-118

to arrays, generating, 92
arrays of, 122-123
assignments, 117, 332

base type of, 49, 115, 118

C file, 215, 216, 217
C++ file, 557
to class members, 337-339
comparisons, 119-120, 133

definition of, 48, 114

to derived class objects,334-336dynamic allocation and,129-131to functions, 126-129
indexing, 102-104
initializing, 125-126, 132,134-135to objects, 329-331
operators, 48-49,115-116, 347
to pointers, 123-124
problems with, 131-135

returned from functions,
151-152structure, 169-173

this, 315, 332-334
typeid and base-class,570-572void*, 130pointer type, 863
pointer_to_binary_functionclass, 876-877pointer_to_unary_functionclass, 876, 877Polymorphism, 258-259through function
overloading, 275, 276, 360through operator
overloading, 278Polymorphism, run-time
through inheritance and
virtual functions, 283,
336, 444, 446, 455-458through RTTI and casting
operators, 568pop_back( ), 634
pop_front( ), 635

pop_heap( ) algorithm, 850-851
Portability, 6
using sizeof to ensure,
183-184using typedef to aid,184-185pos_typedatatype,561,793,804

pow( ), 743
#pragma directive, 248

precision( ), 520-522, 802

Predicate functions, 632

Preprocessor directives, 238-248

Preprocessor operators, 248-250

prev_permutation( )
algorithm, 851printf( ), 117, 134, 192, 195-203,
233, 711-713
in C++ program, 262

format specifiers, table of,195-196, 712returnvalueof,150,195,711
priority_queue container, 633,
813, 830-831member functions,table of, 831private access specifier, 290, 418
effects of, 419-420
Program(s)
general form of C, 10, 11

general form of C++, 288
systems, 9Index1019_ _property keyword, 1002
protected access specifier, 290,
418, 420effects of, 420-425
Prototypes,function,
155-157,626
ptr_fun( ) adaptor, 876-877

ptrdiff_t type, 664, 842, 863

public access specifier, 271,
290, 418effects of, 418-419
push_back( ), 634, 636, 637, 646,647, 649, 651-652, 867push_front( ), 635, 647, 648,
651-652, 867push_heap( ) algorithm, 851
Put pointer, 557, 804, 808

put( ), 546, 547-548, 626, 802
putback( ), 556, 802
putc( ), 217-219, 714
putchar(),189-190,193,232,714

puts( ), 192-194, 714Qqsort( ), 768-769
queue container, 633, 813,
829-830member functions, table of,829-830<queue> header, 633, 813

Quicksort, 155, 769Rraise( ), 769
rand( ), 59, 574, 770
RAND_MAX, 59, 762, 770
RandIter, 632, 812

Random-access I/O, 229-230,557-561, 804random_shuffle( ) algorithm,
851-642range_error exception, 928

raw_storage_iterator class, 931
rdstate( ), 561-563, 802-803

read( ), 548-551, 626, 803

readsome( ), 803-804
real( ), 899

realloc( ), 758, 759

Recursion, 153-155
Reference(s)
definition of, 339
independent, 345-346
to objects, passing, 343-344
parameters, 339-343, 346,393-394restrictions, 347

returning, 344-345

typeid and, 572-573
and virtual functions,447-448reference type, 863

register storage class specifier,
30-31, 627reinterpret_cast, 588-589

Relational operators, 40-42
release( ), 929

Relocatable format, 12
remove( ), 226, 715
algorithm, 852remove_copy( ) algorithm, 666,
670-672, 852remove_copy_if()algorithm,
852remove_if( ) algorithm, 666,
681-682, 852rename( ), 715

replace( ), 688, 689
algorithm, 852-853replace_copy( ) algorithm, 666,
670-672, 852-853replace_copy_if( ) algorithm,
852-853replace_if( ) algorithm, 852-853

resetiosflags manipulator,
523, 792restrict qualifier, 4

return statement, 82
using to return from
a function, 148-149using to return a value, 149
reverse( ) algortihm, 667,
672-673, 853reverse_copy( ) algorithm, 853

reverse_iterator class, 868
rewind( ), 223-224, 715

rfind( ), 690-692
Richards, Martin, 4

rightformat flag, 513, 791
manipulator, 523, 792
Ritchie, Dennis, 4
Robotics, 1006-1008
rotate( ) algorithm, 853

rotate_copy( ) algorithm,
853-854Run-time type identification(RTTI), 568-578
runtime_error class, 928

rvalue, 35SScalar, 59

scanf( ), 195, 203-209, 262,715-719format specifiers, table of,204, 716Scanset, 206-207, 718-719
scientificformat flag, 514, 791
manipulator, 523, 792
Scope resolution operator (::),
272, 319, 438-439Scope rules, 138

_ _sealed keyword, 1002

search( ) algorithm, 854

search_n( ) algorithm, 854

SEEK_CUR macro, 215, 229, 708

SEEK_ENDmacro,215,229,708

SEEK_SET macro, 215, 229,
230, 708seekdir enumeration, 557,794, 804seekg( ), 557-560, 804
seekp( ), 557-560, 804
Selection statements, 58, 59-70declaring variables within,81-82set container, 633, 634, 813,
831-833member functions, table of,832-8331020C++:TheCompleteReference
<set> header, 633, 813
set_difference( ) algorithm,
854-855set_intersection()algorithm,855

set_symmetric_difference( )
algorithm, 855-856set_terminate( ), 504
set_unexpected( ), 504
set_union( ) algorithm, 856
setbase manipulator, 523, 792

setbuf( ), 719
setf( ), 514-515, 805overloaded, 516-518setfill manipulator, 523, 792

setiosflags( ) manipulator, 523,
525, 792setjmp( ), 507, 767, 770
setlocale( ), 752-753
setprecision manipulator,
523, 792setvbuf( ), 719-720
setw manipulator, 523, 792

short modifier, 15-16

Shorthand assignmentoperators, 56, 390showbaseformat flag, 514, 791
manipulator, 523, 792
showpointformat flag, 514, 791
manipulator, 523, 792
showposformat flag, 514, 791
manipulator, 523, 792
SIG_DFL, 771
SIG_ERR, 771
SIG_IGN, 771
SIGABRT, 769

SIGFPE, 769
SIGILL, 769
SIGINT, 770

Sign flag, 16
signal( ), 770-771
signed modifier, 15-16

SIGSEGV, 770

SIGTERM, 770
sin( ), 150, 743
sinh( ), 744
size( ), 636, 637
sizeof operator, 50, 131, 183-184
size_t data type, 50, 130, 215,398, 700, 724, 762, 776skipwsformat flag, 513, 791
manipulator, 523, 792
slice class, 917-919
slice_array class, 920
sort( ), 647, 652-653algorithm, 856sort_heap( ) algorithm, 856-857
splice( ), 647, 648
sprintf( ), 720
sqrt( ), 150, 744
sscanf( ), 720
sqrt( ), 150, 744
srand( ), 771
<sstream> header, 790

stable_partition()algorithm,857

stable_sort( ) algorithm, 857
Stackand local variables, 20
and recursive routines, 154
stack container, 633, 813,
833-834member functions,table of, 834<stack> header, 633, 813

Standard C++, 4, 257, 267

Standard template library
(STL), 11, 256-257, 630-695
elements of, 630-634
general theory of operation,634-635Statements, 57-88
static storage class specifier,
28-30, 310static_cast, 588
std namespace, 261, 269-270,510, 592, 601-603stdarg.h header file, 722

<stdbool.h> header, 266

_ _STDC_ _ predefined
macro, 250
stderr standard stream, 232-233

<stdexcept>header,926,927-928

stdin standard stream, 232-234

stdio.h header file, 188,214-215, 700stdlib.h header file, 59, 759, 762
stdout standard stream, 232-234
Stepanov, Alexander, 256

Storage class specifiers, 25-31
str( ), 624, 806
strcat( ), 94-95, 685, 729

strchr( ), 94-95, 729

strcmp( ), 74, 94-95, 128, 730

strcoll( ), 730

strcpy( ), 94-95, 684, 685, 731

strcspn( ), 731

Stream(s)
binary, 212, 213

C++, 510
for C++ array-based I/O,619-623for C++ file I/O, 540
classes, 510-512, 540,618-619flushing, 226-227
predefined C++, 512-513

redirecting standard, 232,
233-235, 512standard C, 232-233

text, 212-213streambuf class, 512, 790

<streambuf> header, 791

streambuf_type, 872

streamoff data type, 793

streampos data type, 793

streamsize data type, 548, 793

strerror( ), 731

strftime( ), 753-754
Stride, 918
String(s)as arrays, 90, 94-95
arrays of, 100-101
class, creation of custom,
936-961classes, Standard C++, 94,
630, 683-695, 882-896in console I/O, 192-194
constant, 33, 94, 126
in C file I/O, 222
limitations ofnull-terminated, 683-684manipulation functions,94-95substring subtraction from,
936, 945-946table, 126Index1021string class, 94, 630, 683-695,882, 884and containers, 693-695dynamic aspect of, 687
member functions, 687-692
operators defined for, 685
<string> header, 684

string.h header file, 724
stringbuf class, 790
stringstream class, 790

stringstream( ), 806-807

strlen( ), 24, 79, 94-95, 731-732
strncat( ), 732
strncmp( ), 732
strncpy( ), 733
Stroustrup, Bjarne, 256, 267

strpbrk( ), 733
strrchr( ), 733

strspn( ), 734
strstr( ), 94-95, 734
strstream class, 619, 623, 625

<strstream> header, 618

strtod( ), 771-772
strtok( ), 734
strtol( ), 772
strtoul( ), 772-773
struct keyword, 162, 163, 295

Structure(s), 162-174
arrays of, 166
arrays and structures
within, 173-174assignments, 165-166
and classes, 293-295
declaration, 162-163,164-165members, accessing, 165,171, 173passing to functions,167-169pointers, 169-173
size of, determining, 183
variable, declaring, 163-164strxfrm( ), 735
swap( ) algorithm, 857
swap_ranges( ) algorithm, 858
switch statement, 67-70declaringvariablewithin,81
sync_with_stdio( ), 807
system( ), 773
Systems program, 9
Ttan( ), 744
tanh( ), 744
tellg( ), 561, 808
tellp( ), 561, 808
Template function.
SeeGenericfunction(s)template keyword, 460

template< > syntax, 465, 483
Templates, 460-485
advantages to using, 485
definition of, 460
See alsoGeneric class;Generic function(s)terminate( ), 489, 503-505
terminate_handlertype,504,927

Ternaryoperator(?),47-48,63-66

thispointer,315,332-334,
386,391
Thompson, Ken, 4
throw statement, 489-490,
502-503throw( ) clause, 500

Time and date functions,
748-755Time delay loops, 77

time.h header file, 748
time( ), 754-755
_ _TIME_ _ predefined
macro, 250
time_t data type, 748
tm structure, 748

TMP_MAX, 721
tmpfile( ), 720-721
tmpnam( ), 721
Token, 969

tolower( ), 735
toupper( ), 735
towctrans( ), 778-779
transform( ) algorithm, 667,673-674, 676-678, 858true, 40, 58, 266
True and false in C and C++,
40, 58trunc, 793

try statement, 488-493, 501-502
_ _try_cast keyword, 1002

Two’s complement, 16

Type checking and C++
pointers, 549Type conversion
and ambiguity in functionoverloading, 378-380in assignments, 35-37
in expressions, 53-54

using unions fornonstandard, 178-179
Type promotion, 53

type_info class, 568, 931
typedef statement, 162, 184-185
typeid, 568-578, 926-927using dynamic_cast toreplace, 582-584
<typeinfo> header, 568, 931

typename keyword, 460,
484-485_ _typeof keyword, 1002

Types.
SeeData typesUULONG_MAX, 773
unary_function class, 678,873-874unary_negate class, 875, 876
uncaught_exception( ), 505
#undef directive, 246-247

underflow_error exception, 928

unexpected( ), 500, 501,503-504, 926unexpected_handler type,504, 927ungetc( ), 721-722
union keyword, 177

Unions, 162, 176-179, 184anonymous, 179, 296-297
and classes, 295-297
for nonstandard type
conversions, 178-179size of, determining, 1841022C++:TheCompleteReference
unique( ) algorithm, 858-859unique_copy( ) algorithm,858-859unitbufformat flag, 514, 791
manipulator, 523, 792
UNIX, 4
unmanaged pragma, 1002
UnPred type, 632, 812

unsetf( ), 515-516, 808
unsigned modifier, 14-16

upper_bound( ) algorithm, 859
uppercase
format flag, 514, 791
manipulator, 523, 792
#using preprocessor
directive, 1002
using statement, 261, 270, 434,437, 596-598<utility> header, 632, 931
Vva_arg( ), 773-774

va_end( ), 773-774
va_list type, 722, 774
va_start( ), 773-774
valarray class, 902-920member functions, table of,903-907nonmember operatorfunctions defined for,

table of, 908-913transcendental functionsdefined for, table of,

914-915<valarray> header, 902

_ _value keyword, 1002

Variables, 17-23
automatic, 18
declaration vs.definition of, 26declaring, 17-18, 81-82
as formal parameters, 21
initializing, 31-32
instance, 292member.
SeeMembervariablesplacement in memory, 133

pointer, 48-49, 115

reference.
SeeReference(s)
register, 30-31

storage class specifiers for,
25-31structure, 163-164
Variables, global, 7, 21-23
declarations, difference
between C and C++, 626and encapsulation, 315
extern used with, 25-27
static, 29-30, 598-599Variables, local, 6-7, 18-20,
21, 22declarations, differences
between C and C++,
19-20, 264-265, 626initializing, 20
static used with, 20, 28-29,30, 139vector container, 630, 633, 634,
635-645, 813, 834-837member functions, table of,637, 835-837<vector> header, 633, 813

vfprintf( ), 722
Virtual functions, 444-458
and base-class references,
447-448and class libraries, 458
hierarchical nature of,
450-453and inheritance of virtualattribute, 448-450and late binding, 458
overloading versusoverriding and, 446-447pure, 453-455

using, 455-458virtual keyword, 440, 444, 445

Visual C++ compiler, 191

void data type, 14, 15, 153,261, 626volatile access modifier,
24-25, 609vprintf( ), 722
vsprintf( ), 722Wwchar.h header file, 776

WCHAR_MAX, 776
WCHAR_MIN, 776
wchar_t data type, 14, 32, 513,698, 776wcstombs( ), 774
wctomb( ), 774
wctrans( ), 778-779
wctrans_t type, 776
wctype.h header file, 776
wctype( ), 776-778
wctype_t type, 776
WEOF macro, 776

werr, 513

what( ), 794, 926
while loop, 7, 77-79declaringvariablewithin,81
Wide character(s), 511, 513, 545
functions, 776-784
I/O classes, 512, 789-790width( ), 520, 521-522, 808-809
win, 513
wint_t type, 776
wlog, 513
Word alignment, 183

wout, 513
write( ), 548-551, 626, 809
ws manipulator, 523, 792

wstreampos type, 793

wstring class, 683, 862, 864XXORbitwise operator (^), 43, 45logical operation, 40-42Index1023INTERNATIONAL CONTACT INFORMATIONAUSTRALIA
McGraw-Hill Book Company Australia Pty. Ltd.

TEL +61-2-9900-1800
FAX +61-2-9878-8881

http://www.mcgraw-hill.com.au

books-it_sydney@mcgraw-hill.com
CANADA
McGraw-Hill Ryerson Ltd.

TEL +905-430-5000
FAX +905-430-5020

http://www.mcgraw-hill.ca
GREECE, MIDDLE EAST, & AFRICA
(ExcludingSouth Africa)

McGraw-Hill Hellas

TEL +30-210-6560-990
TEL +30-210-6560-993
TEL +30-210-6560-994
FAX +30-210-6545-525
MEXICO (Also serving Latin America)
McGraw-HillInteramericanaEditoresS.A.deC.V.

TEL +525-117-1583
FAX +525-117-1589

http://www.mcgraw-hill.com.mx

fernando_castellanos@mcgraw-hill.com
SINGAPORE (Serving Asia)
McGraw-Hill Book Company

TEL +65-863-1580
FAX +65-862-3354

http://www.mcgraw-hill.com.sg

mghasia@mcgraw-hill.com
SOUTH AFRICA
McGraw-Hill South Africa

TEL +27-11-622-7512
FAX +27-11-622-9045

robyn_swanepoel@mcgraw-hill.com
SPAIN
McGraw-Hill/Interamericana de España, S.A.U.

TEL +34-91-180-3000
FAX +34-91-372-8513

http://www.mcgraw-hill.es

professional@mcgraw-hill.es
UNITED KINGDOM, NORTHERN,
EASTERN, & CENTRAL EUROPE

McGraw-Hill Education Europe

TEL +44-1-628-502500
FAX +44-1-628-770224

http://www.mcgraw-hill.co.uk

computing_europe@mcgraw-hill.com
ALL OTHER INQUIRIES Contact:
Osborne/McGraw-Hill

TEL +1-510-549-6600
FAX +1-510-883-7600

http://www.osborne.com

omg_international@mcgraw-hill.com
